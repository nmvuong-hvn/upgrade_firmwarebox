<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/Constants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/Constants.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import java.util.concurrent.TimeUnit&#10;&#10;object Constants {&#10;    const val RANGE_HEADER = &quot;Range&quot;&#10;    const val ETAG_HEADER = &quot;ETag&quot;&#10;    val CONNECT_TIMEOUT = TimeUnit.SECONDS.toSeconds(60)&#10;    const val HTTP_OK = 200&#10;    const val HTTP_PARTIAL_CONTENT = 206&#10;&#10;    // Download States&#10;    const val STATE_IDLE = 0&#10;    const val STATE_DOWNLOADING = 1&#10;    const val STATE_PAUSED = 2&#10;    const val STATE_COMPLETED = 3&#10;    const val STATE_FAILED = 4&#10;    const val STATE_CANCELLED = 5&#10;    const val STATE_WAITING_FOR_NETWORK = 6&#10;&#10;    // Buffer and retry settings&#10;    const val BUFFER_SIZE = 8192&#10;    const val MAX_RETRY_ATTEMPTS = 3&#10;    const val RETRY_DELAY_MS = 2000L&#10;    const val NETWORK_CHECK_INTERVAL_MS = 1000L&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import java.util.concurrent.TimeUnit&#10;&#10;object Constants {&#10;    const val RANGE_HEADER = &quot;Range&quot;&#10;    const val ETAG_HEADER = &quot;ETag&quot;&#10;    val CONNECT_TIMEOUT = TimeUnit.SECONDS.toSeconds(60)&#10;    const val HTTP_OK = 200&#10;    const val HTTP_PARTIAL_CONTENT = 206&#10;&#10;    // Download States&#10;    const val STATE_IDLE = 0&#10;    const val STATE_DOWNLOADING = 1&#10;    const val STATE_PAUSED = 2&#10;    const val STATE_COMPLETED = 3&#10;    const val STATE_FAILED = 4&#10;    const val STATE_CANCELLED = 5&#10;    const val STATE_WAITING_FOR_NETWORK = 6&#10;&#10;    // Buffer and retry settings&#10;    const val BUFFER_SIZE = 8192&#10;    const val MAX_RETRY_ATTEMPTS = 3&#10;    const val RETRY_DELAY_MS = 2000L&#10;    const val NETWORK_CHECK_INTERVAL_MS = 1000L&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DatabaseResumeExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DatabaseResumeExample.kt" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.example&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.lifecycle.lifecycleScope&#10;import com.marusys.downloadsdk.Constants&#10;import com.marusys.downloadsdk.DownloadListener&#10;import com.marusys.downloadsdk.DownloadManager&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.*&#10;import java.io.File&#10;&#10;/**&#10; * Complete example demonstrating Room database integration for resuming downloads&#10; * when the app is reopened&#10; */&#10;class DatabaseResumeExample(private val context: Context) {&#10;    &#10;    private val downloadManager = DownloadManager.getInstance()&#10;    &#10;    /**&#10;     * Initialize download manager in your Application class or MainActivity&#10;     */&#10;    fun initializeDownloadManager() {&#10;        // Initialize with automatic resume of incomplete downloads&#10;        downloadManager.initialize(&#10;            context = context,&#10;            autoResumeIncompleteDownloads = true // This will resume downloads when app opens&#10;        )&#10;        &#10;        Log.d(&quot;DatabaseResume&quot;, &quot; DownloadManager initialized with database persistence&quot;)&#10;        Log.d(&quot;DatabaseResume&quot;, &quot; Incomplete downloads will be automatically loaded and ready to resume&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Start a new download that will be persisted to database&#10;     */&#10;    fun startPersistentDownload() {&#10;        val downloadRequest = DownloadRequestFileModel(&#10;            downloadId = System.currentTimeMillis(),&#10;            fileName = &quot;firmware_persistent.bin&quot;,&#10;            url = &quot;https://example.com/firmware_persistent.bin&quot;,&#10;            downloadedBytes = 0L&#10;        )&#10;        &#10;        val outputFile = File(context.getExternalFilesDir(null), downloadRequest.fileName)&#10;        &#10;        val listener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;                Log.d(&quot;PersistentDownload&quot;, &quot;Progress: $percentage% - ${formatBytes(downloaded)}/${formatBytes(total)}&quot;)&#10;                // Progress is automatically saved to database by CompositeDownloadListener&#10;            }&#10;            &#10;            override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    Log.d(&quot;PersistentDownload&quot;, &quot;✅ Download completed and saved to database: $filePath&quot;)&#10;                } else {&#10;                    Log.d(&quot;PersistentDownload&quot;, &quot;❌ Download failed - state saved to database&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(downloadId: Long, error: String) {&#10;                Log.e(&quot;PersistentDownload&quot;, &quot;⚠️ Error (saved to DB): $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;                Log.d(&quot;PersistentDownload&quot;, &quot; State changed to: ${getStateString(state)} (saved to DB)&quot;)&#10;            }&#10;            &#10;            override fun onDownloadPaused(downloadId: Long) {&#10;                Log.d(&quot;PersistentDownload&quot;, &quot;⏸️ Download paused - state persisted for resume&quot;)&#10;            }&#10;            &#10;            override fun onDownloadResumed(downloadId: Long) {&#10;                Log.d(&quot;PersistentDownload&quot;, &quot;▶️ Download resumed from database state&quot;)&#10;            }&#10;            &#10;            override fun onDownloadCancelled(downloadId: Long) {&#10;                Log.d(&quot;PersistentDownload&quot;, &quot;❌ Download cancelled - marked in database&quot;)&#10;            }&#10;            &#10;            override fun onNetworkReconnected(downloadId: Long) {&#10;                Log.d(&quot;PersistentDownload&quot;, &quot; Network restored - download will auto-resume&quot;)&#10;            }&#10;        }&#10;        &#10;        // Start download - it will be automatically saved to database&#10;        val downloadId = downloadManager.startDownload(context, downloadRequest, outputFile, listener)&#10;        &#10;        Log.d(&quot;DatabaseResume&quot;, &quot; Started persistent download: ${downloadRequest.fileName} (ID: $downloadId)&quot;)&#10;        Log.d(&quot;DatabaseResume&quot;, &quot; Download progress will be saved to Room database&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Demonstrate manual resume of incomplete downloads&#10;     */&#10;    fun resumeIncompleteDownloadsManually() {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Get all downloads from database&#10;                val allDownloads = downloadManager.getAllDownloadsFromDatabase()&#10;                &#10;                Log.d(&quot;DatabaseResume&quot;, &quot; Found ${allDownloads.size} downloads in database:&quot;)&#10;                &#10;                allDownloads.forEach { download -&gt;&#10;                    val stateString = getStateString(download.state)&#10;                    val progress = if (download.totalBytes &gt; 0) {&#10;                        &quot;${(download.downloadedBytes * 100 / download.totalBytes)}%&quot;&#10;                    } else &quot;0%&quot;&#10;                    &#10;                    Log.d(&quot;DatabaseResume&quot;, &quot;   ${download.fileName}: $stateString ($progress)&quot;)&#10;                    &#10;                    // Resume paused downloads&#10;                    if (download.state == Constants.STATE_PAUSED &amp;&amp; downloadManager.isDownloadActive(download.downloadId)) {&#10;                        Log.d(&quot;DatabaseResume&quot;, &quot; Resuming paused download: ${download.fileName}&quot;)&#10;                        downloadManager.resumeDownload(download.downloadId)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;DatabaseResume&quot;, &quot;Error loading downloads from database&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Demonstrate observing downloads from database in real-time&#10;     */&#10;    fun observeDownloadsFromDatabase() {&#10;        // Observe all downloads from database for UI updates&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            downloadManager.getAllDownloadsFlow().collect { downloads -&gt;&#10;                Log.d(&quot;DatabaseObserver&quot;, &quot; Database updated - ${downloads.size} total downloads:&quot;)&#10;                &#10;                downloads.forEach { download -&gt;&#10;                    val stateString = getStateString(download.state)&#10;                    val progressPercent = if (download.totalBytes &gt; 0) {&#10;                        (download.downloadedBytes * 100 / download.totalBytes).toInt()&#10;                    } else 0&#10;                    &#10;                    Log.d(&quot;DatabaseObserver&quot;, &quot;   ${download.fileName}: $stateString ($progressPercent%)&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Simulate app restart scenario&#10;     */&#10;    fun simulateAppRestart() {&#10;        Log.d(&quot;AppRestart&quot;, &quot; Simulating app restart...&quot;)&#10;        &#10;        // This would normally happen when the app starts&#10;        downloadManager.initialize(context, autoResumeIncompleteDownloads = true)&#10;        &#10;        // After initialization, incomplete downloads are automatically loaded&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            delay(2000) // Wait for initialization&#10;            &#10;            val activeIds = downloadManager.getActiveDownloadIds()&#10;            Log.d(&quot;AppRestart&quot;, &quot; After restart - ${activeIds.size} downloads loaded from database&quot;)&#10;            &#10;            activeIds.forEach { downloadId -&gt;&#10;                val info = downloadManager.getDownloadInfo(downloadId)&#10;                if (info != null) {&#10;                    Log.d(&quot;AppRestart&quot;, &quot;   Loaded: ${info.fileName} (${info.progress.toInt()}% complete)&quot;)&#10;                    Log.d(&quot;AppRestart&quot;, &quot;     State: ${getStateString(info.state)}&quot;)&#10;                    Log.d(&quot;AppRestart&quot;, &quot;     Progress: ${formatBytes(info.downloadedBytes)}/${formatBytes(info.totalBytes)}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Demonstrate cleanup operations&#10;     */&#10;    fun demonstrateCleanupOperations() {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            // Clean up old completed downloads (older than 7 days)&#10;            downloadManager.cleanupOldDownloads(daysOld = 7)&#10;            Log.d(&quot;Cleanup&quot;, &quot; Cleaned up old completed downloads from database&quot;)&#10;            &#10;            // Get download statistics from database&#10;            val stats = downloadManager.getDownloadStatistics()&#10;            Log.d(&quot;Cleanup&quot;, &quot;&quot;&quot;&#10;                 Download Statistics:&#10;                - Active: ${stats.totalActive}&#10;                - Downloading: ${stats.downloading} &#10;                - Paused: ${stats.paused}&#10;                - Waiting for Network: ${stats.waitingForNetwork}&#10;                - Completed: ${stats.completed}&#10;                - Failed: ${stats.failed}&#10;            &quot;&quot;&quot;.trimIndent())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Demonstrate deleting downloads with file cleanup&#10;     */&#10;    fun deleteDownloadExample(downloadId: Long) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            // Delete download from database and remove file&#10;            downloadManager.deleteDownload(downloadId, deleteFile = true)&#10;            Log.d(&quot;DeleteDownload&quot;, &quot;️ Deleted download $downloadId from database and removed file&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Create a download that will be paused and later resumed via database&#10;     */&#10;    fun createResumableDownload() {&#10;        val downloadRequest = DownloadRequestFileModel(&#10;            downloadId = System.currentTimeMillis(),&#10;            fileName = &quot;large_resumable_file.bin&quot;,&#10;            url = &quot;https://example.com/large_resumable_file.bin&quot;&#10;        )&#10;        &#10;        val outputFile = File(context.getExternalFilesDir(null), downloadRequest.fileName)&#10;        &#10;        val listener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;                // Automatically saved to database&#10;                if (percentage &gt; 0 &amp;&amp; percentage % 25 == 0) {&#10;                    Log.d(&quot;ResumableDownload&quot;, &quot; Progress milestone: $percentage% - saved to database&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;                Log.d(&quot;ResumableDownload&quot;, &quot;✅ Download completed - final state saved to database&quot;)&#10;            }&#10;            &#10;            override fun onDownloadError(downloadId: Long, error: String) {&#10;                Log.e(&quot;ResumableDownload&quot;, &quot;❌ Error saved to database: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;                Log.d(&quot;ResumableDownload&quot;, &quot;State changed: ${getStateString(state)} - persisted to DB&quot;)&#10;            }&#10;            &#10;            override fun onDownloadPaused(downloadId: Long) {&#10;                Log.d(&quot;ResumableDownload&quot;, &quot;⏸️ Paused - ready for resume after app restart&quot;)&#10;            }&#10;            &#10;            override fun onDownloadResumed(downloadId: Long) {&#10;                Log.d(&quot;ResumableDownload&quot;, &quot;▶️ Resumed from database state&quot;)&#10;            }&#10;            &#10;            override fun onDownloadCancelled(downloadId: Long) {&#10;                Log.d(&quot;ResumableDownload&quot;, &quot;❌ Cancelled&quot;)&#10;            }&#10;            &#10;            override fun onNetworkReconnected(downloadId: Long) {&#10;                Log.d(&quot;ResumableDownload&quot;, &quot; Network restored - auto-resuming&quot;)&#10;            }&#10;        }&#10;        &#10;        // Start download&#10;        val downloadId = downloadManager.startDownload(context, downloadRequest, outputFile, listener)&#10;        &#10;        // Simulate user pausing the download after 3 seconds&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            delay(3000)&#10;            downloadManager.pauseDownload(downloadId)&#10;            Log.d(&quot;ResumableDownload&quot;, &quot;⏸️ Download paused - state saved to database&quot;)&#10;            Log.d(&quot;ResumableDownload&quot;, &quot; This download can now be resumed even after app restart&quot;)&#10;        }&#10;    }&#10;    &#10;    // Utility functions&#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024 * 1024)} GB&quot;&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;            bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;    &#10;    private fun getStateString(state: Int): String {&#10;        return when (state) {&#10;            Constants.STATE_IDLE -&gt; &quot;Idle&quot;&#10;            Constants.STATE_DOWNLOADING -&gt; &quot;Downloading&quot;&#10;            Constants.STATE_PAUSED -&gt; &quot;Paused&quot;&#10;            Constants.STATE_COMPLETED -&gt; &quot;Completed&quot;&#10;            Constants.STATE_FAILED -&gt; &quot;Failed&quot;&#10;            Constants.STATE_CANCELLED -&gt; &quot;Cancelled&quot;&#10;            Constants.STATE_WAITING_FOR_NETWORK -&gt; &quot;Waiting for Network&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Example Application class showing proper initialization&#10; */&#10;/*&#10;class MyApplication : Application() {&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        &#10;        // Initialize download manager with database persistence&#10;        val downloadManager = DownloadManager.getInstance()&#10;        downloadManager.initialize(&#10;            context = this,&#10;            autoResumeIncompleteDownloads = true&#10;        )&#10;    }&#10;}&#10;*/&#10;&#10;/**&#10; * Example Activity showing usage&#10; */&#10;/*&#10;class MainActivity : AppCompatActivity() {&#10;    private lateinit var databaseExample: DatabaseResumeExample&#10;    &#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        databaseExample = DatabaseResumeExample(this)&#10;        &#10;        // Initialize (if not done in Application class)&#10;        databaseExample.initializeDownloadManager()&#10;        &#10;        // Start observing downloads from database&#10;        databaseExample.observeDownloadsFromDatabase()&#10;        &#10;        // Start a persistent download&#10;        databaseExample.startPersistentDownload()&#10;        &#10;        // Create a resumable download&#10;        databaseExample.createResumableDownload()&#10;    }&#10;    &#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Resume any paused downloads&#10;        databaseExample.resumeIncompleteDownloadsManually()&#10;    }&#10;}&#10;*/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadController.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadController.kt" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;/**&#10; * Interface for download operations and state management&#10; */&#10;interface DownloadController {&#10;    fun pauseDownload()&#10;    fun resumeDownload()&#10;    fun cancelDownload()&#10;    fun getDownloadState(): Int&#10;    fun getCurrentProgress(): Long&#10;    fun getTotalSize(): Long&#10;}&#10;&#10;/**&#10; * Listener interface for download events&#10; */&#10;interface DownloadListener {&#10;    fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int)&#10;    fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?)&#10;    fun onDownloadError(downloadId: Long, error: String)&#10;    fun onDownloadStateChanged(downloadId: Long, state: Int)&#10;    fun onDownloadPaused(downloadId: Long)&#10;    fun onDownloadResumed(downloadId: Long)&#10;    fun onDownloadCancelled(downloadId: Long)&#10;    fun onNetworkReconnected(downloadId: Long)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadExample.kt" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.example&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants&#10;import com.marusys.downloadsdk.DownloadListener&#10;import com.marusys.downloadsdk.DownloadManager&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.*&#10;import java.io.File&#10;&#10;/**&#10; * Complete usage example demonstrating pause, resume, cancel, and network reconnection&#10; */&#10;class DownloadExample(private val context: Context) {&#10;    &#10;    private val downloadManager = DownloadManager.getInstance()&#10;    &#10;    /**&#10;     * Example: Basic download with all control features&#10;     */&#10;    fun startBasicDownload() {&#10;        val downloadRequest = DownloadRequestFileModel(&#10;            downloadId = System.currentTimeMillis(),&#10;            fileName = &quot;firmware_v1.4.0.bin&quot;,&#10;            url = &quot;https://example.com/firmware/firmware_v1.4.0.bin&quot;,&#10;            downloadedBytes = 0L&#10;        )&#10;        &#10;        val outputFile = File(context.getExternalFilesDir(null), downloadRequest.fileName)&#10;        &#10;        val listener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;                Log.d(&quot;Download&quot;, &quot;Progress: $percentage% (${formatBytes(downloaded)}/${formatBytes(total)})&quot;)&#10;            }&#10;            &#10;            override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    Log.d(&quot;Download&quot;, &quot;✅ Download completed: $filePath&quot;)&#10;                } else {&#10;                    Log.d(&quot;Download&quot;, &quot;❌ Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(downloadId: Long, error: String) {&#10;                Log.e(&quot;Download&quot;, &quot;⚠️ Error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;                val stateString = getStateString(state)&#10;                Log.d(&quot;Download&quot;, &quot; State changed to: $stateString&quot;)&#10;            }&#10;            &#10;            override fun onDownloadPaused(downloadId: Long) {&#10;                Log.d(&quot;Download&quot;, &quot;⏸️ Download paused&quot;)&#10;            }&#10;            &#10;            override fun onDownloadResumed(downloadId: Long) {&#10;                Log.d(&quot;Download&quot;, &quot;▶️ Download resumed&quot;)&#10;            }&#10;            &#10;            override fun onDownloadCancelled(downloadId: Long) {&#10;                Log.d(&quot;Download&quot;, &quot;❌ Download cancelled&quot;)&#10;            }&#10;            &#10;            override fun onNetworkReconnected(downloadId: Long) {&#10;                Log.d(&quot;Download&quot;, &quot; Network reconnected - resuming download&quot;)&#10;            }&#10;        }&#10;        &#10;        // Start download&#10;        val downloadId = downloadManager.startDownload(context, downloadRequest, outputFile, listener)&#10;        &#10;        // Demonstrate pause/resume/cancel after delays&#10;        demonstrateControlOperations(downloadId)&#10;    }&#10;    &#10;    /**&#10;     * Demonstrate pause, resume, and cancel operations&#10;     */&#10;    private fun demonstrateControlOperations(downloadId: Long) {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            // Pause after 5 seconds&#10;            delay(5000)&#10;            if (downloadManager.pauseDownload(downloadId)) {&#10;                Log.d(&quot;Example&quot;, &quot;⏸️ Download paused successfully&quot;)&#10;                &#10;                // Show current progress while paused&#10;                val progress = downloadManager.getDownloadProgress(downloadId)&#10;                val total = downloadManager.getDownloadTotalSize(downloadId)&#10;                Log.d(&quot;Example&quot;, &quot; Paused at: ${formatBytes(progress)}/${formatBytes(total)}&quot;)&#10;            }&#10;            &#10;            // Resume after 3 seconds&#10;            delay(3000)&#10;            if (downloadManager.resumeDownload(downloadId)) {&#10;                Log.d(&quot;Example&quot;, &quot;▶️ Download resumed successfully&quot;)&#10;            }&#10;            &#10;            // Cancel after 10 more seconds (optional)&#10;            delay(10000)&#10;            if (downloadManager.cancelDownload(downloadId)) {&#10;                Log.d(&quot;Example&quot;, &quot;❌ Download cancelled successfully&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Example: Multiple downloads with different control operations&#10;     */&#10;    fun startMultipleDownloads() {&#10;        val downloads = listOf(&#10;            &quot;firmware_v1.4.0.bin&quot; to &quot;https://example.com/firmware_v1.4.0.bin&quot;,&#10;            &quot;firmware_v1.4.1.bin&quot; to &quot;https://example.com/firmware_v1.4.1.bin&quot;,&#10;            &quot;firmware_v1.4.2.bin&quot; to &quot;https://example.com/firmware_v1.4.2.bin&quot;&#10;        )&#10;        &#10;        val downloadIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        downloads.forEach { (fileName, url) -&gt;&#10;            val request = DownloadRequestFileModel(&#10;                downloadId = System.currentTimeMillis() + downloadIds.size,&#10;                fileName = fileName,&#10;                url = url&#10;            )&#10;            &#10;            val outputFile = File(context.getExternalFilesDir(null), fileName)&#10;            val listener = createMultiDownloadListener(fileName)&#10;            &#10;            val downloadId = downloadManager.startDownload(context, request, outputFile, listener)&#10;            downloadIds.add(downloadId)&#10;            &#10;            Log.d(&quot;Example&quot;, &quot; Started download: $fileName (ID: $downloadId)&quot;)&#10;        }&#10;        &#10;        // Monitor and control multiple downloads&#10;        monitorMultipleDownloads(downloadIds)&#10;    }&#10;    &#10;    private fun createMultiDownloadListener(fileName: String): DownloadListener {&#10;        return object : DownloadListener {&#10;            override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;                // Throttle updates for multiple downloads&#10;                if (percentage % 5 == 0) {&#10;                    Log.d(&quot;MultiDownload&quot;, &quot;[$fileName] $percentage%&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;                Log.d(&quot;MultiDownload&quot;, &quot;[$fileName] ✅ Completed: $success&quot;)&#10;            }&#10;            &#10;            override fun onDownloadError(downloadId: Long, error: String) {&#10;                Log.e(&quot;MultiDownload&quot;, &quot;[$fileName] ❌ Error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;                Log.d(&quot;MultiDownload&quot;, &quot;[$fileName] State: ${getStateString(state)}&quot;)&#10;            }&#10;            &#10;            override fun onDownloadPaused(downloadId: Long) {&#10;                Log.d(&quot;MultiDownload&quot;, &quot;[$fileName] ⏸️ Paused&quot;)&#10;            }&#10;            &#10;            override fun onDownloadResumed(downloadId: Long) {&#10;                Log.d(&quot;MultiDownload&quot;, &quot;[$fileName] ▶️ Resumed&quot;)&#10;            }&#10;            &#10;            override fun onDownloadCancelled(downloadId: Long) {&#10;                Log.d(&quot;MultiDownload&quot;, &quot;[$fileName] ❌ Cancelled&quot;)&#10;            }&#10;            &#10;            override fun onNetworkReconnected(downloadId: Long) {&#10;                Log.d(&quot;MultiDownload&quot;, &quot;[$fileName]  Network restored&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun monitorMultipleDownloads(downloadIds: List&lt;Long&gt;) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            while (downloadIds.any { downloadManager.isDownloadActive(it) }) {&#10;                // Print statistics every 5 seconds&#10;                delay(5000)&#10;                &#10;                val stats = downloadManager.getDownloadStatistics()&#10;                Log.d(&quot;Monitor&quot;, &quot;&quot;&quot;&#10;                     Download Statistics:&#10;                    - Total Active: ${stats.totalActive}&#10;                    - Downloading: ${stats.downloading}&#10;                    - Paused: ${stats.paused}&#10;                    - Waiting for Network: ${stats.waitingForNetwork}&#10;                    - Completed: ${stats.completed}&#10;                    - Failed: ${stats.failed}&#10;                &quot;&quot;&quot;.trimIndent())&#10;                &#10;                // Show individual progress&#10;                downloadIds.forEach { downloadId -&gt;&#10;                    val info = downloadManager.getDownloadInfo(downloadId)&#10;                    if (info != null) {&#10;                        Log.d(&quot;Monitor&quot;, &quot; ${info.fileName}: ${info.progress.toInt()}% (${getStateString(info.state)})&quot;)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Log.d(&quot;Monitor&quot;, &quot; All downloads completed!&quot;)&#10;            downloadManager.cleanupCompletedDownloads()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Example: Resume interrupted download (simulate app restart)&#10;     */&#10;    fun resumeInterruptedDownload() {&#10;        // Simulate a download that was interrupted at 50% (2MB downloaded out of 4MB)&#10;        val partialDownloadRequest = DownloadRequestFileModel(&#10;            downloadId = 12345L,&#10;            fileName = &quot;large_firmware.bin&quot;,&#10;            url = &quot;https://example.com/large_firmware.bin&quot;,&#10;            downloadedBytes = 2 * 1024 * 1024L, // 2MB already downloaded&#10;            totalBytes = 4 * 1024 * 1024L        // 4MB total&#10;        )&#10;        &#10;        val outputFile = File(context.getExternalFilesDir(null), partialDownloadRequest.fileName)&#10;        &#10;        val listener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;                Log.d(&quot;Resume&quot;, &quot;Resuming from 50%: Current $percentage% (${formatBytes(downloaded)}/${formatBytes(total)})&quot;)&#10;            }&#10;            &#10;            override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;                Log.d(&quot;Resume&quot;, &quot;✅ Interrupted download completed successfully!&quot;)&#10;            }&#10;            &#10;            override fun onDownloadError(downloadId: Long, error: String) {&#10;                Log.e(&quot;Resume&quot;, &quot;❌ Resume failed: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;                Log.d(&quot;Resume&quot;, &quot;Resume state: ${getStateString(state)}&quot;)&#10;            }&#10;            &#10;            override fun onDownloadPaused(downloadId: Long) {}&#10;            override fun onDownloadResumed(downloadId: Long) {}&#10;            override fun onDownloadCancelled(downloadId: Long) {}&#10;            &#10;            override fun onNetworkReconnected(downloadId: Long) {&#10;                Log.d(&quot;Resume&quot;, &quot; Network restored during resume&quot;)&#10;            }&#10;        }&#10;        &#10;        // This will automatically resume from 2MB using HTTP Range header&#10;        downloadManager.startDownload(context, partialDownloadRequest, outputFile, listener)&#10;        Log.d(&quot;Resume&quot;, &quot; Resuming download from ${formatBytes(partialDownloadRequest.downloadedBytes)}&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Example: Batch operations on multiple downloads&#10;     */&#10;    fun demonstrateBatchOperations() {&#10;        Log.d(&quot;Batch&quot;, &quot; Pausing all active downloads...&quot;)&#10;        downloadManager.pauseAllDownloads()&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            delay(3000)&#10;            &#10;            Log.d(&quot;Batch&quot;, &quot;▶️ Resuming all paused downloads...&quot;)&#10;            downloadManager.resumeAllDownloads()&#10;            &#10;            delay(10000)&#10;            &#10;            Log.d(&quot;Batch&quot;, &quot;❌ Cancelling all downloads...&quot;)&#10;            downloadManager.cancelAllDownloads()&#10;        }&#10;    }&#10;    &#10;    // Utility functions&#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024 * 1024)} GB&quot;&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;            bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;    &#10;    private fun getStateString(state: Int): String {&#10;        return when (state) {&#10;            Constants.STATE_IDLE -&gt; &quot;Idle&quot;&#10;            Constants.STATE_DOWNLOADING -&gt; &quot;Downloading&quot;&#10;            Constants.STATE_PAUSED -&gt; &quot;Paused&quot;&#10;            Constants.STATE_COMPLETED -&gt; &quot;Completed&quot;&#10;            Constants.STATE_FAILED -&gt; &quot;Failed&quot;&#10;            Constants.STATE_CANCELLED -&gt; &quot;Cancelled&quot;&#10;            Constants.STATE_WAITING_FOR_NETWORK -&gt; &quot;Waiting for Network&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import java.io.File&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;/**&#10; * Main Download Manager that handles multiple concurrent downloads&#10; * with pause, resume, cancel, and network reconnection support&#10; */&#10;class DownloadManager private constructor() {&#10;    &#10;    private val TAG = &quot;DownloadManager&quot;&#10;    private val activeDownloads = ConcurrentHashMap&lt;Long, DownloadTaskManager&gt;()&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadManager? = null&#10;        &#10;        fun getInstance(): DownloadManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DownloadManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Start a new download&#10;     */&#10;    fun startDownload(&#10;        context: Context,&#10;        downloadRequest: DownloadRequestFileModel,&#10;        outputFile: File,&#10;        listener: DownloadListener? = null&#10;    ): Long {&#10;        val downloadId = downloadRequest.downloadId&#10;        &#10;        // Check if download is already active&#10;        if (isDownloadActive(downloadId)) {&#10;            Log.w(TAG, &quot;Download with ID $downloadId is already active&quot;)&#10;            return downloadId&#10;        }&#10;        &#10;        // Create and start download task&#10;        val downloadTask = DownloadTaskManager(context, downloadRequest, outputFile, listener)&#10;        activeDownloads[downloadId] = downloadTask&#10;        downloadTask.startDownload()&#10;        &#10;        Log.d(TAG, &quot;Started download: ${downloadRequest.fileName} (ID: $downloadId)&quot;)&#10;        return downloadId&#10;    }&#10;    &#10;    /**&#10;     * Pause a download&#10;     */&#10;    fun pauseDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.pauseDownload()&#10;            Log.d(TAG, &quot;Paused download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Resume a paused download&#10;     */&#10;    fun resumeDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.resumeDownload()&#10;            Log.d(TAG, &quot;Resumed download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel a download&#10;     */&#10;    fun cancelDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.cancelDownload()&#10;            activeDownloads.remove(downloadId)&#10;            Log.d(TAG, &quot;Cancelled download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel all active downloads&#10;     */&#10;    fun cancelAllDownloads() {&#10;        val downloadIds = activeDownloads.keys.toList()&#10;        downloadIds.forEach { downloadId -&gt;&#10;            cancelDownload(downloadId)&#10;        }&#10;        Log.d(TAG, &quot;Cancelled all downloads (${downloadIds.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Get download state&#10;     */&#10;    fun getDownloadState(downloadId: Long): Int? {&#10;        return activeDownloads[downloadId]?.getDownloadState()&#10;    }&#10;    &#10;    /**&#10;     * Get current progress in bytes&#10;     */&#10;    fun getDownloadProgress(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getCurrentProgress() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get total file size in bytes&#10;     */&#10;    fun getDownloadTotalSize(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getTotalSize() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get complete download information&#10;     */&#10;    fun getDownloadInfo(downloadId: Long): DownloadRequestFileModel? {&#10;        return activeDownloads[downloadId]?.getDownloadInfo()&#10;    }&#10;    &#10;    /**&#10;     * Check if download is active&#10;     */&#10;    fun isDownloadActive(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.isActive() == true&#10;    }&#10;    &#10;    /**&#10;     * Get all active download IDs&#10;     */&#10;    fun getActiveDownloadIds(): Set&lt;Long&gt; {&#10;        return activeDownloads.keys.toSet()&#10;    }&#10;    &#10;    /**&#10;     * Get number of active downloads&#10;     */&#10;    fun getActiveDownloadCount(): Int = activeDownloads.size&#10;    &#10;    /**&#10;     * Pause all active downloads&#10;     */&#10;    fun pauseAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            task.pauseDownload()&#10;        }&#10;        Log.d(TAG, &quot;Paused all downloads (${activeDownloads.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Resume all paused downloads&#10;     */&#10;    fun resumeAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            if (task.getDownloadState() == Constants.STATE_PAUSED) {&#10;                task.resumeDownload()&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Resumed all paused downloads&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Clean up completed or failed downloads from active list&#10;     */&#10;    fun cleanupCompletedDownloads() {&#10;        val completedIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        activeDownloads.forEach { (id, task) -&gt;&#10;            val state = task.getDownloadState()&#10;            if (state in listOf(Constants.STATE_COMPLETED, Constants.STATE_FAILED, Constants.STATE_CANCELLED)) {&#10;                task.cleanup()&#10;                completedIds.add(id)&#10;            }&#10;        }&#10;        &#10;        completedIds.forEach { id -&gt;&#10;            activeDownloads.remove(id)&#10;        }&#10;        &#10;        if (completedIds.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Cleaned up ${completedIds.size} completed downloads&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get download statistics&#10;     */&#10;    fun getDownloadStatistics(): DownloadStatistics {&#10;        var totalDownloading = 0&#10;        var totalPaused = 0&#10;        var totalWaitingForNetwork = 0&#10;        var totalCompleted = 0&#10;        var totalFailed = 0&#10;        &#10;        activeDownloads.values.forEach { task -&gt;&#10;            when (task.getDownloadState()) {&#10;                Constants.STATE_DOWNLOADING -&gt; totalDownloading++&#10;                Constants.STATE_PAUSED -&gt; totalPaused++&#10;                Constants.STATE_WAITING_FOR_NETWORK -&gt; totalWaitingForNetwork++&#10;                Constants.STATE_COMPLETED -&gt; totalCompleted++&#10;                Constants.STATE_FAILED -&gt; totalFailed++&#10;            }&#10;        }&#10;        &#10;        return DownloadStatistics(&#10;            totalActive = activeDownloads.size,&#10;            downloading = totalDownloading,&#10;            paused = totalPaused,&#10;            waitingForNetwork = totalWaitingForNetwork,&#10;            completed = totalCompleted,&#10;            failed = totalFailed&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Data class for download statistics&#10; */&#10;data class DownloadStatistics(&#10;    val totalActive: Int,&#10;    val downloading: Int,&#10;    val paused: Int,&#10;    val waitingForNetwork: Int,&#10;    val completed: Int,&#10;    val failed: Int&#10;)&#10;" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.db.DownloadPersistenceManager&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;/**&#10; * Enhanced Download Manager with Room database persistence&#10; * Automatically resumes downloads when app is reopened&#10; */&#10;class DownloadManager private constructor() {&#10;    &#10;    private val TAG = &quot;DownloadManager&quot;&#10;    private val activeDownloads = ConcurrentHashMap&lt;Long, DownloadTaskManager&gt;()&#10;    private val persistenceManager = DownloadPersistenceManager.getInstance()&#10;    private val resumeScope = CoroutineScope(Dispatchers.IO)&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadManager? = null&#10;        &#10;        fun getInstance(): DownloadManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DownloadManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Initialize the download manager and resume incomplete downloads&#10;     */&#10;    fun initialize(context: Context, autoResumeIncompleteDownloads: Boolean = true) {&#10;        persistenceManager.initialize(context)&#10;        &#10;        if (autoResumeIncompleteDownloads) {&#10;            resumeIncompleteDownloads(context)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;DownloadManager initialized&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Resume all incomplete downloads from database when app opens&#10;     */&#10;    fun resumeIncompleteDownloads(context: Context) {&#10;        resumeScope.launch {&#10;            try {&#10;                val incompleteDownloads = persistenceManager.getIncompleteDownloads()&#10;                Log.d(TAG, &quot;Resuming ${incompleteDownloads.size} incomplete downloads&quot;)&#10;                &#10;                incompleteDownloads.forEach { request -&gt;&#10;                    // Validate that the file still exists and has correct size&#10;                    if (persistenceManager.validateDownloadFile(request.downloadId)) {&#10;                        val outputFile = File(context.getExternalFilesDir(null), request.fileName)&#10;                        resumeDownloadFromDatabase(context, request, outputFile)&#10;                    } else {&#10;                        Log.w(TAG, &quot;Cannot resume download ${request.fileName} - file validation failed&quot;)&#10;                        // Reset download progress in database&#10;                        persistenceManager.updateProgress(request.downloadId, 0L, request.totalBytes)&#10;                        persistenceManager.updateState(request.downloadId, Constants.STATE_IDLE)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error resuming incomplete downloads&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun resumeDownloadFromDatabase(&#10;        context: Context,&#10;        request: DownloadRequestFileModel,&#10;        outputFile: File&#10;    ) {&#10;        Log.d(TAG, &quot;Resuming download: ${request.fileName} from ${formatBytes(request.downloadedBytes)}&quot;)&#10;        &#10;        val listener = DatabaseIntegratedListener(request.downloadId)&#10;        val downloadTask = DownloadTaskManager(context, request, outputFile, listener)&#10;        activeDownloads[request.downloadId] = downloadTask&#10;        &#10;        // Set initial state to paused so user can choose to resume&#10;        persistenceManager.updateState(request.downloadId, Constants.STATE_PAUSED)&#10;        &#10;        Log.d(TAG, &quot;Download ${request.fileName} ready to resume (currently paused)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Start a new download with database persistence&#10;     */&#10;    fun startDownload(&#10;        context: Context,&#10;        downloadRequest: DownloadRequestFileModel,&#10;        outputFile: File,&#10;        listener: DownloadListener? = null&#10;    ): Long {&#10;        val downloadId = downloadRequest.downloadId&#10;        &#10;        // Check if download is already active&#10;        if (isDownloadActive(downloadId)) {&#10;            Log.w(TAG, &quot;Download with ID $downloadId is already active&quot;)&#10;            return downloadId&#10;        }&#10;        &#10;        // Save to database&#10;        resumeScope.launch {&#10;            persistenceManager.saveDownloadRequest(downloadRequest, outputFile.absolutePath)&#10;        }&#10;        &#10;        // Create composite listener that includes database updates&#10;        val compositeListener = CompositeDownloadListener(downloadId, listener)&#10;        &#10;        // Create and start download task&#10;        val downloadTask = DownloadTaskManager(context, downloadRequest, outputFile, compositeListener)&#10;        activeDownloads[downloadId] = downloadTask&#10;        downloadTask.startDownload()&#10;        &#10;        Log.d(TAG, &quot;Started download: ${downloadRequest.fileName} (ID: $downloadId)&quot;)&#10;        return downloadId&#10;    }&#10;    &#10;    /**&#10;     * Pause a download&#10;     */&#10;    fun pauseDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.pauseDownload()&#10;            persistenceManager.updateState(downloadId, Constants.STATE_PAUSED)&#10;            Log.d(TAG, &quot;Paused download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Resume a paused download&#10;     */&#10;    fun resumeDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.resumeDownload()&#10;            persistenceManager.updateState(downloadId, Constants.STATE_DOWNLOADING)&#10;            Log.d(TAG, &quot;Resumed download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel a download&#10;     */&#10;    fun cancelDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.cancelDownload()&#10;            persistenceManager.updateState(downloadId, Constants.STATE_CANCELLED)&#10;            activeDownloads.remove(downloadId)&#10;            Log.d(TAG, &quot;Cancelled download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel all active downloads&#10;     */&#10;    fun cancelAllDownloads() {&#10;        val downloadIds = activeDownloads.keys.toList()&#10;        downloadIds.forEach { downloadId -&gt;&#10;            cancelDownload(downloadId)&#10;        }&#10;        Log.d(TAG, &quot;Cancelled all downloads (${downloadIds.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Get download state&#10;     */&#10;    fun getDownloadState(downloadId: Long): Int? {&#10;        return activeDownloads[downloadId]?.getDownloadState()&#10;    }&#10;    &#10;    /**&#10;     * Get current progress in bytes&#10;     */&#10;    fun getDownloadProgress(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getCurrentProgress() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get total file size in bytes&#10;     */&#10;    fun getDownloadTotalSize(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getTotalSize() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get complete download information&#10;     */&#10;    fun getDownloadInfo(downloadId: Long): DownloadRequestFileModel? {&#10;        return activeDownloads[downloadId]?.getDownloadInfo()&#10;    }&#10;    &#10;    /**&#10;     * Check if download is active&#10;     */&#10;    fun isDownloadActive(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.isActive() == true&#10;    }&#10;    &#10;    /**&#10;     * Get all active download IDs&#10;     */&#10;    fun getActiveDownloadIds(): Set&lt;Long&gt; {&#10;        return activeDownloads.keys.toSet()&#10;    }&#10;    &#10;    /**&#10;     * Get number of active downloads&#10;     */&#10;    fun getActiveDownloadCount(): Int = activeDownloads.size&#10;    &#10;    /**&#10;     * Pause all active downloads&#10;     */&#10;    fun pauseAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            task.pauseDownload()&#10;        }&#10;        Log.d(TAG, &quot;Paused all downloads (${activeDownloads.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Resume all paused downloads&#10;     */&#10;    fun resumeAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            if (task.getDownloadState() == Constants.STATE_PAUSED) {&#10;                task.resumeDownload()&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Resumed all paused downloads&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Clean up completed or failed downloads from active list&#10;     */&#10;    fun cleanupCompletedDownloads() {&#10;        val completedIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        activeDownloads.forEach { (id, task) -&gt;&#10;            val state = task.getDownloadState()&#10;            if (state in listOf(Constants.STATE_COMPLETED, Constants.STATE_FAILED, Constants.STATE_CANCELLED)) {&#10;                task.cleanup()&#10;                completedIds.add(id)&#10;            }&#10;        }&#10;        &#10;        completedIds.forEach { id -&gt;&#10;            activeDownloads.remove(id)&#10;        }&#10;        &#10;        if (completedIds.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Cleaned up ${completedIds.size} completed downloads&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get download statistics&#10;     */&#10;    fun getDownloadStatistics(): DownloadStatistics {&#10;        var totalDownloading = 0&#10;        var totalPaused = 0&#10;        var totalWaitingForNetwork = 0&#10;        var totalCompleted = 0&#10;        var totalFailed = 0&#10;        &#10;        activeDownloads.values.forEach { task -&gt;&#10;            when (task.getDownloadState()) {&#10;                Constants.STATE_DOWNLOADING -&gt; totalDownloading++&#10;                Constants.STATE_PAUSED -&gt; totalPaused++&#10;                Constants.STATE_WAITING_FOR_NETWORK -&gt; totalWaitingForNetwork++&#10;                Constants.STATE_COMPLETED -&gt; totalCompleted++&#10;                Constants.STATE_FAILED -&gt; totalFailed++&#10;            }&#10;        }&#10;        &#10;        return DownloadStatistics(&#10;            totalActive = activeDownloads.size,&#10;            downloading = totalDownloading,&#10;            paused = totalPaused,&#10;            waitingForNetwork = totalWaitingForNetwork,&#10;            completed = totalCompleted,&#10;            failed = totalFailed&#10;        )&#10;    }&#10;    &#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024 * 1024)} GB&quot;&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;            bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Composite listener that handles both user callbacks and database persistence&#10;     */&#10;    private inner class CompositeDownloadListener(&#10;        private val downloadId: Long,&#10;        private val userListener: DownloadListener?&#10;    ) : DownloadListener {&#10;        &#10;        override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;            // Update database&#10;            persistenceManager.updateProgress(downloadId, downloaded, total)&#10;            // Notify user listener&#10;            userListener?.onProgressUpdate(downloadId, downloaded, total, percentage)&#10;        }&#10;        &#10;        override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;            // Update database&#10;            val state = if (success) Constants.STATE_COMPLETED else Constants.STATE_FAILED&#10;            persistenceManager.updateState(downloadId, state)&#10;            // Remove from active downloads&#10;            activeDownloads.remove(downloadId)&#10;            // Notify user listener&#10;            userListener?.onDownloadComplete(downloadId, success, filePath)&#10;        }&#10;        &#10;        override fun onDownloadError(downloadId: Long, error: String) {&#10;            // Update database&#10;            persistenceManager.updateState(downloadId, Constants.STATE_FAILED, error)&#10;            // Notify user listener&#10;            userListener?.onDownloadError(downloadId, error)&#10;        }&#10;        &#10;        override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;            // Update database&#10;            persistenceManager.updateState(downloadId, state)&#10;            // Notify user listener&#10;            userListener?.onDownloadStateChanged(downloadId, state)&#10;        }&#10;        &#10;        override fun onDownloadPaused(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_PAUSED)&#10;            userListener?.onDownloadPaused(downloadId)&#10;        }&#10;        &#10;        override fun onDownloadResumed(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_DOWNLOADING)&#10;            userListener?.onDownloadResumed(downloadId)&#10;        }&#10;        &#10;        override fun onDownloadCancelled(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_CANCELLED)&#10;            userListener?.onDownloadCancelled(downloadId)&#10;        }&#10;        &#10;        override fun onNetworkReconnected(downloadId: Long) {&#10;            userListener?.onNetworkReconnected(downloadId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Database-only listener for resumed downloads&#10;     */&#10;    private inner class DatabaseIntegratedListener(&#10;        private val downloadId: Long&#10;    ) : DownloadListener {&#10;        &#10;        override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;            persistenceManager.updateProgress(downloadId, downloaded, total)&#10;        }&#10;        &#10;        override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;            val state = if (success) Constants.STATE_COMPLETED else Constants.STATE_FAILED&#10;            persistenceManager.updateState(downloadId, state)&#10;            activeDownloads.remove(downloadId)&#10;        }&#10;        &#10;        override fun onDownloadError(downloadId: Long, error: String) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_FAILED, error)&#10;        }&#10;        &#10;        override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;            persistenceManager.updateState(downloadId, state)&#10;        }&#10;        &#10;        override fun onDownloadPaused(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_PAUSED)&#10;        }&#10;        &#10;        override fun onDownloadResumed(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_DOWNLOADING)&#10;        }&#10;        &#10;        override fun onDownloadCancelled(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_CANCELLED)&#10;        }&#10;        &#10;        override fun onNetworkReconnected(downloadId: Long) {&#10;            // Handle network reconnection&#10;        }&#10;    }&#10;}&#10;&#10;data class DownloadStatistics(&#10;    val totalActive: Int,&#10;    val downloading: Int,&#10;    val paused: Int,&#10;    val waitingForNetwork: Int,&#10;    val completed: Int,&#10;    val failed: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadTaskManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadTaskManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.*&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;import java.util.concurrent.atomic.AtomicInteger&#10;import java.util.concurrent.atomic.AtomicLong&#10;&#10;class DownloadTaskManager(&#10;    private val context: Context,&#10;    private var downloadRequestFileModel: DownloadRequestFileModel,&#10;    private val outputFile: File,&#10;    private val listener: DownloadListener? = null&#10;) : DownloadController, NetworkManager.NetworkConnectionState {&#10;&#10;    private val TAG = &quot;DownloadTaskManager&quot;&#10;    &#10;    // Core components&#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private val httpConnectionManager = HttpConnectionManager(downloadRequestFileModel)&#10;    private val networkManager = NetworkManager(context, this)&#10;    &#10;    // State management&#10;    private val currentState = AtomicInteger(Constants.STATE_IDLE)&#10;    private val isPaused = AtomicBoolean(false)&#10;    private val isCancelled = AtomicBoolean(false)&#10;    private val isWaitingForNetwork = AtomicBoolean(false)&#10;    &#10;    // Download progress tracking&#10;    private val downloadedBytes = AtomicLong(downloadRequestFileModel.downloadedBytes)&#10;    private val totalBytes = AtomicLong(downloadRequestFileModel.totalBytes)&#10;    &#10;    // Jobs and retry management&#10;    private var downloadJob: Job? = null&#10;    private var retryCount = 0&#10;&#10;    @RequiresPermission(Manifest.permission.ACCESS_NETWORK_STATE)&#10;    fun startDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            Log.w(TAG, &quot;Download already in progress&quot;)&#10;            return&#10;        }&#10;        &#10;        networkManager.registerNetworkCallback()&#10;        &#10;        if (!networkManager.isConnected()) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            Log.d(TAG, &quot;No network connection, waiting for network...&quot;)&#10;            return&#10;        }&#10;        &#10;        executeDownload()&#10;    }&#10;&#10;    private fun executeDownload() {&#10;        if (isCancelled.get()) return&#10;        &#10;        setState(Constants.STATE_DOWNLOADING)&#10;        isPaused.set(false)&#10;        &#10;        downloadJob = scope.launch {&#10;            try {&#10;                performDownload()&#10;            } catch (e: CancellationException) {&#10;                Log.d(TAG, &quot;Download cancelled&quot;)&#10;                handleDownloadCancellation()&#10;            } catch (e: IOException) {&#10;                Log.e(TAG, &quot;Download IO error&quot;, e)&#10;                handleNetworkError(e)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Download error&quot;, e)&#10;                handleDownloadError(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun performDownload() {&#10;        // Update request model with current progress&#10;        downloadRequestFileModel = downloadRequestFileModel.copy(&#10;            downloadedBytes = downloadedBytes.get()&#10;        )&#10;        &#10;        // Establish connection&#10;        httpConnectionManager.buildConnectionToDownload()&#10;        &#10;        val contentLength = httpConnectionManager.getContentLength()&#10;        if (contentLength &gt; 0 &amp;&amp; totalBytes.get() &lt;= 0) {&#10;            totalBytes.set(contentLength + downloadedBytes.get())&#10;        }&#10;        &#10;        // Start streaming download&#10;        httpConnectionManager.getInputStream()?.use { inputStream -&gt;&#10;            FileOutputStream(outputFile, downloadedBytes.get() &gt; 0).use { outputStream -&gt;&#10;                downloadDataStream(inputStream, outputStream)&#10;            }&#10;        } ?: throw IOException(&quot;Unable to get input stream&quot;)&#10;        &#10;        // Download completed successfully&#10;        setState(Constants.STATE_COMPLETED)&#10;        listener?.onDownloadComplete(&#10;            downloadRequestFileModel.downloadId,&#10;            true,&#10;            outputFile.absolutePath&#10;        )&#10;    }&#10;&#10;    private suspend fun downloadDataStream(&#10;        inputStream: java.io.InputStream,&#10;        outputStream: FileOutputStream&#10;    ) {&#10;        val buffer = ByteArray(Constants.BUFFER_SIZE)&#10;        var bytesRead: Int&#10;        var lastProgressUpdate = 0L&#10;&#10;        while (inputStream.read(buffer).also { bytesRead = it } != -1) {&#10;            // Check for cancellation&#10;            if (isCancelled.get()) {&#10;                throw CancellationException(&quot;Download cancelled&quot;)&#10;            }&#10;&#10;            // Handle pause state&#10;            while (isPaused.get() &amp;&amp; !isCancelled.get()) {&#10;                delay(100)&#10;            }&#10;&#10;            // Write data to file&#10;            outputStream.write(buffer, 0, bytesRead)&#10;            outputStream.flush()&#10;            &#10;            // Update progress&#10;            val currentDownloaded = downloadedBytes.addAndGet(bytesRead.toLong())&#10;            &#10;            // Throttle progress updates (every 100KB or 1%)&#10;            val shouldUpdateProgress = currentDownloaded - lastProgressUpdate &gt;= 100_000 ||&#10;                    (totalBytes.get() &gt; 0 &amp;&amp; (currentDownloaded * 100 / totalBytes.get()) &gt; (lastProgressUpdate * 100 / totalBytes.get()))&#10;            &#10;            if (shouldUpdateProgress) {&#10;                notifyProgress(currentDownloaded)&#10;                lastProgressUpdate = currentDownloaded&#10;            }&#10;            &#10;            // Yield to allow other coroutines to run and check for state changes&#10;            yield()&#10;        }&#10;    }&#10;&#10;    private fun notifyProgress(downloaded: Long) {&#10;        val total = totalBytes.get()&#10;        val percentage = if (total &gt; 0) {&#10;            ((downloaded * 100) / total).toInt()&#10;        } else 0&#10;        &#10;        listener?.onProgressUpdate(&#10;            downloadRequestFileModel.downloadId,&#10;            downloaded,&#10;            total,&#10;            percentage&#10;        )&#10;    }&#10;&#10;    private fun handleNetworkError(exception: IOException) {&#10;        if (networkManager.isConnected()) {&#10;            // Network is available but connection failed - retry&#10;            handleRetry(exception)&#10;        } else {&#10;            // No network - wait for reconnection&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;            Log.d(TAG, &quot;Network lost during download, waiting for reconnection...&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleRetry(exception: Exception) {&#10;        if (retryCount &lt; Constants.MAX_RETRY_ATTEMPTS &amp;&amp; !isCancelled.get()) {&#10;            retryCount++&#10;            Log.d(TAG, &quot;Retrying download... Attempt $retryCount/${Constants.MAX_RETRY_ATTEMPTS}&quot;)&#10;            &#10;            scope.launch {&#10;                delay(Constants.RETRY_DELAY_MS)&#10;                if (!isCancelled.get()) {&#10;                    executeDownload()&#10;                }&#10;            }&#10;        } else {&#10;            setState(Constants.STATE_FAILED)&#10;            listener?.onDownloadError(&#10;                downloadRequestFileModel.downloadId,&#10;                &quot;Download failed after $retryCount attempts: ${exception.message}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun handleDownloadError(exception: Exception) {&#10;        setState(Constants.STATE_FAILED)&#10;        listener?.onDownloadError(&#10;            downloadRequestFileModel.downloadId,&#10;            &quot;Download error: ${exception.message}&quot;&#10;        )&#10;    }&#10;&#10;    private fun handleDownloadCancellation() {&#10;        setState(Constants.STATE_CANCELLED)&#10;        // Delete partial file if download was cancelled&#10;        if (outputFile.exists() &amp;&amp; downloadedBytes.get() &lt; totalBytes.get()) {&#10;            outputFile.delete()&#10;            Log.d(TAG, &quot;Deleted partial download file&quot;)&#10;        }&#10;        listener?.onDownloadCancelled(downloadRequestFileModel.downloadId)&#10;    }&#10;&#10;    // DownloadController implementation&#10;    override fun pauseDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            isPaused.set(true)&#10;            setState(Constants.STATE_PAUSED)&#10;            listener?.onDownloadPaused(downloadRequestFileModel.downloadId)&#10;            Log.d(TAG, &quot;Download paused&quot;)&#10;        }&#10;    }&#10;&#10;    override fun resumeDownload() {&#10;        when (currentState.get()) {&#10;            Constants.STATE_PAUSED -&gt; {&#10;                if (networkManager.isConnected()) {&#10;                    isPaused.set(false)&#10;                    setState(Constants.STATE_DOWNLOADING)&#10;                    listener?.onDownloadResumed(downloadRequestFileModel.downloadId)&#10;                    Log.d(TAG, &quot;Download resumed&quot;)&#10;                } else {&#10;                    setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;                    isWaitingForNetwork.set(true)&#10;                    Log.d(TAG, &quot;Cannot resume - no network connection&quot;)&#10;                }&#10;            }&#10;            Constants.STATE_FAILED -&gt; {&#10;                // Allow resume after failure&#10;                retryCount = 0&#10;                executeDownload()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun cancelDownload() {&#10;        isCancelled.set(true)&#10;        isPaused.set(false)&#10;        downloadJob?.cancel()&#10;        cleanup()&#10;        Log.d(TAG, &quot;Download cancelled&quot;)&#10;    }&#10;&#10;    override fun getDownloadState(): Int = currentState.get()&#10;&#10;    override fun getCurrentProgress(): Long = downloadedBytes.get()&#10;&#10;    override fun getTotalSize(): Long = totalBytes.get()&#10;&#10;    // NetworkManager.NetworkConnectionState implementation&#10;    override fun onConnected() {&#10;        Log.d(TAG, &quot;Network reconnected&quot;)&#10;        &#10;        if (isWaitingForNetwork.get() || currentState.get() == Constants.STATE_WAITING_FOR_NETWORK) {&#10;            isWaitingForNetwork.set(false)&#10;            retryCount = 0 // Reset retry count on network reconnection&#10;            &#10;            listener?.onNetworkReconnected(downloadRequestFileModel.downloadId)&#10;            &#10;            // Resume download automatically when network is restored&#10;            executeDownload()&#10;        }&#10;    }&#10;&#10;    override fun onDisconnected() {&#10;        Log.d(TAG, &quot;Network disconnected&quot;)&#10;        &#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;        }&#10;    }&#10;&#10;    private fun setState(newState: Int) {&#10;        val oldState = currentState.getAndSet(newState)&#10;        if (oldState != newState) {&#10;            listener?.onDownloadStateChanged(downloadRequestFileModel.downloadId, newState)&#10;        }&#10;    }&#10;&#10;    fun cleanup() {&#10;        downloadJob?.cancel()&#10;        httpConnectionManager.disconnect()&#10;        networkManager.cleanup()&#10;        scope.cancel()&#10;    }&#10;&#10;    // Utility methods&#10;    fun getDownloadInfo(): DownloadRequestFileModel {&#10;        return downloadRequestFileModel.copy(&#10;            downloadedBytes = downloadedBytes.get(),&#10;            totalBytes = totalBytes.get(),&#10;            state = currentState.get(),&#10;            progress = if (totalBytes.get() &gt; 0) {&#10;                (downloadedBytes.get().toFloat() / totalBytes.get().toFloat()) * 100&#10;            } else 0f&#10;        )&#10;    }&#10;&#10;    fun isActive(): Boolean {&#10;        return currentState.get() in listOf(&#10;            Constants.STATE_DOWNLOADING,&#10;            Constants.STATE_WAITING_FOR_NETWORK&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.*&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;import java.util.concurrent.atomic.AtomicInteger&#10;import java.util.concurrent.atomic.AtomicLong&#10;&#10;class DownloadTaskManager(&#10;    private val context: Context,&#10;    private var downloadRequestFileModel: DownloadRequestFileModel,&#10;    private val outputFile: File,&#10;    private val listener: DownloadListener? = null&#10;) : DownloadController, NetworkManager.NetworkConnectionState {&#10;&#10;    private val TAG = &quot;DownloadTaskManager&quot;&#10;    &#10;    // Core components&#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private val httpConnectionManager = HttpConnectionManager(downloadRequestFileModel)&#10;    private val networkManager = NetworkManager(context, this)&#10;    &#10;    // State management&#10;    private val currentState = AtomicInteger(Constants.STATE_IDLE)&#10;    private val isPaused = AtomicBoolean(false)&#10;    private val isCancelled = AtomicBoolean(false)&#10;    private val isWaitingForNetwork = AtomicBoolean(false)&#10;    &#10;    // Download progress tracking&#10;    private val downloadedBytes = AtomicLong(downloadRequestFileModel.downloadedBytes)&#10;    private val totalBytes = AtomicLong(downloadRequestFileModel.totalBytes)&#10;    &#10;    // Jobs and retry management&#10;    private var downloadJob: Job? = null&#10;    private var retryCount = 0&#10;&#10;    @RequiresPermission(Manifest.permission.ACCESS_NETWORK_STATE)&#10;    fun startDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            Log.w(TAG, &quot;Download already in progress&quot;)&#10;            return&#10;        }&#10;        &#10;        networkManager.registerNetworkCallback()&#10;        &#10;        if (!networkManager.isConnected()) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            Log.d(TAG, &quot;No network connection, waiting for network...&quot;)&#10;            return&#10;        }&#10;        &#10;        executeDownload()&#10;    }&#10;&#10;    private fun executeDownload() {&#10;        if (isCancelled.get()) return&#10;        &#10;        setState(Constants.STATE_DOWNLOADING)&#10;        isPaused.set(false)&#10;        &#10;        downloadJob = scope.launch {&#10;            try {&#10;                performDownload()&#10;            } catch (e: CancellationException) {&#10;                Log.d(TAG, &quot;Download cancelled&quot;)&#10;                handleDownloadCancellation()&#10;            } catch (e: IOException) {&#10;                Log.e(TAG, &quot;Download IO error&quot;, e)&#10;                handleNetworkError(e)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Download error&quot;, e)&#10;                handleDownloadError(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun performDownload() {&#10;        // Get current downloaded bytes (important for resume)&#10;        val currentDownloadedBytes = downloadedBytes.get()&#10;        &#10;        // Update request model with current progress for HTTP Range header&#10;        downloadRequestFileModel = downloadRequestFileModel.copy(&#10;            downloadedBytes = currentDownloadedBytes&#10;        )&#10;        &#10;        Log.d(TAG, &quot;Starting download from byte: $currentDownloadedBytes&quot;)&#10;        &#10;        // Establish connection with Range header for resume&#10;        httpConnectionManager.buildConnectionToDownload()&#10;        &#10;        val contentLength = httpConnectionManager.getContentLength()&#10;        &#10;        // Set total bytes correctly for resume scenarios&#10;        if (totalBytes.get() &lt;= 0) {&#10;            // For new downloads, total = content length + already downloaded&#10;            val totalSize = if (currentDownloadedBytes &gt; 0) {&#10;                // Resume: add current downloaded bytes to remaining content length&#10;                currentDownloadedBytes + contentLength&#10;            } else {&#10;                // New download: just the content length&#10;                contentLength&#10;            }&#10;            totalBytes.set(totalSize)&#10;            Log.d(TAG, &quot;Total size set to: $totalSize bytes&quot;)&#10;        }&#10;        &#10;        // Validate that we can resume&#10;        if (currentDownloadedBytes &gt; 0 &amp;&amp; outputFile.exists()) {&#10;            val actualFileSize = outputFile.length()&#10;            if (actualFileSize != currentDownloadedBytes) {&#10;                Log.w(TAG, &quot;File size mismatch. Expected: $currentDownloadedBytes, Actual: $actualFileSize&quot;)&#10;                // Reset to actual file size&#10;                downloadedBytes.set(actualFileSize)&#10;                downloadRequestFileModel = downloadRequestFileModel.copy(&#10;                    downloadedBytes = actualFileSize&#10;                )&#10;                // Reconnect with correct range&#10;                httpConnectionManager.disconnect()&#10;                httpConnectionManager.buildConnectionToDownload()&#10;            }&#10;        }&#10;        &#10;        // Start streaming download from current position&#10;        httpConnectionManager.getInputStream()?.use { inputStream -&gt;&#10;            // IMPORTANT: Use append mode (true) when resuming&#10;            FileOutputStream(outputFile, currentDownloadedBytes &gt; 0).use { outputStream -&gt;&#10;                Log.d(TAG, &quot;Resume mode: ${currentDownloadedBytes &gt; 0}, File exists: ${outputFile.exists()}&quot;)&#10;                downloadDataStream(inputStream, outputStream)&#10;            }&#10;        } ?: throw IOException(&quot;Unable to get input stream&quot;)&#10;        &#10;        // Download completed successfully&#10;        setState(Constants.STATE_COMPLETED)&#10;        listener?.onDownloadComplete(&#10;            downloadRequestFileModel.downloadId,&#10;            true,&#10;            outputFile.absolutePath&#10;        )&#10;        &#10;        Log.d(TAG, &quot;Download completed. Final size: ${outputFile.length()} bytes&quot;)&#10;    }&#10;&#10;    private suspend fun downloadDataStream(&#10;        inputStream: java.io.InputStream,&#10;        outputStream: FileOutputStream&#10;    ) {&#10;        val buffer = ByteArray(Constants.BUFFER_SIZE)&#10;        var bytesRead: Int&#10;        var lastProgressUpdate = 0L&#10;&#10;        while (inputStream.read(buffer).also { bytesRead = it } != -1) {&#10;            // Check for cancellation&#10;            if (isCancelled.get()) {&#10;                throw CancellationException(&quot;Download cancelled&quot;)&#10;            }&#10;&#10;            // Handle pause state&#10;            while (isPaused.get() &amp;&amp; !isCancelled.get()) {&#10;                delay(100)&#10;            }&#10;&#10;            // Write data to file&#10;            outputStream.write(buffer, 0, bytesRead)&#10;            outputStream.flush()&#10;            &#10;            // Update progress&#10;            val currentDownloaded = downloadedBytes.addAndGet(bytesRead.toLong())&#10;            &#10;            // Throttle progress updates (every 100KB or 1%)&#10;            val shouldUpdateProgress = currentDownloaded - lastProgressUpdate &gt;= 100_000 ||&#10;                    (totalBytes.get() &gt; 0 &amp;&amp; (currentDownloaded * 100 / totalBytes.get()) &gt; (lastProgressUpdate * 100 / totalBytes.get()))&#10;            &#10;            if (shouldUpdateProgress) {&#10;                notifyProgress(currentDownloaded)&#10;                lastProgressUpdate = currentDownloaded&#10;            }&#10;            &#10;            // Yield to allow other coroutines to run and check for state changes&#10;            yield()&#10;        }&#10;    }&#10;&#10;    private fun notifyProgress(downloaded: Long) {&#10;        val total = totalBytes.get()&#10;        val percentage = if (total &gt; 0) {&#10;            ((downloaded * 100) / total).toInt()&#10;        } else 0&#10;        &#10;        listener?.onProgressUpdate(&#10;            downloadRequestFileModel.downloadId,&#10;            downloaded,&#10;            total,&#10;            percentage&#10;        )&#10;    }&#10;&#10;    private fun handleNetworkError(exception: IOException) {&#10;        if (networkManager.isConnected()) {&#10;            // Network is available but connection failed - retry&#10;            handleRetry(exception)&#10;        } else {&#10;            // No network - wait for reconnection&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;            Log.d(TAG, &quot;Network lost during download, waiting for reconnection...&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleRetry(exception: Exception) {&#10;        if (retryCount &lt; Constants.MAX_RETRY_ATTEMPTS &amp;&amp; !isCancelled.get()) {&#10;            retryCount++&#10;            Log.d(TAG, &quot;Retrying download... Attempt $retryCount/${Constants.MAX_RETRY_ATTEMPTS}&quot;)&#10;            &#10;            scope.launch {&#10;                delay(Constants.RETRY_DELAY_MS)&#10;                if (!isCancelled.get()) {&#10;                    executeDownload()&#10;                }&#10;            }&#10;        } else {&#10;            setState(Constants.STATE_FAILED)&#10;            listener?.onDownloadError(&#10;                downloadRequestFileModel.downloadId,&#10;                &quot;Download failed after $retryCount attempts: ${exception.message}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun handleDownloadError(exception: Exception) {&#10;        setState(Constants.STATE_FAILED)&#10;        listener?.onDownloadError(&#10;            downloadRequestFileModel.downloadId,&#10;            &quot;Download error: ${exception.message}&quot;&#10;        )&#10;    }&#10;&#10;    private fun handleDownloadCancellation() {&#10;        setState(Constants.STATE_CANCELLED)&#10;        // Delete partial file if download was cancelled&#10;        if (outputFile.exists() &amp;&amp; downloadedBytes.get() &lt; totalBytes.get()) {&#10;            outputFile.delete()&#10;            Log.d(TAG, &quot;Deleted partial download file&quot;)&#10;        }&#10;        listener?.onDownloadCancelled(downloadRequestFileModel.downloadId)&#10;    }&#10;&#10;    // DownloadController implementation&#10;    override fun pauseDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            isPaused.set(true)&#10;            setState(Constants.STATE_PAUSED)&#10;            listener?.onDownloadPaused(downloadRequestFileModel.downloadId)&#10;            Log.d(TAG, &quot;Download paused&quot;)&#10;        }&#10;    }&#10;&#10;    override fun resumeDownload() {&#10;        when (currentState.get()) {&#10;            Constants.STATE_PAUSED -&gt; {&#10;                if (networkManager.isConnected()) {&#10;                    isPaused.set(false)&#10;                    setState(Constants.STATE_DOWNLOADING)&#10;                    listener?.onDownloadResumed(downloadRequestFileModel.downloadId)&#10;                    Log.d(TAG, &quot;Download resumed&quot;)&#10;                } else {&#10;                    setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;                    isWaitingForNetwork.set(true)&#10;                    Log.d(TAG, &quot;Cannot resume - no network connection&quot;)&#10;                }&#10;            }&#10;            Constants.STATE_FAILED -&gt; {&#10;                // Allow resume after failure&#10;                retryCount = 0&#10;                executeDownload()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun cancelDownload() {&#10;        isCancelled.set(true)&#10;        isPaused.set(false)&#10;        downloadJob?.cancel()&#10;        cleanup()&#10;        Log.d(TAG, &quot;Download cancelled&quot;)&#10;    }&#10;&#10;    override fun getDownloadState(): Int = currentState.get()&#10;&#10;    override fun getCurrentProgress(): Long = downloadedBytes.get()&#10;&#10;    override fun getTotalSize(): Long = totalBytes.get()&#10;&#10;    // NetworkManager.NetworkConnectionState implementation&#10;    override fun onConnected() {&#10;        Log.d(TAG, &quot;Network reconnected&quot;)&#10;        &#10;        if (isWaitingForNetwork.get() || currentState.get() == Constants.STATE_WAITING_FOR_NETWORK) {&#10;            isWaitingForNetwork.set(false)&#10;            retryCount = 0 // Reset retry count on network reconnection&#10;            &#10;            listener?.onNetworkReconnected(downloadRequestFileModel.downloadId)&#10;            &#10;            // Resume download automatically when network is restored&#10;            executeDownload()&#10;        }&#10;    }&#10;&#10;    override fun onDisconnected() {&#10;        Log.d(TAG, &quot;Network disconnected&quot;)&#10;        &#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;        }&#10;    }&#10;&#10;    private fun setState(newState: Int) {&#10;        val oldState = currentState.getAndSet(newState)&#10;        if (oldState != newState) {&#10;            listener?.onDownloadStateChanged(downloadRequestFileModel.downloadId, newState)&#10;        }&#10;    }&#10;&#10;    fun cleanup() {&#10;        downloadJob?.cancel()&#10;        httpConnectionManager.disconnect()&#10;        networkManager.cleanup()&#10;        scope.cancel()&#10;    }&#10;&#10;    // Utility methods&#10;    fun getDownloadInfo(): DownloadRequestFileModel {&#10;        return downloadRequestFileModel.copy(&#10;            downloadedBytes = downloadedBytes.get(),&#10;            totalBytes = totalBytes.get(),&#10;            state = currentState.get(),&#10;            progress = if (totalBytes.get() &gt; 0) {&#10;                (downloadedBytes.get().toFloat() / totalBytes.get().toFloat()) * 100&#10;            } else 0f&#10;        )&#10;    }&#10;&#10;    fun isActive(): Boolean {&#10;        return currentState.get() in listOf(&#10;            Constants.STATE_DOWNLOADING,&#10;            Constants.STATE_WAITING_FOR_NETWORK&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/HttpConnectionManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/HttpConnectionManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.annotation.SuppressLint&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants.CONNECT_TIMEOUT&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.util.Locale&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HttpConnectionManager(private val request: DownloadRequestFileModel) {&#10;    private val TAG = &quot;HttpConnectionManager&quot;&#10;    private var httpURLConnection : HttpURLConnection? = null&#10;&#10;    suspend fun buildConnectionToDownload() {&#10;        disconnect()&#10;        httpURLConnection = createConnection(request.url).also { conn -&gt;&#10;            configureConnection(conn)&#10;            conn.connect()&#10;        }&#10;    }&#10;&#10;    private fun createConnection(url: String): HttpURLConnection {&#10;        return URL(url).openConnection() as HttpURLConnection&#10;    }&#10;    private fun configureConnection(conn: HttpURLConnection) {&#10;        conn.connectTimeout = CONNECT_TIMEOUT.toInt()&#10;        if (request.downloadedBytes &gt; 0) {&#10;            val rangeHeader = String.format(&#10;                Locale.ENGLISH,&#10;                &quot;bytes=%d-&quot;,&#10;                request.downloadedBytes&#10;            )&#10;            Log.d(TAG, &quot;configureConnection: =====&gt; rangeHeader&quot;)&#10;            conn.setRequestProperty(Constants.RANGE_HEADER, rangeHeader)&#10;        }&#10;    }&#10;    fun getInputStream(): InputStream? = httpURLConnection?.inputStream&#10;    fun getResponseCode(): Int = httpURLConnection?.responseCode ?: 0&#10;&#10;    fun getContentLength(): Long = httpURLConnection?.contentLengthLong ?: -1L&#10;&#10;    fun isValidResponse(): Boolean {&#10;        val responseCode = getResponseCode()&#10;        return responseCode == Constants.HTTP_OK || responseCode == Constants.HTTP_PARTIAL_CONTENT&#10;    }&#10;    fun disconnect() {&#10;        httpURLConnection?.disconnect()&#10;        httpURLConnection = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants.CONNECT_TIMEOUT&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import java.io.IOException&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.util.Locale&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HttpConnectionManager(private val request: DownloadRequestFileModel) {&#10;    private val TAG = &quot;HttpConnectionManager&quot;&#10;    private var httpURLConnection : HttpURLConnection? = null&#10;&#10;    suspend fun buildConnectionToDownload() {&#10;        disconnect()&#10;        httpURLConnection = createConnection(request.url).also { conn -&gt;&#10;            configureConnection(conn)&#10;            conn.connect()&#10;        }&#10;        &#10;        if (!isValidResponse()) {&#10;            throw IOException(&quot;Invalid HTTP response: ${getResponseCode()}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun createConnection(url: String): HttpURLConnection {&#10;        return URL(url).openConnection() as HttpURLConnection&#10;    }&#10;    &#10;    private fun configureConnection(conn: HttpURLConnection) {&#10;        conn.connectTimeout = CONNECT_TIMEOUT.toInt()&#10;        conn.readTimeout = CONNECT_TIMEOUT.toInt()&#10;        &#10;        if (request.downloadedBytes &gt; 0) {&#10;            val rangeHeader = String.format(&#10;                Locale.ENGLISH,&#10;                &quot;bytes=%d-&quot;,&#10;                request.downloadedBytes&#10;            )&#10;            Log.d(TAG, &quot;configureConnection: =====&gt; rangeHeader: $rangeHeader&quot;)&#10;            conn.setRequestProperty(Constants.RANGE_HEADER, rangeHeader)&#10;        }&#10;    }&#10;    &#10;    fun getInputStream(): InputStream? = httpURLConnection?.inputStream&#10;    &#10;    fun getResponseCode(): Int = httpURLConnection?.responseCode ?: 0&#10;&#10;    fun getContentLength(): Long = httpURLConnection?.contentLengthLong ?: -1L&#10;    &#10;    fun getETag(): String? = httpURLConnection?.getHeaderField(Constants.ETAG_HEADER)&#10;&#10;    fun isValidResponse(): Boolean {&#10;        val responseCode = getResponseCode()&#10;        return responseCode == Constants.HTTP_OK || responseCode == Constants.HTTP_PARTIAL_CONTENT&#10;    }&#10;    &#10;    fun disconnect() {&#10;        httpURLConnection?.disconnect()&#10;        httpURLConnection = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/NetworkManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/NetworkManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.net.NetworkRequest&#10;import android.util.Log&#10;import androidx.room.concurrent.AtomicBoolean&#10;&#10;class NetworkManager(context: Context, val listener: NetworkConnectionState) {&#10;    interface NetworkConnectionState {&#10;        fun onConnected()&#10;        fun onDisconnected()&#10;    }&#10;    private val TAG = &quot;NetworkManager&quot;&#10;&#10;    private var isReconnected = AtomicBoolean(false)&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun isConnected(): Boolean {&#10;        val network = connectManager.activeNetwork ?: return false&#10;        val capabilities = connectManager.getNetworkCapabilities(network) ?: return false&#10;        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;    }&#10;&#10;    private val connectManager = context.getSystemService(ConnectivityManager::class.java) as ConnectivityManager&#10;    private val networkRequest = NetworkRequest.Builder()&#10;        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)&#10;        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)&#10;        .build()&#10;&#10;    private val networkCallback = object : ConnectivityManager.NetworkCallback() {&#10;        override fun onAvailable(network: android.net.Network) {&#10;            Log.d(TAG, &quot;onAvailable: ======&gt;&quot;)&#10;            super.onAvailable(network)&#10;            if (isReconnected.get()) {&#10;                listener.onConnected()&#10;                isReconnected.set(false)&#10;            }&#10;        }&#10;&#10;        override fun onLost(network: android.net.Network) {&#10;            super.onLost(network)&#10;            Log.d(TAG, &quot;onLost: ======&gt;&quot;)&#10;            listener.onDisconnected()&#10;            isReconnected.set(true)&#10;        }&#10;    }&#10;&#10;    fun init() {&#10;        connectManager.requestNetwork(networkRequest, networkCallback)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.net.NetworkRequest&#10;import android.util.Log&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;&#10;class NetworkManager(private val context: Context, private val listener: NetworkConnectionState) {&#10;    interface NetworkConnectionState {&#10;        fun onConnected()&#10;        fun onDisconnected()&#10;    }&#10;    private val TAG = &quot;NetworkManager&quot;&#10;&#10;    private var isReconnected = AtomicBoolean(false)&#10;    private var isRegistered = false&#10;&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    fun isConnected(): Boolean {&#10;        val network = connectManager.activeNetwork ?: return false&#10;        val capabilities = connectManager.getNetworkCapabilities(network) ?: return false&#10;        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;    }&#10;&#10;    private val connectManager = context.getSystemService(ConnectivityManager::class.java) as ConnectivityManager&#10;    private val networkRequest = NetworkRequest.Builder()&#10;        .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;        .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)&#10;        .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)&#10;        .build()&#10;&#10;    private val networkCallback = object : ConnectivityManager.NetworkCallback() {&#10;        override fun onAvailable(network: android.net.Network) {&#10;            Log.d(TAG, &quot;onAvailable: ======&gt;&quot;)&#10;            super.onAvailable(network)&#10;            if (isReconnected.get()) {&#10;                listener.onConnected()&#10;                isReconnected.set(false)&#10;            }&#10;        }&#10;&#10;        override fun onLost(network: android.net.Network) {&#10;            super.onLost(network)&#10;            Log.d(TAG, &quot;onLost: ======&gt;&quot;)&#10;            listener.onDisconnected()&#10;            isReconnected.set(true)&#10;        }&#10;    }&#10;    &#10;    fun registerNetworkCallback() {&#10;        if (!isRegistered) {&#10;            connectManager.registerNetworkCallback(networkRequest, networkCallback)&#10;            isRegistered = true&#10;            Log.d(TAG, &quot;Network callback registered&quot;)&#10;        }&#10;    }&#10;    &#10;    fun unregisterNetworkCallback() {&#10;        if (isRegistered) {&#10;            try {&#10;                connectManager.unregisterNetworkCallback(networkCallback)&#10;                isRegistered = false&#10;                Log.d(TAG, &quot;Network callback unregistered&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error unregistering network callback&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun cleanup() {&#10;        unregisterNetworkCallback()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestDao.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy.Companion.REPLACE&#10;import androidx.room.Query&#10;&#10;@Dao&#10;interface DataRequestDao {&#10;    @Insert(onConflict = REPLACE)&#10;    suspend fun insertDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Update&#10;    suspend fun updateDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Query(&quot;UPDATE download_requests SET state = :state, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadState(downloadId: Long, state: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET downloadedBytes = :downloadedBytes, progress = :progress, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadProgress(downloadId: Long, downloadedBytes: Long, progress: Float, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET totalBytes = :totalBytes, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateTotalBytes(downloadId: Long, totalBytes: Long, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET retryCount = :retryCount, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateRetryCount(downloadId: Long, retryCount: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET errorMessage = :errorMessage, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateErrorMessage(downloadId: Long, errorMessage: String?, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    // Query methods for resume functionality&#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun getDownloadRequest(downloadId: Long): DataRequestModel?&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (:states)&quot;)&#10;    suspend fun getDownloadsByState(states: List&lt;Int&gt;): List&lt;DataRequestModel&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadsByState(state: Int): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get incomplete downloads for resume (downloading, paused, waiting for network)&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (1, 2, 6) ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getIncompleteDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get failed downloads for retry&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = 4 ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getFailedDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get all downloads ordered by most recent&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getAllDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Live data for UI updates&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DataRequestModel&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    fun getDownloadRequestFlow(downloadId: Long): Flow&lt;DataRequestModel?&gt;&#10;    &#10;    // Cleanup methods&#10;    @Query(&quot;DELETE FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun deleteDownloadRequest(downloadId: Long)&#10;    &#10;    @Query(&quot;DELETE FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun deleteDownloadsByState(state: Int)&#10;    &#10;    // Delete old completed downloads (older than specified timestamp)&#10;    @Query(&quot;DELETE FROM download_requests WHERE state = 3 AND updatedAt &lt; :beforeTimestamp&quot;)&#10;    suspend fun deleteOldCompletedDownloads(beforeTimestamp: Long)&#10;    &#10;    // Get download statistics&#10;    @Query(&quot;SELECT COUNT(*) FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadCountByState(state: Int): Int&#10;    &#10;    @Query(&quot;SELECT state, COUNT(*) as count FROM download_requests GROUP BY state&quot;)&#10;    suspend fun getDownloadStatistics(): Map&lt;Int, Int&gt;&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy.Companion.REPLACE&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface DataRequestDao {&#10;    &#10;    @Insert(onConflict = REPLACE)&#10;    suspend fun insertDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Update&#10;    suspend fun updateDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Query(&quot;UPDATE download_requests SET state = :state, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadState(downloadId: Long, state: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET downloadedBytes = :downloadedBytes, progress = :progress, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadProgress(downloadId: Long, downloadedBytes: Long, progress: Float, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET totalBytes = :totalBytes, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateTotalBytes(downloadId: Long, totalBytes: Long, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET retryCount = :retryCount, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateRetryCount(downloadId: Long, retryCount: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET errorMessage = :errorMessage, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateErrorMessage(downloadId: Long, errorMessage: String?, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    // Query methods for resume functionality&#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun getDownloadRequest(downloadId: Long): DataRequestModel?&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (:states)&quot;)&#10;    suspend fun getDownloadsByState(states: List&lt;Int&gt;): List&lt;DataRequestModel&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadsByState(state: Int): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get incomplete downloads for resume (downloading, paused, waiting for network)&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (1, 2, 6) ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getIncompleteDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get failed downloads for retry&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = 4 ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getFailedDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get all downloads ordered by most recent&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getAllDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Live data for UI updates&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DataRequestModel&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    fun getDownloadRequestFlow(downloadId: Long): Flow&lt;DataRequestModel?&gt;&#10;    &#10;    // Cleanup methods&#10;    @Query(&quot;DELETE FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun deleteDownloadRequest(downloadId: Long)&#10;    &#10;    @Query(&quot;DELETE FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun deleteDownloadsByState(state: Int)&#10;    &#10;    // Delete old completed downloads (older than specified timestamp)&#10;    @Query(&quot;DELETE FROM download_requests WHERE state = 3 AND updatedAt &lt; :beforeTimestamp&quot;)&#10;    suspend fun deleteOldCompletedDownloads(beforeTimestamp: Long)&#10;    &#10;    // Get download statistics&#10;    @Query(&quot;SELECT COUNT(*) FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadCountByState(state: Int): Int&#10;    &#10;    @Query(&quot;SELECT state, COUNT(*) as count FROM download_requests GROUP BY state&quot;)&#10;    suspend fun getDownloadStatistics(): Map&lt;Int, Int&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestModel.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;data_request_table&quot;)&#10;data class DataRequestModel(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id : Long = System.currentTimeMillis(),&#10;    val downloadId : Long = 0,&#10;    val fileName : String = &quot;&quot;,&#10;    val url : String = &quot;&quot;,&#10;    val progress : Float = 0.0f,&#10;    val downloadedBytes : Long = 0L,&#10;    val totalBytes : Long = 0L,&#10;    val state : Int = 0 // 0: idle, 1: downloading, 2: completed, 3: failed&#10;)" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;download_requests&quot;)&#10;data class DataRequestModel(&#10;    @PrimaryKey&#10;    val downloadId: Long,&#10;    val fileName: String = &quot;&quot;,&#10;    val url: String = &quot;&quot;,&#10;    val filePath: String = &quot;&quot;, // Added: Full file path for resume&#10;    val progress: Float = 0.0f,&#10;    val downloadedBytes: Long = 0L,&#10;    val totalBytes: Long = 0L,&#10;    val state: Int = 0, // Using Constants.STATE_* values&#10;    val createdAt: Long = System.currentTimeMillis(),&#10;    val updatedAt: Long = System.currentTimeMillis(),&#10;    val etag: String? = null, // Added: For server validation&#10;    val retryCount: Int = 0, // Added: Track retry attempts&#10;    val errorMessage: String? = null // Added: Last error message&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DatabaseCache.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DatabaseCache.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk.db&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;&#10;abstract class DatabaseCache : RoomDatabase() {&#10;&#10;    abstract fun getDataRequestDao() : DataRequestDao&#10;&#10;    companion object {&#10;        private var databaseCache: DatabaseCache? = null&#10;        fun create(context: Context) {&#10;            databaseCache =&#10;                Room.databaseBuilder(context, DatabaseCache::class.java, &quot;data_request&quot;).build()&#10;        }&#10;&#10;        fun getInstance(): DatabaseCache {&#10;            return databaseCache!!&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;&#10;@Database(&#10;    entities = [DataRequestModel::class],&#10;    version = 2,&#10;    exportSchema = false&#10;)&#10;abstract class DatabaseCache : RoomDatabase() {&#10;&#10;    abstract fun getDataRequestDao(): DataRequestDao&#10;&#10;    companion object {&#10;        private const val DATABASE_NAME = &quot;download_requests_db&quot;&#10;        &#10;        @Volatile&#10;        private var INSTANCE: DatabaseCache? = null&#10;        &#10;        // Migration from version 1 to 2 (if users have old database)&#10;        private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;            override fun migrate(database: SupportSQLiteDatabase) {&#10;                // Drop old table if exists and create new one&#10;                database.execSQL(&quot;DROP TABLE IF EXISTS data_request_table&quot;)&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE IF NOT EXISTS download_requests (&#10;                        downloadId INTEGER PRIMARY KEY NOT NULL,&#10;                        fileName TEXT NOT NULL,&#10;                        url TEXT NOT NULL,&#10;                        filePath TEXT NOT NULL,&#10;                        progress REAL NOT NULL,&#10;                        downloadedBytes INTEGER NOT NULL,&#10;                        totalBytes INTEGER NOT NULL,&#10;                        state INTEGER NOT NULL,&#10;                        createdAt INTEGER NOT NULL,&#10;                        updatedAt INTEGER NOT NULL,&#10;                        etag TEXT,&#10;                        retryCount INTEGER NOT NULL,&#10;                        errorMessage TEXT&#10;                    )&#10;                &quot;&quot;&quot;.trimIndent())&#10;            }&#10;        }&#10;        &#10;        fun create(context: Context) {&#10;            synchronized(this) {&#10;                if (INSTANCE == null) {&#10;                    INSTANCE = Room.databaseBuilder(&#10;                        context.applicationContext,&#10;                        DatabaseCache::class.java,&#10;                        DATABASE_NAME&#10;                    )&#10;                    .addMigrations(MIGRATION_1_2)&#10;                    .fallbackToDestructiveMigration() // For development - remove in production&#10;                    .build()&#10;                }&#10;            }&#10;        }&#10;&#10;        fun getInstance(): DatabaseCache {&#10;            return INSTANCE ?: throw IllegalStateException(&#10;                &quot;Database not initialized. Call create(context) first.&quot;&#10;            )&#10;        }&#10;        &#10;        fun closeDatabase() {&#10;            INSTANCE?.close()&#10;            INSTANCE = null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DownloadPersistenceManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DownloadPersistenceManager.kt" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;/**&#10; * Manages persistence of download requests to Room database&#10; * Enables resume functionality when app is reopened&#10; */&#10;class DownloadPersistenceManager private constructor() {&#10;    &#10;    private val TAG = &quot;DownloadPersistence&quot;&#10;    private lateinit var dao: DataRequestDao&#10;    private val persistenceScope = CoroutineScope(Dispatchers.IO)&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadPersistenceManager? = null&#10;        &#10;        fun getInstance(): DownloadPersistenceManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DownloadPersistenceManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun initialize(context: Context) {&#10;        DatabaseCache.create(context)&#10;        dao = DatabaseCache.getInstance().getDataRequestDao()&#10;        Log.d(TAG, &quot;DownloadPersistenceManager initialized&quot;)&#10;    }&#10;    &#10;    // Save download request to database&#10;    suspend fun saveDownloadRequest(request: DownloadRequestFileModel, filePath: String) {&#10;        withContext(Dispatchers.IO) {&#10;            val dataModel = request.toDataRequestEntity().copy(&#10;                filePath = filePath,&#10;                updatedAt = System.currentTimeMillis()&#10;            )&#10;            dao.insertDownloadRequest(dataModel)&#10;            Log.d(TAG, &quot;Saved download request: ${request.fileName} (ID: ${request.downloadId})&quot;)&#10;        }&#10;    }&#10;    &#10;    // Update download progress in database&#10;    fun updateProgress(downloadId: Long, downloadedBytes: Long, totalBytes: Long) {&#10;        persistenceScope.launch {&#10;            val progress = if (totalBytes &gt; 0) {&#10;                (downloadedBytes.toFloat() / totalBytes.toFloat()) * 100&#10;            } else 0f&#10;            &#10;            dao.updateDownloadProgress(downloadId, downloadedBytes, progress)&#10;            &#10;            if (totalBytes &gt; 0) {&#10;                dao.updateTotalBytes(downloadId, totalBytes)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Update download state in database&#10;    fun updateState(downloadId: Long, state: Int, errorMessage: String? = null) {&#10;        persistenceScope.launch {&#10;            dao.updateDownloadState(downloadId, state)&#10;            errorMessage?.let { &#10;                dao.updateErrorMessage(downloadId, it)&#10;            }&#10;            Log.d(TAG, &quot;Updated state for download $downloadId to ${getStateString(state)}&quot;)&#10;        }&#10;    }&#10;    &#10;    // Update retry count&#10;    fun updateRetryCount(downloadId: Long, retryCount: Int) {&#10;        persistenceScope.launch {&#10;            dao.updateRetryCount(downloadId, retryCount)&#10;        }&#10;    }&#10;    &#10;    // Get incomplete downloads for resume when app opens&#10;    suspend fun getIncompleteDownloads(): List&lt;DownloadRequestFileModel&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            val incompleteDownloads = dao.getIncompleteDownloads()&#10;            Log.d(TAG, &quot;Found ${incompleteDownloads.size} incomplete downloads to resume&quot;)&#10;            incompleteDownloads.map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Get failed downloads for potential retry&#10;    suspend fun getFailedDownloads(): List&lt;DownloadRequestFileModel&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            val failedDownloads = dao.getFailedDownloads()&#10;            Log.d(TAG, &quot;Found ${failedDownloads.size} failed downloads&quot;)&#10;            failedDownloads.map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Get specific download request&#10;    suspend fun getDownloadRequest(downloadId: Long): DownloadRequestFileModel? {&#10;        return withContext(Dispatchers.IO) {&#10;            dao.getDownloadRequest(downloadId)?.toDownloadRequestFileModel()&#10;        }&#10;    }&#10;    &#10;    // Get all downloads for UI display&#10;    suspend fun getAllDownloads(): List&lt;DownloadRequestFileModel&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            dao.getAllDownloads().map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Flow for real-time UI updates&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DownloadRequestFileModel&gt;&gt; {&#10;        return dao.getAllDownloadsFlow().map { list -&gt;&#10;            list.map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Flow for specific download&#10;    fun getDownloadFlow(downloadId: Long): Flow&lt;DownloadRequestFileModel?&gt; {&#10;        return dao.getDownloadRequestFlow(downloadId).map { &#10;            it?.toDownloadRequestFileModel() &#10;        }&#10;    }&#10;    &#10;    // Check if file exists and validate download integrity&#10;    suspend fun validateDownloadFile(downloadId: Long): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            val request = dao.getDownloadRequest(downloadId) ?: return@withContext false&#10;            val file = File(request.filePath)&#10;            &#10;            if (!file.exists()) {&#10;                Log.w(TAG, &quot;Download file not found: ${request.filePath}&quot;)&#10;                return@withContext false&#10;            }&#10;            &#10;            val actualFileSize = file.length()&#10;            val expectedSize = request.downloadedBytes&#10;            &#10;            if (actualFileSize != expectedSize) {&#10;                Log.w(TAG, &quot;File size mismatch. Expected: $expectedSize, Actual: $actualFileSize&quot;)&#10;                // Update database with actual file size&#10;                dao.updateDownloadProgress(downloadId, actualFileSize, &#10;                    if (request.totalBytes &gt; 0) (actualFileSize.toFloat() / request.totalBytes) * 100 else 0f)&#10;                return@withContext false&#10;            }&#10;            &#10;            Log.d(TAG, &quot;Download file validated: ${request.fileName}&quot;)&#10;            true&#10;        }&#10;    }&#10;    &#10;    // Delete download from database&#10;    suspend fun deleteDownload(downloadId: Long) {&#10;        withContext(Dispatchers.IO) {&#10;            dao.deleteDownloadRequest(downloadId)&#10;            Log.d(TAG, &quot;Deleted download request: $downloadId&quot;)&#10;        }&#10;    }&#10;    &#10;    // Cleanup old completed downloads (older than 30 days)&#10;    suspend fun cleanupOldDownloads(daysOld: Int = 30) {&#10;        withContext(Dispatchers.IO) {&#10;            val cutoffTime = System.currentTimeMillis() - (daysOld * 24 * 60 * 60 * 1000L)&#10;            dao.deleteOldCompletedDownloads(cutoffTime)&#10;            Log.d(TAG, &quot;Cleaned up downloads older than $daysOld days&quot;)&#10;        }&#10;    }&#10;    &#10;    // Get download statistics from database&#10;    suspend fun getDownloadStatistics(): Map&lt;Int, Int&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            dao.getDownloadStatistics()&#10;        }&#10;    }&#10;    &#10;    private fun getStateString(state: Int): String {&#10;        return when (state) {&#10;            Constants.STATE_IDLE -&gt; &quot;Idle&quot;&#10;            Constants.STATE_DOWNLOADING -&gt; &quot;Downloading&quot;&#10;            Constants.STATE_PAUSED -&gt; &quot;Paused&quot;&#10;            Constants.STATE_COMPLETED -&gt; &quot;Completed&quot;&#10;            Constants.STATE_FAILED -&gt; &quot;Failed&quot;&#10;            Constants.STATE_CANCELLED -&gt; &quot;Cancelled&quot;&#10;            Constants.STATE_WAITING_FOR_NETWORK -&gt; &quot;Waiting for Network&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;}&#10;&#10;// Extension functions for conversion between models&#10;fun DataRequestModel.toDownloadRequestFileModel(): DownloadRequestFileModel {&#10;    return DownloadRequestFileModel(&#10;        id = downloadId,&#10;        downloadId = downloadId,&#10;        fileName = fileName,&#10;        url = url,&#10;        progress = progress,&#10;        downloadedBytes = downloadedBytes,&#10;        totalBytes = totalBytes,&#10;        state = state&#10;    )&#10;}&#10;&#10;fun DownloadRequestFileModel.toDataRequestEntity(): DataRequestModel {&#10;    return DataRequestModel(&#10;        downloadId = downloadId,&#10;        fileName = fileName,&#10;        url = url,&#10;        filePath = &quot;&quot;, // Will be set when saving&#10;        progress = progress,&#10;        downloadedBytes = downloadedBytes,&#10;        totalBytes = totalBytes,&#10;        state = state,&#10;        createdAt = System.currentTimeMillis(),&#10;        updatedAt = System.currentTimeMillis(),&#10;        retryCount = 0&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;&#10;    &lt;!-- Storage permissions for different Android versions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&#10;        android:maxSdkVersion=&quot;32&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#10;        android:maxSdkVersion=&quot;29&quot; /&gt;&#10;&#10;    &lt;!-- Android 13+ permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.App&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.UpgradeFirmware&quot;&#10;        android:requestLegacyExternalStorage=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.UpgradeFirmware&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; &#13;&#10;        android:maxSdkVersion=&quot;29&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; &#13;&#10;        android:maxSdkVersion=&quot;32&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;!-- Android 13+ permissions --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_IMAGES&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_VIDEO&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_MEDIA_AUDIO&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:name=&quot;.App&quot;&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.UpgradeFirmware&quot;&#13;&#10;        android:requestLegacyExternalStorage=&quot;true&quot;&gt;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:label=&quot;@string/app_name&quot;&#13;&#10;            android:theme=&quot;@style/Theme.UpgradeFirmware&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;        &#13;&#10;        &lt;!-- NetworkStateReceiver để listen network changes --&gt;&#13;&#10;        &lt;receiver android:name=&quot;.network.NetworkStateReceiver&quot;&#13;&#10;            android:enabled=&quot;true&quot;&#13;&#10;            android:exported=&quot;false&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/receiver&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/App.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/App.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;&#10;class App : Application() {&#10;    &#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        &#10;        // Khởi tạo DownloadingManager&#10;        DownloadingManager.create(this)&#10;        &#10;        Log.d(&quot;App&quot;, &quot;DownloadingManager initialized - will auto-resume incomplete downloads&quot;)&#10;    }&#10;    &#10;    override fun onTerminate() {&#10;        super.onTerminate()&#10;        &#10;        // Cleanup khi app terminate&#10;        DownloadingManager.getInstance().cleanup()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ContentProviderDownloadExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ContentProviderDownloadExample.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Usage examples for ContentProvider-based download system&#10; * Compatible with Android 14+ scoped storage requirements&#10; */&#10;class ContentProviderDownloadExample {&#10;    &#10;    fun demonstrateBasicDownloadWithContentProvider(context: Context) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        // Create download request&#10;        val downloadRequest = DownloadRequest.Builder()&#10;            .url(&quot;https://example.com/firmware.bin&quot;)&#10;            .downloadId(System.currentTimeMillis())&#10;            .connectTimeOut(30_000)&#10;            .build()&#10;        &#10;        val fileName = &quot;Firmware01_1.4.0.bin&quot;&#10;        &#10;        // Create listener for handling download events&#10;        val downloadListener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                println(&quot;Download progress: $percentage% (${formatBytes(downloaded)}/${formatBytes(total)})&quot;)&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    println(&quot;✅ Download completed successfully!&quot;)&#10;                    println(&quot;File URI: $filePath&quot;)&#10;                    println(&quot;File saved to Downloads folder via MediaStore&quot;)&#10;                } else {&#10;                    println(&quot;❌ Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;⚠️ Download error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                println(&quot; Download state: $state&quot;)&#10;            }&#10;        }&#10;        &#10;        // Start download with ContentProvider support&#10;        try {&#10;            val downloadId = firmwareManager.startDownload(&#10;                context = context,&#10;                request = downloadRequest,&#10;                fileName = fileName,&#10;                listener = downloadListener&#10;            )&#10;            println(&quot; Download started with ID: $downloadId&quot;)&#10;            println(&quot; File will be saved to Downloads folder using MediaStore API&quot;)&#10;        } catch (e: IllegalStateException) {&#10;            println(&quot;❌ Failed to start download: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    fun demonstrateDownloadControlWithUri(context: Context) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        val downloadId = System.currentTimeMillis()&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            // Start a download&#10;            val request = DownloadRequest.Builder()&#10;                .url(&quot;https://example.com/large-firmware.bin&quot;)&#10;                .downloadId(downloadId)&#10;                .build()&#10;            &#10;            firmwareManager.startDownload(&#10;                context = context,&#10;                request = request,&#10;                fileName = &quot;large-firmware.bin&quot;&#10;            )&#10;            &#10;            // Monitor and control the download&#10;            delay(5_000)&#10;            &#10;            // Pause download&#10;            if (firmwareManager.pauseDownload(downloadId)) {&#10;                println(&quot;⏸️ Download paused successfully&quot;)&#10;                &#10;                // Get file URI while paused&#10;                val fileUri = firmwareManager.getDownloadFileUri(downloadId)&#10;                println(&quot; Current file URI: $fileUri&quot;)&#10;            }&#10;            &#10;            // Resume after 3 seconds&#10;            delay(3_000)&#10;            if (firmwareManager.resumeDownload(downloadId)) {&#10;                println(&quot;▶️ Download resumed successfully&quot;)&#10;            }&#10;            &#10;            // Cancel after 10 more seconds&#10;            delay(10_000)&#10;            if (firmwareManager.cancelDownload(downloadId)) {&#10;                println(&quot;❌ Download cancelled - file automatically deleted&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun demonstrateMultipleDownloadsWithContentProvider(context: Context) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        val downloadIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        // Start multiple firmware downloads&#10;        val firmwareFiles = listOf(&#10;            &quot;Firmware_v1.4.0.bin&quot;,&#10;            &quot;Firmware_v1.4.1.bin&quot;, &#10;            &quot;Firmware_v1.4.2.bin&quot;&#10;        )&#10;        &#10;        firmwareFiles.forEachIndexed { index, fileName -&gt;&#10;            val request = DownloadRequest.Builder()&#10;                .url(&quot;https://example.com/firmware/$fileName&quot;)&#10;                .downloadId(System.currentTimeMillis() + index)&#10;                .build()&#10;            &#10;            val downloadId = firmwareManager.startDownload(&#10;                context = context,&#10;                request = request,&#10;                fileName = fileName,&#10;                listener = createDownloadListener(fileName)&#10;            )&#10;            &#10;            downloadIds.add(downloadId)&#10;            println(&quot; Started download: $fileName (ID: $downloadId)&quot;)&#10;        }&#10;        &#10;        // Monitor all downloads&#10;        monitorMultipleDownloads(firmwareManager, downloadIds)&#10;    }&#10;    &#10;    private fun createDownloadListener(fileName: String): DownloadListener {&#10;        return object : DownloadListener {&#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                // Throttle progress updates for multiple downloads&#10;                if (percentage % 10 == 0) {&#10;                    println(&quot;[$fileName] Progress: $percentage%&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    println(&quot;✅ [$fileName] Download completed: $filePath&quot;)&#10;                } else {&#10;                    println(&quot;❌ [$fileName] Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;⚠️ [$fileName] Error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                println(&quot; [$fileName] State: $state&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun monitorMultipleDownloads(&#10;        firmwareManager: FirmwareManager,&#10;        downloadIds: List&lt;Long&gt;&#10;    ) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            while (downloadIds.any { firmwareManager.isDownloadActive(it) }) {&#10;                println(&quot;\n === Download Status ===&quot;)&#10;                &#10;                downloadIds.forEach { downloadId -&gt;&#10;                    val state = firmwareManager.getDownloadState(downloadId)&#10;                    val progress = firmwareManager.getDownloadProgress(downloadId)&#10;                    val isActive = firmwareManager.isDownloadActive(downloadId)&#10;                    val fileUri = firmwareManager.getDownloadFileUri(downloadId)&#10;                    &#10;                    println(&quot;ID: $downloadId | State: $state | Progress: ${formatBytes(progress)} | Active: $isActive&quot;)&#10;                    if (fileUri != null) {&#10;                        println(&quot;   URI: $fileUri&quot;)&#10;                    }&#10;                }&#10;                &#10;                println(&quot;Active downloads: ${firmwareManager.getActiveDownloadCount()}&quot;)&#10;                println(&quot;========================\n&quot;)&#10;                &#10;                delay(3_000) // Check every 3 seconds&#10;            }&#10;            &#10;            println(&quot; All downloads completed!&quot;)&#10;        }&#10;    }&#10;    &#10;    fun demonstrateResumeDownloadFromUri(context: Context) {&#10;        // This example shows how to resume a download that was previously started&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        // Simulate a download that was interrupted&#10;        val existingDownloadId = 12345L&#10;        val partiallyDownloadedBytes = 1024 * 512 // 512KB already downloaded&#10;        &#10;        val resumeRequest = DownloadRequest.Builder()&#10;            .url(&quot;https://example.com/firmware.bin&quot;)&#10;            .downloadId(existingDownloadId)&#10;            .downloadedBytes(partiallyDownloadedBytes) // Resume from this position&#10;            .build()&#10;        &#10;        val listener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                println(&quot; Resuming download: $percentage% (${formatBytes(downloaded)}/${formatBytes(total)})&quot;)&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                println(&quot;✅ Resume download completed: $filePath&quot;)&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;❌ Resume download error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                println(&quot; Resume download state: $state&quot;)&#10;            }&#10;        }&#10;        &#10;        try {&#10;            firmwareManager.startDownload(&#10;                context = context,&#10;                request = resumeRequest,&#10;                fileName = &quot;firmware_resumed.bin&quot;,&#10;                listener = listener&#10;            )&#10;            println(&quot; Resume download started from ${formatBytes(partiallyDownloadedBytes)}&quot;)&#10;        } catch (e: Exception) {&#10;            println(&quot;❌ Failed to resume download: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024 * 1024)} GB&quot;&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;            bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadConstants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadConstants.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;/**&#10; * Constants used throughout the download system&#10; */&#10;object DownloadConstants {&#10;    const val RANGE_HEADER = &quot;Range&quot;&#10;    const val ETAG_HEADER = &quot;ETag&quot;&#10;    const val USER_AGENT_HEADER = &quot;User-Agent&quot;&#10;    &#10;    const val DEFAULT_READ_TIMEOUT_MILLIS = 20_000&#10;    const val DEFAULT_CONNECT_TIMEOUT_MILLIS = 20_000&#10;    const val DEFAULT_BUFFER_SIZE = 8_192&#10;    const val PAUSE_CHECK_DELAY_MILLIS = 100L&#10;    &#10;    const val HTTP_OK = 200&#10;    const val HTTP_PARTIAL_CONTENT = 206&#10;    const val HTTP_RANGE_NOT_SATISFIABLE = 416&#10;    const val HTTP_TEMPORARY_REDIRECT = 307&#10;    const val HTTP_PERMANENT_REDIRECT = 308&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadExample.kt" />
              <option name="originalContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.File&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Example usage of the download functionality with pause, resume, and cancel operations&#10; */&#10;class DownloadExample {&#10;&#10;    fun demonstrateDownloadOperations() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;&#10;        // Create a download request&#10;        val downloadRequest = DownloadRequest(&#10;            url = &quot;https://example.com/firmware.bin&quot;,&#10;            downloadId = System.currentTimeMillis(),&#10;            fileName = &quot;firmware.bin&quot;,&#10;            connectTimeOut = 30000,&#10;            readTimeOut = 30000,&#10;            downloadedBytes = 0L,&#10;            requestState = RequestState.None&#10;        )&#10;&#10;        // Specify output file&#10;        val outputFile = File(&quot;/path/to/download/firmware.bin&quot;)&#10;&#10;        // Start download&#10;        firmwareManager.download(downloadRequest, outputFile)&#10;&#10;        // Example of pausing after 5 seconds&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            delay(5000)&#10;            println(&quot;Pausing download...&quot;)&#10;            firmwareManager.pause(downloadRequest)&#10;&#10;            // Resume after 3 seconds&#10;            delay(3000)&#10;            println(&quot;Resuming download...&quot;)&#10;            firmwareManager.resume(downloadRequest)&#10;&#10;            // Cancel after 10 more seconds&#10;            delay(10000)&#10;            println(&quot;Cancelling download...&quot;)&#10;            firmwareManager.cancelRequest(downloadRequest)&#10;        }&#10;    }&#10;&#10;    fun monitorDownloadProgress(downloadId: Long) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            while (true) {&#10;                val state = firmwareManager.getRequestState(downloadId)&#10;                val progress = firmwareManager.getDownloadProgress(downloadId)&#10;                val isActive = firmwareManager.isDownloadActive(downloadId)&#10;&#10;                println(&quot;Download ID: $downloadId&quot;)&#10;                println(&quot;State: $state&quot;)&#10;                println(&quot;Progress: $progress bytes&quot;)&#10;                println(&quot;Active: $isActive&quot;)&#10;                println(&quot;---&quot;)&#10;&#10;                // Exit monitoring if download is completed, cancelled, or failed&#10;                if (state in listOf(RequestState.Completed, RequestState.Cancelled, RequestState.Failed)) {&#10;                    break&#10;                }&#10;&#10;                delay(1000) // Check every second&#10;            }&#10;        }&#10;    }&#10;&#10;    fun handleDownloadWithCallbacks() {&#10;        val downloadTask = DownloadTask()&#10;&#10;        // Set up progress callback&#10;        downloadTask.onProgressUpdate = { downloaded, total, percentage -&gt;&#10;            println(&quot;Progress: $downloaded/$total bytes ($percentage%)&quot;)&#10;        }&#10;&#10;        // Set up completion callback&#10;        downloadTask.onDownloadComplete = { success, filePath -&gt;&#10;            if (success) {&#10;                println(&quot;Download completed successfully: $filePath&quot;)&#10;            } else {&#10;                println(&quot;Download failed&quot;)&#10;            }&#10;        }&#10;&#10;        // Set up error callback&#10;        downloadTask.onDownloadError = { error -&gt;&#10;            println(&quot;Download error: $error&quot;)&#10;        }&#10;&#10;        // Example of manual control&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            delay(5000)&#10;            if (downloadTask.isDownloadActive()) {&#10;                downloadTask.pauseDownload()&#10;                println(&quot;Download paused&quot;)&#10;&#10;                delay(2000)&#10;                downloadTask.resumeDownload()&#10;                println(&quot;Download resumed&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.File&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Clean usage examples demonstrating the refactored download functionality&#10; * Shows proper implementation of the listener pattern and clean API usage&#10; */&#10;class CleanDownloadExample {&#10;    &#10;    fun demonstrateBasicDownload() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        // Create download request using builder pattern for better readability&#10;        val downloadRequest = DownloadRequest.Builder()&#10;            .url(&quot;https://example.com/firmware.bin&quot;)&#10;            .downloadId(System.currentTimeMillis())&#10;            .fileName(&quot;firmware.bin&quot;)&#10;            .connectTimeOut(30_000)&#10;            .readTimeOut(30_000)&#10;            .build()&#10;        &#10;        val outputFile = File(&quot;/path/to/download/firmware.bin&quot;)&#10;        &#10;        // Create listener for handling download events&#10;        val downloadListener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                println(&quot;Download progress: $percentage% ($downloaded/$total bytes)&quot;)&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    println(&quot;Download completed successfully: $filePath&quot;)&#10;                } else {&#10;                    println(&quot;Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;Download error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                println(&quot;Download state changed to: $state&quot;)&#10;            }&#10;        }&#10;        &#10;        // Start download with proper error handling&#10;        try {&#10;            val downloadId = firmwareManager.startDownload(downloadRequest, outputFile, downloadListener)&#10;            println(&quot;Download started with ID: $downloadId&quot;)&#10;        } catch (e: IllegalStateException) {&#10;            println(&quot;Failed to start download: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    fun demonstrateDownloadControl() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        val downloadId = System.currentTimeMillis()&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            // Pause download after 5 seconds&#10;            delay(5_000)&#10;            if (firmwareManager.pauseDownload(downloadId)) {&#10;                println(&quot;Download paused successfully&quot;)&#10;            } else {&#10;                println(&quot;Failed to pause download - download not found or not active&quot;)&#10;            }&#10;            &#10;            // Resume after 3 seconds&#10;            delay(3_000)&#10;            if (firmwareManager.resumeDownload(downloadId)) {&#10;                println(&quot;Download resumed successfully&quot;)&#10;            }&#10;            &#10;            // Cancel after 10 more seconds&#10;            delay(10_000)&#10;            if (firmwareManager.cancelDownload(downloadId)) {&#10;                println(&quot;Download cancelled successfully&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun demonstrateMultipleDownloads() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        // Start multiple downloads&#10;        val downloadIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        repeat(3) { index -&gt;&#10;            val request = DownloadRequest.Builder()&#10;                .url(&quot;https://example.com/firmware$index.bin&quot;)&#10;                .downloadId(System.currentTimeMillis() + index)&#10;                .fileName(&quot;firmware$index.bin&quot;)&#10;                .build()&#10;                &#10;            val outputFile = File(&quot;/path/to/firmware$index.bin&quot;)&#10;            val downloadId = firmwareManager.startDownload(request, outputFile)&#10;            downloadIds.add(downloadId)&#10;        }&#10;        &#10;        // Monitor all downloads&#10;        monitorDownloads(downloadIds)&#10;        &#10;        // Cancel all downloads after some time&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            delay(30_000)&#10;            firmwareManager.cancelAllDownloads()&#10;            println(&quot;All downloads cancelled&quot;)&#10;        }&#10;    }&#10;    &#10;    private fun monitorDownloads(downloadIds: List&lt;Long&gt;) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            while (downloadIds.any { firmwareManager.isDownloadActive(it) }) {&#10;                downloadIds.forEach { downloadId -&gt;&#10;                    val state = firmwareManager.getDownloadState(downloadId)&#10;                    val progress = firmwareManager.getDownloadProgress(downloadId)&#10;                    val isActive = firmwareManager.isDownloadActive(downloadId)&#10;                    &#10;                    println(&quot;Download $downloadId - State: $state, Progress: $progress bytes, Active: $isActive&quot;)&#10;                }&#10;                &#10;                println(&quot;Active downloads: ${firmwareManager.getActiveDownloadCount()}&quot;)&#10;                println(&quot;---&quot;)&#10;                &#10;                delay(2_000) // Check every 2 seconds&#10;            }&#10;            &#10;            println(&quot;All downloads completed or stopped&quot;)&#10;        }&#10;    }&#10;    &#10;    fun demonstrateCustomDownloadListener() {&#10;        class CustomDownloadListener(private val downloadName: String) : DownloadListener {&#10;            private var lastProgressTime = System.currentTimeMillis()&#10;            &#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                val currentTime = System.currentTimeMillis()&#10;                if (currentTime - lastProgressTime &gt;= 1000) { // Throttle updates to once per second&#10;                    println(&quot;[$downloadName] Progress: $percentage% - ${formatBytes(downloaded)}/${formatBytes(total)}&quot;)&#10;                    lastProgressTime = currentTime&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    println(&quot;[$downloadName] ✅ Download completed: $filePath&quot;)&#10;                } else {&#10;                    println(&quot;[$downloadName] ❌ Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;[$downloadName] ⚠️ Error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                val emoji = when (state) {&#10;                    DownloadState.CONNECTING -&gt; &quot;&quot;&#10;                    DownloadState.DOWNLOADING -&gt; &quot;⬇️&quot;&#10;                    DownloadState.PAUSED -&gt; &quot;⏸️&quot;&#10;                    DownloadState.COMPLETED -&gt; &quot;✅&quot;&#10;                    DownloadState.CANCELLED -&gt; &quot;❌&quot;&#10;                    DownloadState.FAILED -&gt; &quot;⚠️&quot;&#10;                    else -&gt; &quot;&quot;&#10;                }&#10;                println(&quot;[$downloadName] $emoji State changed to: $state&quot;)&#10;            }&#10;            &#10;            private fun formatBytes(bytes: Long): String {&#10;                return when {&#10;                    bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;                    bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;                    else -&gt; &quot;$bytes B&quot;&#10;                }&#10;            }&#10;        }&#10;        &#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        val customListener = CustomDownloadListener(&quot;Firmware Update&quot;)&#10;        &#10;        val request = DownloadRequest.Builder()&#10;            .url(&quot;https://example.com/large-firmware.bin&quot;)&#10;            .downloadId(System.currentTimeMillis())&#10;            .fileName(&quot;large-firmware.bin&quot;)&#10;            .build()&#10;            &#10;        val outputFile = File(&quot;/path/to/large-firmware.bin&quot;)&#10;        firmwareManager.startDownload(request, outputFile, customListener)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadInterfaces.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadInterfaces.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;/**&#10; * Interface for download progress and state callbacks&#10; */&#10;interface DownloadListener {&#10;    fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int)&#10;    fun onDownloadComplete(success: Boolean, filePath: String?)&#10;    fun onDownloadError(error: String)&#10;    fun onDownloadStateChanged(state: DownloadState)&#10;}&#10;&#10;/**&#10; * Interface for download operations&#10; */&#10;interface DownloadController {&#10;    suspend fun startDownload()&#10;    fun pauseDownload()&#10;    fun resumeDownload() &#10;    fun cancelDownload()&#10;    fun getDownloadState(): DownloadState&#10;}&#10;&#10;/**&#10; * Enum representing download states&#10; */&#10;enum class DownloadState {&#10;    IDLE,&#10;    CONNECTING,&#10;    DOWNLOADING,&#10;    PAUSED,&#10;    COMPLETED,&#10;    CANCELLED,&#10;    FAILED&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadProgressCallback.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadProgressCallback.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;/**&#10; * Interface để MainActivity nhận updates từ DownloadingManager&#10; * Đặc biệt quan trọng cho network reconnection auto-resume&#10; */&#10;interface DownloadProgressCallback {&#10;    fun onProgressUpdate(downloadId: String, downloaded: Long, total: Long, speed: String)&#10;    fun onDownloadStateChanged(downloadId: String, state: Int)&#10;    fun onNetworkReconnected(downloadId: String)&#10;    fun onNetworkLost(downloadId: String)&#10;    fun onDownloadCompleted(downloadId: String, success: Boolean, filePath: String?)&#10;    fun onDownloadError(downloadId: String, error: String)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadProgressTracker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadProgressTracker.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;/**&#10; * Handles progress tracking and calculations for downloads&#10; */&#10;class DownloadProgressTracker(&#10;    private val totalSize: Long,&#10;    private var downloadedBytes: Long = 0L,&#10;    private val listener: DownloadListener?&#10;) {&#10;    &#10;    fun updateProgress(bytesRead: Int) {&#10;        downloadedBytes += bytesRead&#10;        notifyProgress()&#10;    }&#10;    &#10;    private fun notifyProgress() {&#10;        val percentage = calculatePercentage()&#10;        listener?.onProgressUpdate(downloadedBytes, totalSize, percentage)&#10;    }&#10;    &#10;    private fun calculatePercentage(): Int {&#10;        return if (totalSize &gt; 0) {&#10;            ((downloadedBytes * 100) / totalSize).toInt()&#10;        } else {&#10;            0&#10;        }&#10;    }&#10;    &#10;    fun getCurrentProgress(): Long = downloadedBytes&#10;    &#10;    fun isCompleted(): Boolean = totalSize &gt; 0 &amp;&amp; downloadedBytes &gt;= totalSize&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadStateManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadStateManager.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import kotlinx.coroutines.delay&#10;&#10;/**&#10; * Manages download state and control flow&#10; */&#10;class DownloadStateManager(private val listener: DownloadListener?) {&#10;    @Volatile&#10;    private var currentState: DownloadState = DownloadState.IDLE&#10;    &#10;    fun setState(newState: DownloadState) {&#10;        if (currentState != newState) {&#10;            currentState = newState&#10;            listener?.onDownloadStateChanged(newState)&#10;        }&#10;    }&#10;    &#10;    fun getState(): DownloadState = currentState&#10;    &#10;    fun isPaused(): Boolean = currentState == DownloadState.PAUSED&#10;    &#10;    fun isCancelled(): Boolean = currentState == DownloadState.CANCELLED&#10;    &#10;    fun isActive(): Boolean = currentState in listOf(&#10;        DownloadState.CONNECTING, &#10;        DownloadState.DOWNLOADING&#10;    )&#10;    &#10;    fun pause() {&#10;        if (isActive()) {&#10;            setState(DownloadState.PAUSED)&#10;        }&#10;    }&#10;    &#10;    fun resume() {&#10;        if (isPaused()) {&#10;            setState(DownloadState.DOWNLOADING)&#10;        }&#10;    }&#10;    &#10;    fun cancel() {&#10;        setState(DownloadState.CANCELLED)&#10;    }&#10;    &#10;    suspend fun waitWhilePaused() {&#10;        while (isPaused() &amp;&amp; !isCancelled()) {&#10;            delay(DownloadConstants.PAUSE_CHECK_DELAY_MILLIS)&#10;        }&#10;    }&#10;    &#10;    fun checkCancellation() {&#10;        if (isCancelled()) {&#10;            throw DownloadCancelledException(&quot;Download was cancelled&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Custom exception for cancelled downloads&#10; */&#10;class DownloadCancelledException(message: String) : Exception(message)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadTask.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadTask.kt" />
              <option name="originalContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.net.URLConnection&#10;import java.util.Locale&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Clean implementation of download task with proper separation of concerns&#10; * Follows SOLID principles and clean code guidelines&#10; */&#10;class DownloadTask(&#10;    private val request: DownloadRequest,&#10;    private val outputUri : Uri,&#10;    private val listener: DownloadListener? = null&#10;) : DownloadController {&#10;&#10;    private val connectionManager = HttpConnectionManager(request)&#10;    private val stateManager = DownloadStateManager(listener)&#10;    private var downloadJob: Job? = null&#10;    private var progressTracker: DownloadProgressTracker? = null&#10;&#10;    override suspend fun startDownload() = withContext(Dispatchers.IO) {&#10;        if (stateManager.isActive()) return@withContext&#10;&#10;        downloadJob = launch {&#10;            try {&#10;                executeDownload()&#10;            } catch (e: DownloadCancelledException) {&#10;                handleDownloadCancellation()&#10;            } catch (e: Exception) {&#10;                handleDownloadError(e)&#10;            } finally {&#10;                cleanup()&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun executeDownload() {&#10;        stateManager.setState(DownloadState.CONNECTING)&#10;        establishConnection()&#10;&#10;        stateManager.setState(DownloadState.DOWNLOADING)&#10;        performFileDownload()&#10;&#10;        stateManager.setState(DownloadState.COMPLETED)&#10;        notifyDownloadComplete()&#10;    }&#10;&#10;    private fun establishConnection() {&#10;        connectionManager.connect()&#10;&#10;        if (!connectionManager.isValidResponse()) {&#10;            throw IOException(&quot;Invalid HTTP response: ${connectionManager.getResponseCode()}&quot;)&#10;        }&#10;&#10;        val totalSize = connectionManager.getContentLength()&#10;        progressTracker = DownloadProgressTracker(&#10;            totalSize = totalSize,&#10;            downloadedBytes = request.downloadedBytes,&#10;            listener = listener&#10;        )&#10;    }&#10;&#10;    private suspend fun performFileDownload() {&#10;        connectionManager.getInputStream()?.use { inputStream -&gt;&#10;            FileManager.getInstance().writeToFile(outputUri = outputUri, shouldAppend = {shouldAppend()}){&#10;                downloadDataStream(inputStream, it)&#10;            }&#10;        } ?: throw IOException(&quot;Unable to get input stream&quot;)&#10;    }&#10;&#10;    private fun shouldAppend(): Boolean = request.downloadedBytes &gt; 0&#10;&#10;    private suspend fun downloadDataStream(&#10;        inputStream: java.io.InputStream,&#10;        outputStream: FileOutputStream&#10;    ) {&#10;        val buffer = ByteArray(DownloadConstants.DEFAULT_BUFFER_SIZE)&#10;        var bytesRead: Int&#10;&#10;        while (inputStream.read(buffer).also { bytesRead = it } != -1) {&#10;            stateManager.checkCancellation()&#10;            stateManager.waitWhilePaused()&#10;&#10;            writeBufferToFile(outputStream, buffer, bytesRead)&#10;            progressTracker?.updateProgress(bytesRead)&#10;&#10;            yield() // Allow other coroutines to run&#10;        }&#10;    }&#10;&#10;    private fun writeBufferToFile(&#10;        context: Context,&#10;        contentUri: Uri,&#10;        buffer: ByteArray,&#10;        bytesRead: Int&#10;    ) {&#10;        context.contentResolver.openOutputStream(contentUri)?.use { outputStream -&gt;&#10;            outputStream.write(buffer, 0, bytesRead)&#10;            outputStream.flush()&#10;        } ?: run {&#10;            Log.e(&quot;WriteFile&quot;, &quot;Failed to open output stream for URI: $contentUri&quot;)&#10;        }&#10;    }&#10;    private fun handleDownloadCancellation() {&#10;        stateManager.setState(DownloadState.CANCELLED)&#10;        listener?.onDownloadError(&quot;Download was cancelled&quot;)&#10;    }&#10;&#10;    private fun handleDownloadError(exception: Exception) {&#10;        stateManager.setState(DownloadState.FAILED)&#10;        val errorMessage = &quot;Download failed: ${exception.message}&quot;&#10;        listener?.onDownloadError(errorMessage)&#10;    }&#10;&#10;    private fun notifyDownloadComplete() {&#10;        listener?.onDownloadComplete(true, outputFile.absolutePath)&#10;    }&#10;&#10;    override fun pauseDownload() {&#10;        stateManager.pause()&#10;    }&#10;&#10;    override fun resumeDownload() {&#10;        stateManager.resume()&#10;    }&#10;&#10;    override fun cancelDownload() {&#10;        stateManager.cancel()&#10;        downloadJob?.cancel()&#10;    }&#10;&#10;    override fun getDownloadState(): DownloadState = stateManager.getState()&#10;&#10;    fun getCurrentProgress(): Long = progressTracker?.getCurrentProgress() ?: 0L&#10;&#10;    fun isActive(): Boolean = stateManager.isActive()&#10;&#10;    private fun cleanup() {&#10;        connectionManager.disconnect()&#10;        downloadJob = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import java.io.IOException&#10;import java.io.OutputStream&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Clean implementation of download task with ContentProvider support for Android 14+&#10; * Uses MediaStore API for proper scoped storage access&#10; */&#10;class DownloadTask(&#10;    private val context: Context,&#10;    private val request: DownloadRequest,&#10;    private val fileName: String,&#10;    private val listener: DownloadListener? = null&#10;) : DownloadController {&#10;&#10;    private val connectionManager = HttpConnectionManager(request)&#10;    private val stateManager = DownloadStateManager(listener)&#10;    private val fileStorageManager = FileStorageManager(context)&#10;&#10;    private var downloadJob: Job? = null&#10;    private var progressTracker: DownloadProgressTracker? = null&#10;    private var outputFileUri: Uri? = null&#10;&#10;    override suspend fun startDownload() = withContext(Dispatchers.IO) {&#10;        if (stateManager.isActive()) return@withContext&#10;&#10;        downloadJob = launch {&#10;            try {&#10;                executeDownload()&#10;            } catch (e: DownloadCancelledException) {&#10;                handleDownloadCancellation()&#10;            } catch (e: Exception) {&#10;                handleDownloadError(e)&#10;            } finally {&#10;                cleanup()&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun executeDownload() {&#10;        stateManager.setState(DownloadState.CONNECTING)&#10;&#10;        // Create or get existing file Uri&#10;        outputFileUri = createOrGetExistingFile()&#10;&#10;        establishConnection()&#10;&#10;        stateManager.setState(DownloadState.DOWNLOADING)&#10;        performFileDownload()&#10;&#10;        // Mark file as completed&#10;        outputFileUri?.let { uri -&gt;&#10;            fileStorageManager.markFileAsCompleted(uri)&#10;        }&#10;&#10;        stateManager.setState(DownloadState.COMPLETED)&#10;        notifyDownloadComplete()&#10;    }&#10;&#10;    private fun createOrGetExistingFile(): Uri {&#10;        return fileStorageManager.createDownloadFile(fileName, &quot;application/octet-stream&quot;)&#10;            ?: throw IOException(&quot;Unable to create download file&quot;)&#10;    }&#10;&#10;    private fun establishConnection() {&#10;        connectionManager.connect()&#10;&#10;        if (!connectionManager.isValidResponse()) {&#10;            throw IOException(&quot;Invalid HTTP response: ${connectionManager.getResponseCode()}&quot;)&#10;        }&#10;&#10;        val totalSize = connectionManager.getContentLength()&#10;        val existingSize = outputFileUri?.let { fileStorageManager.getFileSize(it) } ?: 0L&#10;&#10;        progressTracker = DownloadProgressTracker(&#10;            totalSize = totalSize,&#10;            downloadedBytes = existingSize,&#10;            listener = listener&#10;        )&#10;    }&#10;&#10;    private suspend fun performFileDownload() {&#10;        val uri = outputFileUri ?: throw IOException(&quot;Output file URI is null&quot;)&#10;&#10;        connectionManager.getInputStream()?.use { inputStream -&gt;&#10;            openOutputStreamForUri(uri).use { outputStream -&gt;&#10;                downloadDataStream(inputStream, outputStream)&#10;            }&#10;        } ?: throw IOException(&quot;Unable to get input stream&quot;)&#10;    }&#10;&#10;    private fun openOutputStreamForUri(uri: Uri): OutputStream {&#10;        val shouldAppend = request.downloadedBytes &gt; 0&#10;        return if (shouldAppend) {&#10;            fileStorageManager.openOutputStreamForAppend(uri)&#10;        } else {&#10;            fileStorageManager.openOutputStream(uri)&#10;        } ?: throw IOException(&quot;Unable to open output stream for URI: $uri&quot;)&#10;    }&#10;&#10;    private suspend fun downloadDataStream(&#10;        inputStream: java.io.InputStream,&#10;        outputStream: OutputStream&#10;    ) {&#10;        val buffer = ByteArray(DownloadConstants.DEFAULT_BUFFER_SIZE)&#10;        var bytesRead: Int&#10;&#10;        while (inputStream.read(buffer).also { bytesRead = it } != -1) {&#10;            stateManager.checkCancellation()&#10;            stateManager.waitWhilePaused()&#10;&#10;            writeBufferToOutputStream(outputStream, buffer, bytesRead)&#10;            progressTracker?.updateProgress(bytesRead)&#10;&#10;            yield() // Allow other coroutines to run&#10;        }&#10;    }&#10;&#10;    private fun writeBufferToOutputStream(&#10;        outputStream: OutputStream,&#10;        buffer: ByteArray,&#10;        bytesRead: Int&#10;    ) {&#10;        outputStream.write(buffer, 0, bytesRead)&#10;        outputStream.flush() // Ensure data is written immediately&#10;    }&#10;&#10;    private fun handleDownloadCancellation() {&#10;        stateManager.setState(DownloadState.CANCELLED)&#10;        // Delete the incomplete file&#10;        outputFileUri?.let { uri -&gt;&#10;            fileStorageManager.deleteFile(uri)&#10;        }&#10;        listener?.onDownloadError(&quot;Download was cancelled&quot;)&#10;    }&#10;&#10;    private fun handleDownloadError(exception: Exception) {&#10;        stateManager.setState(DownloadState.FAILED)&#10;        // Delete the incomplete file&#10;        outputFileUri?.let { uri -&gt;&#10;            fileStorageManager.deleteFile(uri)&#10;        }&#10;        val errorMessage = &quot;Download failed: ${exception.message}&quot;&#10;        listener?.onDownloadError(errorMessage)&#10;    }&#10;&#10;    private fun notifyDownloadComplete() {&#10;        val filePath = outputFileUri?.toString() ?: &quot;Unknown location&quot;&#10;        listener?.onDownloadComplete(true, filePath)&#10;    }&#10;&#10;    override fun pauseDownload() {&#10;        stateManager.pause()&#10;    }&#10;&#10;    override fun resumeDownload() {&#10;        stateManager.resume()&#10;    }&#10;&#10;    override fun cancelDownload() {&#10;        stateManager.cancel()&#10;        downloadJob?.cancel()&#10;    }&#10;&#10;    override fun getDownloadState(): DownloadState = stateManager.getState()&#10;&#10;    fun getCurrentProgress(): Long = progressTracker?.getCurrentProgress() ?: 0L&#10;&#10;    fun isActive(): Boolean = stateManager.isActive()&#10;&#10;    fun getOutputFileUri(): Uri? = outputFileUri&#10;&#10;    private fun cleanup() {&#10;        connectionManager.disconnect()&#10;        downloadJob = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadingManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadingManager.kt" />
              <option name="originalContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.Context&#10;import android.os.Environment&#10;import android.util.Log&#10;import android.webkit.URLUtil&#10;import androidx.core.content.ContextCompat&#10;import com.marusys.upgradefirmware.database.DownloadDatabase&#10;import com.marusys.upgradefirmware.database.DownloadEntity&#10;import com.marusys.upgradefirmware.network.NetworkStateReceiver&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.awaitAll&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.io.FileInputStream&#10;import java.math.BigInteger&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.security.MessageDigest&#10;import java.util.UUID&#10;&#10;class DownloadingManager(val context: Context) : NetworkStateReceiver.NetworkStateListener {&#10;&#10;    val TAG = &quot;DownloadingManager&quot;&#10;    private var connection: HttpURLConnection? = null&#10;    private var url: String = &quot;&quot;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;    private var downloadedBytes: Long = 0L&#10;    private var currentDownloadId: String? = null&#10;    private var isDownloading = false&#10;&#10;    // Database&#10;    private val database = DownloadDatabase.getDatabase(context)&#10;    private val downloadDao = database.downloadDao()&#10;&#10;    companion object {&#10;        private var downloadingManager: DownloadingManager? = null&#10;&#10;        // Constants for download optimization&#10;        private const val BUFFER_SIZE = 64 * 1024 // 64KB buffer for faster download&#10;        private const val CONNECT_TIMEOUT = 15000 // 15 seconds&#10;        private const val READ_TIMEOUT = 30000 // 30 seconds&#10;        private const val MAX_PARALLEL_CONNECTIONS = 4 // For parallel downloading&#10;        private const val CHUNK_SIZE = 1024 * 1024 // 1MB chunks for parallel download&#10;&#10;        fun create(context: Context) {&#10;            downloadingManager = DownloadingManager(context)&#10;        }&#10;&#10;        fun getInstance(): DownloadingManager {&#10;            return downloadingManager!!&#10;        }&#10;&#10;        fun getPath(dirPath: String?, fileName: String?): String {&#10;            return dirPath + File.separator + fileName&#10;        }&#10;&#10;        fun getTempPath(dirPath: String?, fileName: String?): String {&#10;            return getPath(dirPath, fileName) + &quot;.temp&quot;&#10;        }&#10;    }&#10;&#10;    init {&#10;        // Đăng ký network listener&#10;        NetworkStateReceiver.addListener(this)&#10;&#10;        // Resume downloads khi khởi tạo&#10;        resumeIncompleteDownloads()&#10;    }&#10;&#10;    fun getRootDirPath(context: Context): String {&#10;        if (Environment.MEDIA_MOUNTED == Environment.getExternalStorageState()) {&#10;            val file = ContextCompat.getExternalFilesDirs(&#10;                context.getApplicationContext(),&#10;                null&#10;            )[0]&#10;            return file.getAbsolutePath()&#10;        } else {&#10;            return context.getApplicationContext().getFilesDir().getAbsolutePath()&#10;        }&#10;    }&#10;    /**&#10;     * Start download với database persistence&#10;     */&#10;    fun startDownloading(url: String, expectedMD5: String? = null) {&#10;        scope.launch {&#10;            try {&#10;                val downloadId = UUID.randomUUID().toString()&#10;                currentDownloadId = downloadId&#10;&#10;                val dirPath = getRootDirPath(context)&#10;                val fileName = URLUtil.guessFileName(url, null, null)&#10;                val tempPath = getTempPath(dirPath, fileName)&#10;                val finalPath = getPath(dirPath, fileName)&#10;&#10;                // Lưu vào database&#10;                val downloadEntity = DownloadEntity(&#10;                    downloadId = downloadId,&#10;                    url = url,&#10;                    fileName = fileName,&#10;                    filePath = finalPath,&#10;                    tempPath = tempPath,&#10;                    downloadedBytes = 0L,&#10;                    totalBytes = 0L,&#10;                    status = DownloadEntity.STATUS_PENDING,&#10;                    expectedMD5 = expectedMD5&#10;                )&#10;&#10;                downloadDao.insertDownload(downloadEntity)&#10;                Log.d(TAG, &quot;Saved download to database: $fileName&quot;)&#10;&#10;                // Bắt đầu download&#10;                performDownload(downloadEntity)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error starting download: ${e.message}&quot;)&#10;                currentDownloadId?.let { id -&gt;&#10;                    updateDownloadStatus(id, DownloadEntity.STATUS_FAILED, e.message)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resume downloads chưa hoàn thành khi app khởi động&#10;     */&#10;    private fun resumeIncompleteDownloads() {&#10;        scope.launch {&#10;            try {&#10;                val incompleteDownloads = downloadDao.getIncompleteDownloads()&#10;                Log.d(TAG, &quot;Found ${incompleteDownloads.size} incomplete downloads to resume&quot;)&#10;&#10;                incompleteDownloads.forEach { download -&gt;&#10;                    // Kiểm tra file tồn tại và validate&#10;                    val tempFile = File(download.tempPath)&#10;                    if (tempFile.exists()) {&#10;                        val actualSize = tempFile.length()&#10;                        if (actualSize != download.downloadedBytes) {&#10;                            // Cập nhật downloaded bytes theo kích thước file thật&#10;                            downloadDao.updateProgress(download.downloadId, actualSize)&#10;                            Log.d(TAG, &quot;Updated progress for ${download.fileName}: $actualSize bytes&quot;)&#10;                        }&#10;                    }&#10;&#10;                    // Set status về paused để user có thể resume&#10;                    downloadDao.updateStatus(download.downloadId, DownloadEntity.STATUS_PAUSED)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error resuming incomplete downloads: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resume download cụ thể&#10;     */&#10;    fun resumeDownload(downloadId: String) {&#10;        scope.launch {&#10;            try {&#10;                val download = downloadDao.getDownloadById(downloadId)&#10;                if (download != null &amp;&amp; !isDownloading) {&#10;                    Log.d(TAG, &quot;Resuming download: ${download.fileName}&quot;)&#10;                    currentDownloadId = downloadId&#10;                    performDownload(download)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error resuming download: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thực hiện download chính với tối ưu hóa tốc độ&#10;     */&#10;    private suspend fun performDownload(downloadEntity: DownloadEntity) = withContext(Dispatchers.IO) {&#10;        try {&#10;            isDownloading = true&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_DOWNLOADING)&#10;&#10;            val tempFile = File(downloadEntity.tempPath)&#10;            downloadedBytes = if (tempFile.exists()) tempFile.length() else 0L&#10;&#10;            // Cập nhật downloaded bytes trong database&#10;            if (downloadedBytes &gt; 0) {&#10;                downloadDao.updateProgress(downloadEntity.downloadId, downloadedBytes)&#10;            }&#10;&#10;            Log.d(TAG, &quot;Starting optimized download from byte: $downloadedBytes for ${downloadEntity.fileName}&quot;)&#10;&#10;            connection = createOptimizedConnection(downloadEntity.url, downloadedBytes)&#10;&#10;            Log.d(TAG, &quot;performDownload: ====&gt; connecting with optimizations&quot;)&#10;            connection?.connect()&#10;&#10;            // Kiểm tra response code&#10;            val responseCode = connection?.responseCode ?: 0&#10;            Log.d(TAG, &quot;HTTP Response Code: $responseCode&quot;)&#10;&#10;            if (responseCode !in 200..299 &amp;&amp; responseCode != 206) {&#10;                throw Exception(&quot;HTTP Error: $responseCode - ${connection?.responseMessage}&quot;)&#10;            }&#10;&#10;            val contentLength = connection?.contentLengthLong ?: 0L&#10;            val totalBytes = contentLength + downloadedBytes&#10;            downloadDao.updateTotalBytes(downloadEntity.downloadId, totalBytes)&#10;&#10;            val inputStream = connection?.inputStream&#10;&#10;            // Sử dụng BufferedInputStream cho tốc độ cao hơn&#10;            val bufferedInputStream = java.io.BufferedInputStream(inputStream, BUFFER_SIZE)&#10;&#10;            // Tạo file và folder nếu chưa có&#10;            if (!tempFile.exists()) {&#10;                tempFile.parentFile?.mkdirs()&#10;                tempFile.createNewFile()&#10;            }&#10;&#10;            val outputStream = FileDownloadRandomAccessFile.create(tempFile)&#10;            if (downloadedBytes != 0L) {&#10;                outputStream.seek(downloadedBytes)&#10;            }&#10;&#10;            // Sử dụng buffer lớn hơn cho tốc độ cao&#10;            val buff = ByteArray(BUFFER_SIZE)&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var bytesReadInSecond = 0L&#10;            var lastSpeedUpdate = System.currentTimeMillis()&#10;&#10;            do {&#10;                try {&#10;                    val byteCount: Int = bufferedInputStream.read(buff, 0, BUFFER_SIZE)&#10;                    if (byteCount == -1) {&#10;                        break&#10;                    }&#10;&#10;                    outputStream.write(buff, 0, byteCount)&#10;                    downloadedBytes += byteCount&#10;                    bytesReadInSecond += byteCount&#10;&#10;                    // Cập nhật database và tính tốc độ mỗi giây&#10;                    val currentTime = System.currentTimeMillis()&#10;                    if (currentTime - lastUpdateTime &gt; 1000) {&#10;                        downloadDao.updateProgress(downloadEntity.downloadId, downloadedBytes)&#10;&#10;                        // Tính tốc độ download&#10;                        val speed = bytesReadInSecond / ((currentTime - lastSpeedUpdate) / 1000.0)&#10;                        Log.d(TAG, &quot;Progress: ${downloadEntity.fileName} - $downloadedBytes/$totalBytes bytes - Speed: ${formatSpeed(speed)}&quot;)&#10;&#10;                        lastUpdateTime = currentTime&#10;                        lastSpeedUpdate = currentTime&#10;                        bytesReadInSecond = 0L&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Download error: ${e.message}&quot;)&#10;                    downloadDao.updateError(downloadEntity.downloadId, e.message)&#10;                    throw e&#10;                }&#10;&#10;            } while (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId)&#10;&#10;            outputStream.close()&#10;            bufferedInputStream.close()&#10;            connection?.disconnect()&#10;&#10;            if (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId) {&#10;                // Download hoàn thành&#10;                val finalPath = downloadEntity.filePath&#10;                Utils.renameFileName(downloadEntity.tempPath, finalPath)&#10;&#10;                downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_COMPLETED)&#10;                Log.d(TAG, &quot;Download completed: ${downloadEntity.fileName}&quot;)&#10;&#10;                // Verify MD5 nếu có&#10;                downloadEntity.expectedMD5?.let { expectedMD5 -&gt;&#10;                    verifyDownloadIntegrity(finalPath, expectedMD5) { isValid -&gt;&#10;                        scope.launch {&#10;                            if (isValid) {&#10;                                Log.d(TAG, &quot;✅ ${downloadEntity.fileName} - MD5 verification successful&quot;)&#10;                            } else {&#10;                                Log.e(TAG, &quot;❌ ${downloadEntity.fileName} - MD5 verification failed&quot;)&#10;                                downloadDao.updateError(downloadEntity.downloadId, &quot;MD5 verification failed&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Download failed: ${e.message}&quot;)&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_FAILED)&#10;            downloadDao.updateError(downloadEntity.downloadId, e.message)&#10;        } finally {&#10;            isDownloading = false&#10;            currentDownloadId = null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo connection được tối ưu hóa cho tốc độ download cao&#10;     */&#10;    private fun createOptimizedConnection(url: String, startByte: Long): HttpURLConnection {&#10;        val connection = URL(url).openConnection() as HttpURLConnection&#10;&#10;        // Timeout tối ưu&#10;        connection.connectTimeout = CONNECT_TIMEOUT&#10;        connection.readTimeout = READ_TIMEOUT&#10;&#10;        // Headers để tối ưu tốc độ&#10;        connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android) DownloadManager/2.0&quot;)&#10;        connection.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;        connection.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;identity&quot;) // Không nén để tăng tốc&#10;        connection.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;)&#10;        connection.setRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;)&#10;&#10;        // Thêm Range header nếu resume&#10;        if (startByte &gt; 0) {&#10;            connection.setRequestProperty(&quot;Range&quot;, &quot;bytes=$startByte-&quot;)&#10;            Log.d(TAG, &quot;Resume download from byte: $startByte&quot;)&#10;        }&#10;&#10;        // Tối ưu HTTP settings&#10;        connection.instanceFollowRedirects = true&#10;        connection.useCaches = false&#10;        connection.doInput = true&#10;&#10;        // Thêm headers để server biết client hỗ trợ range requests&#10;        connection.setRequestProperty(&quot;Accept-Ranges&quot;, &quot;bytes&quot;)&#10;&#10;        Log.d(TAG, &quot;Created optimized connection with ${BUFFER_SIZE/1024}KB buffer&quot;)&#10;        return connection&#10;    }&#10;&#10;    /**&#10;     * Format tốc độ download để hiển thị&#10;     */&#10;    private fun formatSpeed(bytesPerSecond: Double): String {&#10;        return when {&#10;            bytesPerSecond &gt;= 1024 * 1024 -&gt; &quot;%.1f MB/s&quot;.format(bytesPerSecond / (1024 * 1024))&#10;            bytesPerSecond &gt;= 1024 -&gt; &quot;%.1f KB/s&quot;.format(bytesPerSecond / 1024)&#10;            else -&gt; &quot;%.0f B/s&quot;.format(bytesPerSecond)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pause download hiện tại&#10;     */&#10;    fun pauseDownload() {&#10;        isDownloading = false&#10;        currentDownloadId?.let { id -&gt;&#10;            scope.launch {&#10;                updateDownloadStatus(id, DownloadEntity.STATUS_PAUSED)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Download paused&quot;)&#10;    }&#10;&#10;    /**&#10;     * Cancel download hiện tại&#10;     */&#10;    fun cancelDownload() {&#10;        isDownloading = false&#10;        currentDownloadId?.let { id -&gt;&#10;            scope.launch {&#10;                updateDownloadStatus(id, DownloadEntity.STATUS_CANCELLED)&#10;                // Xóa temp file&#10;                val download = downloadDao.getDownloadById(id)&#10;                download?.let {&#10;                    File(it.tempPath).delete()&#10;                }&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Download cancelled&quot;)&#10;    }&#10;&#10;    // NetworkStateReceiver.NetworkStateListener implementation&#10;    override fun onNetworkAvailable() {&#10;        Log.d(TAG, &quot;Network available - resuming paused downloads&quot;)&#10;        scope.launch {&#10;            val pausedDownloads = downloadDao.getIncompleteDownloads()&#10;                .filter { it.status == DownloadEntity.STATUS_PAUSED }&#10;&#10;            if (pausedDownloads.isNotEmpty() &amp;&amp; !isDownloading) {&#10;                // Resume download đầu tiên&#10;                val download = pausedDownloads.first()&#10;                resumeDownload(download.downloadId)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onNetworkLost() {&#10;        Log.d(TAG, &quot;Network lost - pausing current download&quot;)&#10;        if (isDownloading) {&#10;            pauseDownload()&#10;        }&#10;    }&#10;&#10;    private suspend fun updateDownloadStatus(downloadId: String, status: Int, error: String? = null) {&#10;        downloadDao.updateStatus(downloadId, status)&#10;        error?.let { downloadDao.updateError(downloadId, it) }&#10;    }&#10;&#10;    fun cleanup() {&#10;        NetworkStateReceiver.removeListener(this)&#10;        isDownloading = false&#10;        connection?.disconnect()&#10;    }&#10;&#10;    /**&#10;     * Tính MD5 checksum của file&#10;     * @param file File cần tính checksum&#10;     * @return String MD5 hash hoặc null nếu có lỗi&#10;     */&#10;    fun calculateMD5(file: File): String? {&#10;        return try {&#10;            val md5 = MessageDigest.getInstance(&quot;MD5&quot;)&#10;            FileInputStream(file).use { fis -&gt;&#10;                val buffer = ByteArray(8192)&#10;                var bytesRead: Int&#10;                while (fis.read(buffer).also { bytesRead = it } != -1) {&#10;                    md5.update(buffer, 0, bytesRead)&#10;                }&#10;            }&#10;            val digest = md5.digest()&#10;            val bigInteger = BigInteger(1, digest)&#10;            bigInteger.toString(16).padStart(32, '0')&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error calculating MD5: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tính MD5 checksum của file theo đường dẫn&#10;     * @param filePath Đường dẫn đến file&#10;     * @return String MD5 hash hoặc null nếu có lỗi&#10;     */&#10;    fun calculateMD5(filePath: String): String? {&#10;        val file = File(filePath)&#10;        return if (file.exists() &amp;&amp; file.isFile) {&#10;            calculateMD5(file)&#10;        } else {&#10;            Log.e(TAG, &quot;File not found: $filePath&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * So sánh MD5 checksum của file với hash mong đợi&#10;     * @param file File cần kiểm tra&#10;     * @param expectedHash MD5 hash mong đợi&#10;     * @return true nếu khớp, false nếu không khớp&#10;     */&#10;    fun verifyMD5(file: File, expectedHash: String): Boolean {&#10;        val actualHash = calculateMD5(file)&#10;        return if (actualHash != null) {&#10;            val isValid = actualHash.equals(expectedHash, ignoreCase = true)&#10;            Log.d(TAG, &quot;MD5 Verification - Expected: $expectedHash, Actual: $actualHash, Valid: $isValid&quot;)&#10;            isValid&#10;        } else {&#10;            Log.e(TAG, &quot;Cannot calculate MD5 for verification&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * So sánh MD5 checksum của file theo đường dẫn với hash mong đợi&#10;     * @param filePath Đường dẫn đến file&#10;     * @param expectedHash MD5 hash mong đợi&#10;     * @return true nếu khớp, false nếu không khớp&#10;     */&#10;    fun verifyMD5(filePath: String, expectedHash: String): Boolean {&#10;        val file = File(filePath)&#10;        return if (file.exists() &amp;&amp; file.isFile) {&#10;            verifyMD5(file, expectedHash)&#10;        } else {&#10;            Log.e(TAG, &quot;File not found for MD5 verification: $filePath&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính toàn vẹn file sau khi download hoàn thành&#10;     * @param filePath Đường dẫn file đã download&#10;     * @param expectedMD5 MD5 hash mong đợi&#10;     * @param onResult Callback trả về kết quả (true/false)&#10;     */&#10;    fun verifyDownloadIntegrity(filePath: String, expectedMD5: String, onResult: (Boolean) -&gt; Unit) {&#10;        scope.launch {&#10;            val isValid = verifyMD5(filePath, expectedMD5)&#10;            withContext(Dispatchers.Main) {&#10;                onResult(isValid)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start parallel download để tăng tốc độ&#10;     */&#10;    fun startParallelDownloading(url: String, expectedMD5: String? = null, numConnections: Int = MAX_PARALLEL_CONNECTIONS) {&#10;        scope.launch {&#10;            try {&#10;                val downloadId = UUID.randomUUID().toString()&#10;                currentDownloadId = downloadId&#10;&#10;                val dirPath = getRootDirPath(context)&#10;                val fileName = URLUtil.guessFileName(url, null, null)&#10;                val tempPath = getTempPath(dirPath, fileName)&#10;                val finalPath = getPath(dirPath, fileName)&#10;&#10;                // Kiểm tra xem server có hỗ tr��� range requests không&#10;                if (supportsRangeRequests(url)) {&#10;                    Log.d(TAG, &quot;Server supports range requests - using parallel download with $numConnections connections&quot;)&#10;&#10;                    val downloadEntity = DownloadEntity(&#10;                        downloadId = downloadId,&#10;                        url = url,&#10;                        fileName = fileName,&#10;                        filePath = finalPath,&#10;                        tempPath = tempPath,&#10;                        downloadedBytes = 0L,&#10;                        totalBytes = 0L,&#10;                        status = DownloadEntity.STATUS_PENDING,&#10;                        expectedMD5 = expectedMD5&#10;                    )&#10;&#10;                    downloadDao.insertDownload(downloadEntity)&#10;                    performParallelDownload(downloadEntity, numConnections)&#10;                } else {&#10;                    Log.d(TAG, &quot;Server doesn't support range requests - using single connection&quot;)&#10;                    startDownloading(url, expectedMD5)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error starting parallel download: ${e.message}&quot;)&#10;                currentDownloadId?.let { id -&gt;&#10;                    updateDownloadStatus(id, DownloadEntity.STATUS_FAILED, e.message)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra server có hỗ trợ range requests không&#10;     */&#10;    private suspend fun supportsRangeRequests(url: String): Boolean = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val connection = URL(url).openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;HEAD&quot;&#10;            connection.connect()&#10;&#10;            val acceptRanges = connection.getHeaderField(&quot;Accept-Ranges&quot;)&#10;            val supportsRanges = acceptRanges == &quot;bytes&quot; || connection.responseCode == 206&#10;&#10;            connection.disconnect()&#10;            Log.d(TAG, &quot;Range support check - Accept-Ranges: $acceptRanges, Supports: $supportsRanges&quot;)&#10;            supportsRanges&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Cannot check range support: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thực hiện parallel download&#10;     */&#10;    private suspend fun performParallelDownload(downloadEntity: DownloadEntity, numConnections: Int) = withContext(Dispatchers.IO) {&#10;        try {&#10;            isDownloading = true&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_DOWNLOADING)&#10;&#10;            // Lấy file size trước&#10;            val totalFileSize = getFileSize(downloadEntity.url)&#10;            if (totalFileSize &lt;= 0) {&#10;                throw Exception(&quot;Cannot determine file size for parallel download&quot;)&#10;            }&#10;&#10;            downloadDao.updateTotalBytes(downloadEntity.downloadId, totalFileSize)&#10;            Log.d(TAG, &quot;Starting parallel download - File size: ${formatBytes(totalFileSize)}, Connections: $numConnections&quot;)&#10;&#10;            val tempFile = File(downloadEntity.tempPath)&#10;            if (!tempFile.exists()) {&#10;                tempFile.parentFile?.mkdirs()&#10;                tempFile.createNewFile()&#10;            }&#10;&#10;            // Tạo file với size đầy đủ&#10;            val randomAccessFile = FileDownloadRandomAccessFile.create(tempFile)&#10;            randomAccessFile.setLength(totalFileSize)&#10;&#10;            // Chia file thành các chunk&#10;            val chunkSize = totalFileSize / numConnections&#10;            val downloadJobs = mutableListOf&lt;kotlinx.coroutines.Deferred&lt;Unit&gt;&gt;()&#10;&#10;            repeat(numConnections) { i -&gt;&#10;                val startByte = i * chunkSize&#10;                val endByte = if (i == numConnections - 1) totalFileSize - 1 else (i + 1) * chunkSize - 1&#10;&#10;                val job = async {&#10;                    downloadChunk(downloadEntity.url, startByte, endByte, tempFile, i)&#10;                }&#10;                downloadJobs.add(job)&#10;&#10;                Log.d(TAG, &quot;Chunk $i: ${formatBytes(startByte)} - ${formatBytes(endByte)}&quot;)&#10;            }&#10;&#10;            // Theo dõi tiến độ&#10;            val progressJob = async {&#10;                monitorParallelProgress(downloadEntity, totalFileSize, tempFile)&#10;            }&#10;&#10;            // Đợi tất cả chunks hoàn thành&#10;            downloadJobs.awaitAll()&#10;            progressJob.cancel()&#10;&#10;            randomAccessFile.close()&#10;&#10;            if (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId) {&#10;                // Download hoàn thành&#10;                Utils.renameFileName(downloadEntity.tempPath, downloadEntity.filePath)&#10;                downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_COMPLETED)&#10;                Log.d(TAG, &quot;Parallel download completed: ${downloadEntity.fileName}&quot;)&#10;&#10;                // Verify MD5&#10;                downloadEntity.expectedMD5?.let { expectedMD5 -&gt;&#10;                    verifyDownloadIntegrity(downloadEntity.filePath, expectedMD5) { isValid -&gt;&#10;                        scope.launch {&#10;                            if (isValid) {&#10;                                Log.d(TAG, &quot;✅ ${downloadEntity.fileName} - MD5 verification successful&quot;)&#10;                            } else {&#10;                                Log.e(TAG, &quot;❌ ${downloadEntity.fileName} - MD5 verification failed&quot;)&#10;                                downloadDao.updateError(downloadEntity.downloadId, &quot;MD5 verification failed&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Parallel download failed: ${e.message}&quot;)&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_FAILED)&#10;            downloadDao.updateError(downloadEntity.downloadId, e.message)&#10;        } finally {&#10;            isDownloading = false&#10;            currentDownloadId = null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download một chunk của file&#10;     */&#10;    private suspend fun downloadChunk(url: String, startByte: Long, endByte: Long, outputFile: File, chunkIndex: Int) = withContext(Dispatchers.IO) {&#10;        var retryCount = 0&#10;        val maxRetries = 3&#10;&#10;        while (retryCount &lt; maxRetries &amp;&amp; isDownloading) {&#10;            try {&#10;                val connection = URL(url).openConnection() as HttpURLConnection&#10;&#10;                // Cấu hình connection cho chunk&#10;                connection.connectTimeout = CONNECT_TIMEOUT&#10;                connection.readTimeout = READ_TIMEOUT&#10;                connection.setRequestProperty(&quot;Range&quot;, &quot;bytes=$startByte-$endByte&quot;)&#10;                connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android) ParallelDownloader/1.0&quot;)&#10;                connection.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;&#10;                connection.connect()&#10;&#10;                if (connection.responseCode == 206) {&#10;                    val inputStream = java.io.BufferedInputStream(connection.inputStream, BUFFER_SIZE / 4)&#10;                    val randomAccessFile = FileDownloadRandomAccessFile.create(outputFile)&#10;&#10;                    randomAccessFile.seek(startByte)&#10;                    val buffer = ByteArray(BUFFER_SIZE / 4) // Smaller buffer for parallel chunks&#10;                    var totalRead = 0L&#10;                    var bytesRead: Int&#10;&#10;                    while (inputStream.read(buffer).also { bytesRead = it } != -1 &amp;&amp; isDownloading) {&#10;                        randomAccessFile.write(buffer, 0, bytesRead)&#10;                        totalRead += bytesRead&#10;&#10;                        // Break if we've read all bytes for this chunk&#10;                        if (startByte + totalRead &gt; endByte) {&#10;                            break&#10;                        }&#10;                    }&#10;&#10;                    randomAccessFile.close()&#10;                    inputStream.close()&#10;                    connection.disconnect()&#10;&#10;                    Log.d(TAG, &quot;Chunk $chunkIndex completed: ${formatBytes(totalRead)} bytes&quot;)&#10;                    return@withContext&#10;&#10;                } else {&#10;                    throw Exception(&quot;Chunk $chunkIndex failed with response code: ${connection.responseCode}&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                retryCount++&#10;                Log.w(TAG, &quot;Chunk $chunkIndex retry $retryCount/$maxRetries: ${e.message}&quot;)&#10;&#10;                if (retryCount &gt;= maxRetries) {&#10;                    throw e&#10;                }&#10;&#10;               delay(1000L * retryCount) // Exponential backoff&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Theo dõi tiến độ của parallel download&#10;     */&#10;    private suspend fun monitorParallelProgress(downloadEntity: DownloadEntity, totalSize: Long, tempFile: File) = withContext(Dispatchers.IO) {&#10;        var lastSize = 0L&#10;        var lastTime = System.currentTimeMillis()&#10;&#10;        while (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId) {&#10;            kotlinx.coroutines.delay(1000) // Update every second&#10;&#10;            if (tempFile.exists()) {&#10;                val currentSize = tempFile.length()&#10;                val currentTime = System.currentTimeMillis()&#10;&#10;                // Tính tốc độ&#10;                val speed = (currentSize - lastSize) / ((currentTime - lastTime) / 1000.0)&#10;                val progress = ((currentSize * 100) / totalSize).toInt()&#10;&#10;                // Cập nhật database&#10;                downloadDao.updateProgress(downloadEntity.downloadId, currentSize)&#10;&#10;                Log.d(TAG, &quot;Parallel progress: $progress% - ${formatBytes(currentSize)}/${formatBytes(totalSize)} - Speed: ${formatSpeed(speed)}&quot;)&#10;&#10;                lastSize = currentSize&#10;                lastTime = currentTime&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy file size từ server&#10;     */&#10;    private suspend fun getFileSize(url: String): Long = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val connection = URL(url).openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;HEAD&quot;&#10;            connection.connect()&#10;&#10;            val size = connection.contentLengthLong&#10;            connection.disconnect()&#10;&#10;            Log.d(TAG, &quot;File size: ${formatBytes(size)}&quot;)&#10;            size&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Cannot get file size: ${e.message}&quot;)&#10;            -1L&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format bytes thành string dễ đọc&#10;     */&#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;%.1f GB&quot;.format(bytes / (1024f * 1024f * 1024f))&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;%.1f MB&quot;.format(bytes / (1024f * 1024f))&#10;            bytes &gt;= 1024 -&gt; &quot;%.1f KB&quot;.format(bytes / 1024f)&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.Context&#10;import android.os.Environment&#10;import android.util.Log&#10;import android.webkit.URLUtil&#10;import androidx.core.content.ContextCompat&#10;import com.marusys.upgradefirmware.database.DownloadDatabase&#10;import com.marusys.upgradefirmware.database.DownloadEntity&#10;import com.marusys.upgradefirmware.network.NetworkStateReceiver&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.awaitAll&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;import java.io.FileInputStream&#10;import java.math.BigInteger&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.security.MessageDigest&#10;import java.util.UUID&#10;&#10;class DownloadingManager(val context: Context) : NetworkStateReceiver.NetworkStateListener {&#10;&#10;    val TAG = &quot;DownloadingManager&quot;&#10;    private var connection: HttpURLConnection? = null&#10;    private var url: String = &quot;&quot;&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;    private var downloadedBytes: Long = 0L&#10;    private var currentDownloadId: String? = null&#10;    private var isDownloading = false&#10;&#10;    // Database&#10;    private val database = DownloadDatabase.getDatabase(context)&#10;    private val downloadDao = database.downloadDao()&#10;&#10;    // Callback để thông báo cho UI&#10;    private var progressCallback: DownloadProgressCallback? = null&#10;&#10;    companion object {&#10;        private var downloadingManager: DownloadingManager? = null&#10;&#10;        // Constants for download optimization&#10;        private const val BUFFER_SIZE = 64 * 1024 // 64KB buffer for faster download&#10;        private const val CONNECT_TIMEOUT = 15000 // 15 seconds&#10;        private const val READ_TIMEOUT = 30000 // 30 seconds&#10;        private const val MAX_PARALLEL_CONNECTIONS = 4 // For parallel downloading&#10;        private const val CHUNK_SIZE = 1024 * 1024 // 1MB chunks for parallel download&#10;&#10;        fun create(context: Context) {&#10;            downloadingManager = DownloadingManager(context)&#10;        }&#10;&#10;        fun getInstance(): DownloadingManager {&#10;            return downloadingManager!!&#10;        }&#10;&#10;        fun getPath(dirPath: String?, fileName: String?): String {&#10;            return dirPath + File.separator + fileName&#10;        }&#10;&#10;        fun getTempPath(dirPath: String?, fileName: String?): String {&#10;            return getPath(dirPath, fileName) + &quot;.temp&quot;&#10;        }&#10;    }&#10;&#10;    init {&#10;        // Đăng ký network listener&#10;        NetworkStateReceiver.addListener(this)&#10;&#10;        // Resume downloads khi khởi tạo&#10;        resumeIncompleteDownloads()&#10;    }&#10;&#10;    fun getRootDirPath(context: Context): String {&#10;        if (Environment.MEDIA_MOUNTED == Environment.getExternalStorageState()) {&#10;            val file = ContextCompat.getExternalFilesDirs(&#10;                context.getApplicationContext(),&#10;                null&#10;            )[0]&#10;            return file.getAbsolutePath()&#10;        } else {&#10;            return context.getApplicationContext().getFilesDir().getAbsolutePath()&#10;        }&#10;    }&#10;    /**&#10;     * Start download với database persistence&#10;     */&#10;    fun startDownloading(url: String, expectedMD5: String? = null) {&#10;        scope.launch {&#10;            try {&#10;                val downloadId = UUID.randomUUID().toString()&#10;                currentDownloadId = downloadId&#10;&#10;                val dirPath = getRootDirPath(context)&#10;                val fileName = URLUtil.guessFileName(url, null, null)&#10;                val tempPath = getTempPath(dirPath, fileName)&#10;                val finalPath = getPath(dirPath, fileName)&#10;&#10;                // Lưu vào database&#10;                val downloadEntity = DownloadEntity(&#10;                    downloadId = downloadId,&#10;                    url = url,&#10;                    fileName = fileName,&#10;                    filePath = finalPath,&#10;                    tempPath = tempPath,&#10;                    downloadedBytes = 0L,&#10;                    totalBytes = 0L,&#10;                    status = DownloadEntity.STATUS_PENDING,&#10;                    expectedMD5 = expectedMD5&#10;                )&#10;&#10;                downloadDao.insertDownload(downloadEntity)&#10;                Log.d(TAG, &quot;Saved download to database: $fileName&quot;)&#10;&#10;                // Bắt đầu download&#10;                performDownload(downloadEntity)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error starting download: ${e.message}&quot;)&#10;                currentDownloadId?.let { id -&gt;&#10;                    updateDownloadStatus(id, DownloadEntity.STATUS_FAILED, e.message)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resume downloads chưa hoàn thành khi app khởi động&#10;     */&#10;    private fun resumeIncompleteDownloads() {&#10;        scope.launch {&#10;            try {&#10;                val incompleteDownloads = downloadDao.getIncompleteDownloads()&#10;                Log.d(TAG, &quot;Found ${incompleteDownloads.size} incomplete downloads to resume&quot;)&#10;&#10;                incompleteDownloads.forEach { download -&gt;&#10;                    // Kiểm tra file tồn tại và validate&#10;                    val tempFile = File(download.tempPath)&#10;                    if (tempFile.exists()) {&#10;                        val actualSize = tempFile.length()&#10;                        if (actualSize != download.downloadedBytes) {&#10;                            // Cập nhật downloaded bytes theo kích thước file thật&#10;                            downloadDao.updateProgress(download.downloadId, actualSize)&#10;                            Log.d(TAG, &quot;Updated progress for ${download.fileName}: $actualSize bytes&quot;)&#10;                        }&#10;                    }&#10;&#10;                    // Set status về paused để user có thể resume&#10;                    downloadDao.updateStatus(download.downloadId, DownloadEntity.STATUS_PAUSED)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error resuming incomplete downloads: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resume download cụ thể&#10;     */&#10;    fun resumeDownload(downloadId: String) {&#10;        scope.launch {&#10;            try {&#10;                val download = downloadDao.getDownloadById(downloadId)&#10;                if (download != null &amp;&amp; !isDownloading) {&#10;                    Log.d(TAG, &quot;Resuming download: ${download.fileName}&quot;)&#10;                    currentDownloadId = downloadId&#10;                    performDownload(download)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error resuming download: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thực hiện download chính với tối ưu hóa tốc độ&#10;     */&#10;    private suspend fun performDownload(downloadEntity: DownloadEntity) = withContext(Dispatchers.IO) {&#10;        try {&#10;            isDownloading = true&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_DOWNLOADING)&#10;            &#10;            // Thông báo UI về state change&#10;            progressCallback?.onDownloadStateChanged(downloadEntity.downloadId, DownloadEntity.STATUS_DOWNLOADING)&#10;&#10;            val tempFile = File(downloadEntity.tempPath)&#10;            downloadedBytes = if (tempFile.exists()) tempFile.length() else 0L&#10;&#10;            // Cập nhật downloaded bytes trong database&#10;            if (downloadedBytes &gt; 0) {&#10;                downloadDao.updateProgress(downloadEntity.downloadId, downloadedBytes)&#10;            }&#10;&#10;            Log.d(TAG, &quot;Starting optimized download from byte: $downloadedBytes for ${downloadEntity.fileName}&quot;)&#10;&#10;            connection = createOptimizedConnection(downloadEntity.url, downloadedBytes)&#10;&#10;            Log.d(TAG, &quot;performDownload: ====&gt; connecting with optimizations&quot;)&#10;            connection?.connect()&#10;&#10;            // Kiểm tra response code&#10;            val responseCode = connection?.responseCode ?: 0&#10;            Log.d(TAG, &quot;HTTP Response Code: $responseCode&quot;)&#10;&#10;            if (responseCode !in 200..299 &amp;&amp; responseCode != 206) {&#10;                throw Exception(&quot;HTTP Error: $responseCode - ${connection?.responseMessage}&quot;)&#10;            }&#10;&#10;            val contentLength = connection?.contentLengthLong ?: 0L&#10;            val totalBytes = contentLength + downloadedBytes&#10;            downloadDao.updateTotalBytes(downloadEntity.downloadId, totalBytes)&#10;&#10;            val inputStream = connection?.inputStream&#10;&#10;            // Sử dụng BufferedInputStream cho tốc độ cao hơn&#10;            val bufferedInputStream = java.io.BufferedInputStream(inputStream, BUFFER_SIZE)&#10;&#10;            // Tạo file và folder nếu chưa có&#10;            if (!tempFile.exists()) {&#10;                tempFile.parentFile?.mkdirs()&#10;                tempFile.createNewFile()&#10;            }&#10;&#10;            val outputStream = FileDownloadRandomAccessFile.create(tempFile)&#10;            if (downloadedBytes != 0L) {&#10;                outputStream.seek(downloadedBytes)&#10;            }&#10;&#10;            // Sử dụng buffer lớn hơn cho tốc độ cao&#10;            val buff = ByteArray(BUFFER_SIZE)&#10;            var lastUpdateTime = System.currentTimeMillis()&#10;            var bytesReadInSecond = 0L&#10;            var lastSpeedUpdate = System.currentTimeMillis()&#10;&#10;            do {&#10;                try {&#10;                    val byteCount: Int = bufferedInputStream.read(buff, 0, BUFFER_SIZE)&#10;                    if (byteCount == -1) {&#10;                        break&#10;                    }&#10;&#10;                    outputStream.write(buff, 0, byteCount)&#10;                    downloadedBytes += byteCount&#10;                    bytesReadInSecond += byteCount&#10;&#10;                    // Cập nhật database và UI mỗi giây&#10;                    val currentTime = System.currentTimeMillis()&#10;                    if (currentTime - lastUpdateTime &gt; 1000) {&#10;                        downloadDao.updateProgress(downloadEntity.downloadId, downloadedBytes)&#10;&#10;                        // Tính tốc độ download&#10;                        val speed = bytesReadInSecond / ((currentTime - lastSpeedUpdate) / 1000.0)&#10;                        val speedString = formatSpeed(speed)&#10;                        &#10;                        // Thông báo UI về progress update&#10;                        progressCallback?.onProgressUpdate(&#10;                            downloadEntity.downloadId, &#10;                            downloadedBytes, &#10;                            totalBytes, &#10;                            speedString&#10;                        )&#10;                        &#10;                        Log.d(TAG, &quot;Progress: ${downloadEntity.fileName} - $downloadedBytes/$totalBytes bytes - Speed: $speedString&quot;)&#10;&#10;                        lastUpdateTime = currentTime&#10;                        lastSpeedUpdate = currentTime&#10;                        bytesReadInSecond = 0L&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Download error: ${e.message}&quot;)&#10;                    downloadDao.updateError(downloadEntity.downloadId, e.message)&#10;                    progressCallback?.onDownloadError(downloadEntity.downloadId, e.message ?: &quot;Unknown error&quot;)&#10;                    throw e&#10;                }&#10;&#10;            } while (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId)&#10;&#10;            outputStream.close()&#10;            bufferedInputStream.close()&#10;            connection?.disconnect()&#10;&#10;            if (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId) {&#10;                // Download hoàn thành&#10;                val finalPath = downloadEntity.filePath&#10;                Utils.renameFileName(downloadEntity.tempPath, finalPath)&#10;&#10;                downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_COMPLETED)&#10;                &#10;                // Thông báo UI về completion&#10;                progressCallback?.onDownloadStateChanged(downloadEntity.downloadId, DownloadEntity.STATUS_COMPLETED)&#10;                progressCallback?.onDownloadCompleted(downloadEntity.downloadId, true, finalPath)&#10;                &#10;                Log.d(TAG, &quot;Download completed: ${downloadEntity.fileName}&quot;)&#10;&#10;                // Verify MD5 nếu có&#10;                downloadEntity.expectedMD5?.let { expectedMD5 -&gt;&#10;                    verifyDownloadIntegrity(finalPath, expectedMD5) { isValid -&gt;&#10;                        scope.launch {&#10;                            if (isValid) {&#10;                                Log.d(TAG, &quot;✅ ${downloadEntity.fileName} - MD5 verification successful&quot;)&#10;                            } else {&#10;                                Log.e(TAG, &quot;❌ ${downloadEntity.fileName} - MD5 verification failed&quot;)&#10;                                downloadDao.updateError(downloadEntity.downloadId, &quot;MD5 verification failed&quot;)&#10;                                progressCallback?.onDownloadError(downloadEntity.downloadId, &quot;MD5 verification failed&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Download failed: ${e.message}&quot;)&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_FAILED)&#10;            downloadDao.updateError(downloadEntity.downloadId, e.message)&#10;            &#10;            // Thông báo UI về failure&#10;            progressCallback?.onDownloadStateChanged(downloadEntity.downloadId, DownloadEntity.STATUS_FAILED)&#10;            progressCallback?.onDownloadError(downloadEntity.downloadId, e.message ?: &quot;Download failed&quot;)&#10;        } finally {&#10;            isDownloading = false&#10;            currentDownloadId = null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tạo connection được tối ưu hóa cho tốc độ download cao&#10;     */&#10;    private fun createOptimizedConnection(url: String, startByte: Long): HttpURLConnection {&#10;        val connection = URL(url).openConnection() as HttpURLConnection&#10;&#10;        // Timeout tối ưu&#10;        connection.connectTimeout = CONNECT_TIMEOUT&#10;        connection.readTimeout = READ_TIMEOUT&#10;&#10;        // Headers để tối ưu tốc độ&#10;        connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android) DownloadManager/2.0&quot;)&#10;        connection.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;        connection.setRequestProperty(&quot;Accept-Encoding&quot;, &quot;identity&quot;) // Không nén để tăng tốc&#10;        connection.setRequestProperty(&quot;Connection&quot;, &quot;keep-alive&quot;)&#10;        connection.setRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;)&#10;&#10;        // Thêm Range header nếu resume&#10;        if (startByte &gt; 0) {&#10;            connection.setRequestProperty(&quot;Range&quot;, &quot;bytes=$startByte-&quot;)&#10;            Log.d(TAG, &quot;Resume download from byte: $startByte&quot;)&#10;        }&#10;&#10;        // Tối ưu HTTP settings&#10;        connection.instanceFollowRedirects = true&#10;        connection.useCaches = false&#10;        connection.doInput = true&#10;&#10;        // Thêm headers để server biết client hỗ trợ range requests&#10;        connection.setRequestProperty(&quot;Accept-Ranges&quot;, &quot;bytes&quot;)&#10;&#10;        Log.d(TAG, &quot;Created optimized connection with ${BUFFER_SIZE/1024}KB buffer&quot;)&#10;        return connection&#10;    }&#10;&#10;    /**&#10;     * Format tốc độ download để hiển thị&#10;     */&#10;    private fun formatSpeed(bytesPerSecond: Double): String {&#10;        return when {&#10;            bytesPerSecond &gt;= 1024 * 1024 -&gt; &quot;%.1f MB/s&quot;.format(bytesPerSecond / (1024 * 1024))&#10;            bytesPerSecond &gt;= 1024 -&gt; &quot;%.1f KB/s&quot;.format(bytesPerSecond / 1024)&#10;            else -&gt; &quot;%.0f B/s&quot;.format(bytesPerSecond)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pause download hiện tại&#10;     */&#10;    fun pauseDownload() {&#10;        isDownloading = false&#10;        currentDownloadId?.let { id -&gt;&#10;            scope.launch {&#10;                updateDownloadStatus(id, DownloadEntity.STATUS_PAUSED)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Download paused&quot;)&#10;    }&#10;&#10;    /**&#10;     * Cancel download hiện tại&#10;     */&#10;    fun cancelDownload() {&#10;        isDownloading = false&#10;        currentDownloadId?.let { id -&gt;&#10;            scope.launch {&#10;                updateDownloadStatus(id, DownloadEntity.STATUS_CANCELLED)&#10;                // Xóa temp file&#10;                val download = downloadDao.getDownloadById(id)&#10;                download?.let {&#10;                    File(it.tempPath).delete()&#10;                }&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Download cancelled&quot;)&#10;    }&#10;&#10;    // NetworkStateReceiver.NetworkStateListener implementation&#10;    override fun onNetworkAvailable() {&#10;        Log.d(TAG, &quot;Network available - resuming paused downloads&quot;)&#10;        &#10;        // Thông báo cho UI về network reconnection&#10;        currentDownloadId?.let { downloadId -&gt;&#10;            progressCallback?.onNetworkReconnected(downloadId)&#10;        }&#10;        &#10;        scope.launch {&#10;            val pausedDownloads = downloadDao.getIncompleteDownloads()&#10;                .filter { it.status == DownloadEntity.STATUS_PAUSED }&#10;&#10;            if (pausedDownloads.isNotEmpty() &amp;&amp; !isDownloading) {&#10;                // Resume download đầu tiên&#10;                val download = pausedDownloads.first()&#10;                currentDownloadId = download.downloadId&#10;                &#10;                // Thông báo UI về việc auto-resume&#10;                progressCallback?.onDownloadStateChanged(download.downloadId, DownloadEntity.STATUS_DOWNLOADING)&#10;                &#10;                resumeDownload(download.downloadId)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onNetworkLost() {&#10;        Log.d(TAG, &quot;Network lost - pausing current download&quot;)&#10;        &#10;        // Thông báo cho UI về network loss&#10;        currentDownloadId?.let { downloadId -&gt;&#10;            progressCallback?.onNetworkLost(downloadId)&#10;            progressCallback?.onDownloadStateChanged(downloadId, DownloadEntity.STATUS_PAUSED)&#10;        }&#10;        &#10;        if (isDownloading) {&#10;            pauseDownload()&#10;        }&#10;    }&#10;&#10;    private suspend fun updateDownloadStatus(downloadId: String, status: Int, error: String? = null) {&#10;        downloadDao.updateStatus(downloadId, status)&#10;        error?.let { downloadDao.updateError(downloadId, it) }&#10;    }&#10;&#10;    fun cleanup() {&#10;        NetworkStateReceiver.removeListener(this)&#10;        isDownloading = false&#10;        connection?.disconnect()&#10;    }&#10;&#10;    /**&#10;     * Tính MD5 checksum của file&#10;     * @param file File cần tính checksum&#10;     * @return String MD5 hash hoặc null nếu có lỗi&#10;     */&#10;    fun calculateMD5(file: File): String? {&#10;        return try {&#10;            val md5 = MessageDigest.getInstance(&quot;MD5&quot;)&#10;            FileInputStream(file).use { fis -&gt;&#10;                val buffer = ByteArray(8192)&#10;                var bytesRead: Int&#10;                while (fis.read(buffer).also { bytesRead = it } != -1) {&#10;                    md5.update(buffer, 0, bytesRead)&#10;                }&#10;            }&#10;            val digest = md5.digest()&#10;            val bigInteger = BigInteger(1, digest)&#10;            bigInteger.toString(16).padStart(32, '0')&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error calculating MD5: ${e.message}&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Tính MD5 checksum của file theo đường dẫn&#10;     * @param filePath Đường dẫn đến file&#10;     * @return String MD5 hash hoặc null nếu có lỗi&#10;     */&#10;    fun calculateMD5(filePath: String): String? {&#10;        val file = File(filePath)&#10;        return if (file.exists() &amp;&amp; file.isFile) {&#10;            calculateMD5(file)&#10;        } else {&#10;            Log.e(TAG, &quot;File not found: $filePath&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * So sánh MD5 checksum của file v��i hash mong đợi&#10;     * @param file File cần kiểm tra&#10;     * @param expectedHash MD5 hash mong đợi&#10;     * @return true nếu khớp, false nếu không khớp&#10;     */&#10;    fun verifyMD5(file: File, expectedHash: String): Boolean {&#10;        val actualHash = calculateMD5(file)&#10;        return if (actualHash != null) {&#10;            val isValid = actualHash.equals(expectedHash, ignoreCase = true)&#10;            Log.d(TAG, &quot;MD5 Verification - Expected: $expectedHash, Actual: $actualHash, Valid: $isValid&quot;)&#10;            isValid&#10;        } else {&#10;            Log.e(TAG, &quot;Cannot calculate MD5 for verification&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * So sánh MD5 checksum của file theo đường dẫn với hash mong đợi&#10;     * @param filePath Đường dẫn đến file&#10;     * @param expectedHash MD5 hash mong đợi&#10;     * @return true nếu khớp, false nếu không khớp&#10;     */&#10;    fun verifyMD5(filePath: String, expectedHash: String): Boolean {&#10;        val file = File(filePath)&#10;        return if (file.exists() &amp;&amp; file.isFile) {&#10;            verifyMD5(file, expectedHash)&#10;        } else {&#10;            Log.e(TAG, &quot;File not found for MD5 verification: $filePath&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra tính toàn vẹn file sau khi download hoàn thành&#10;     * @param filePath Đường dẫn file đã download&#10;     * @param expectedMD5 MD5 hash mong đợi&#10;     * @param onResult Callback trả về kết quả (true/false)&#10;     */&#10;    fun verifyDownloadIntegrity(filePath: String, expectedMD5: String, onResult: (Boolean) -&gt; Unit) {&#10;        scope.launch {&#10;            val isValid = verifyMD5(filePath, expectedMD5)&#10;            withContext(Dispatchers.Main) {&#10;                onResult(isValid)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Start parallel download để tăng tốc độ&#10;     */&#10;    fun startParallelDownloading(url: String, expectedMD5: String? = null, numConnections: Int = MAX_PARALLEL_CONNECTIONS) {&#10;        scope.launch {&#10;            try {&#10;                val downloadId = UUID.randomUUID().toString()&#10;                currentDownloadId = downloadId&#10;&#10;                val dirPath = getRootDirPath(context)&#10;                val fileName = URLUtil.guessFileName(url, null, null)&#10;                val tempPath = getTempPath(dirPath, fileName)&#10;                val finalPath = getPath(dirPath, fileName)&#10;&#10;                // Kiểm tra xem server có hỗ tr��� range requests không&#10;                if (supportsRangeRequests(url)) {&#10;                    Log.d(TAG, &quot;Server supports range requests - using parallel download with $numConnections connections&quot;)&#10;&#10;                    val downloadEntity = DownloadEntity(&#10;                        downloadId = downloadId,&#10;                        url = url,&#10;                        fileName = fileName,&#10;                        filePath = finalPath,&#10;                        tempPath = tempPath,&#10;                        downloadedBytes = 0L,&#10;                        totalBytes = 0L,&#10;                        status = DownloadEntity.STATUS_PENDING,&#10;                        expectedMD5 = expectedMD5&#10;                    )&#10;&#10;                    downloadDao.insertDownload(downloadEntity)&#10;                    performParallelDownload(downloadEntity, numConnections)&#10;                } else {&#10;                    Log.d(TAG, &quot;Server doesn't support range requests - using single connection&quot;)&#10;                    startDownloading(url, expectedMD5)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error starting parallel download: ${e.message}&quot;)&#10;                currentDownloadId?.let { id -&gt;&#10;                    updateDownloadStatus(id, DownloadEntity.STATUS_FAILED, e.message)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Kiểm tra server có hỗ trợ range requests không&#10;     */&#10;    private suspend fun supportsRangeRequests(url: String): Boolean = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val connection = URL(url).openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;HEAD&quot;&#10;            connection.connect()&#10;&#10;            val acceptRanges = connection.getHeaderField(&quot;Accept-Ranges&quot;)&#10;            val supportsRanges = acceptRanges == &quot;bytes&quot; || connection.responseCode == 206&#10;&#10;            connection.disconnect()&#10;            Log.d(TAG, &quot;Range support check - Accept-Ranges: $acceptRanges, Supports: $supportsRanges&quot;)&#10;            supportsRanges&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Cannot check range support: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Thực hiện parallel download&#10;     */&#10;    private suspend fun performParallelDownload(downloadEntity: DownloadEntity, numConnections: Int) = withContext(Dispatchers.IO) {&#10;        try {&#10;            isDownloading = true&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_DOWNLOADING)&#10;&#10;            // Lấy file size trước&#10;            val totalFileSize = getFileSize(downloadEntity.url)&#10;            if (totalFileSize &lt;= 0) {&#10;                throw Exception(&quot;Cannot determine file size for parallel download&quot;)&#10;            }&#10;&#10;            downloadDao.updateTotalBytes(downloadEntity.downloadId, totalFileSize)&#10;            Log.d(TAG, &quot;Starting parallel download - File size: ${formatBytes(totalFileSize)}, Connections: $numConnections&quot;)&#10;&#10;            val tempFile = File(downloadEntity.tempPath)&#10;            if (!tempFile.exists()) {&#10;                tempFile.parentFile?.mkdirs()&#10;                tempFile.createNewFile()&#10;            }&#10;&#10;            // Tạo file với size đầy đủ&#10;            val randomAccessFile = FileDownloadRandomAccessFile.create(tempFile)&#10;            randomAccessFile.setLength(totalFileSize)&#10;&#10;            // Chia file thành các chunk&#10;            val chunkSize = totalFileSize / numConnections&#10;            val downloadJobs = mutableListOf&lt;kotlinx.coroutines.Deferred&lt;Unit&gt;&gt;()&#10;&#10;            repeat(numConnections) { i -&gt;&#10;                val startByte = i * chunkSize&#10;                val endByte = if (i == numConnections - 1) totalFileSize - 1 else (i + 1) * chunkSize - 1&#10;&#10;                val job = async {&#10;                    downloadChunk(downloadEntity.url, startByte, endByte, tempFile, i)&#10;                }&#10;                downloadJobs.add(job)&#10;&#10;                Log.d(TAG, &quot;Chunk $i: ${formatBytes(startByte)} - ${formatBytes(endByte)}&quot;)&#10;            }&#10;&#10;            // Theo dõi tiến độ&#10;            val progressJob = async {&#10;                monitorParallelProgress(downloadEntity, totalFileSize, tempFile)&#10;            }&#10;&#10;            // Đợi tất cả chunks hoàn thành&#10;            downloadJobs.awaitAll()&#10;            progressJob.cancel()&#10;&#10;            randomAccessFile.close()&#10;&#10;            if (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId) {&#10;                // Download hoàn thành&#10;                Utils.renameFileName(downloadEntity.tempPath, downloadEntity.filePath)&#10;                downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_COMPLETED)&#10;                Log.d(TAG, &quot;Parallel download completed: ${downloadEntity.fileName}&quot;)&#10;&#10;                // Verify MD5&#10;                downloadEntity.expectedMD5?.let { expectedMD5 -&gt;&#10;                    verifyDownloadIntegrity(downloadEntity.filePath, expectedMD5) { isValid -&gt;&#10;                        scope.launch {&#10;                            if (isValid) {&#10;                                Log.d(TAG, &quot;✅ ${downloadEntity.fileName} - MD5 verification successful&quot;)&#10;                            } else {&#10;                                Log.e(TAG, &quot;❌ ${downloadEntity.fileName} - MD5 verification failed&quot;)&#10;                                downloadDao.updateError(downloadEntity.downloadId, &quot;MD5 verification failed&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Parallel download failed: ${e.message}&quot;)&#10;            downloadDao.updateStatus(downloadEntity.downloadId, DownloadEntity.STATUS_FAILED)&#10;            downloadDao.updateError(downloadEntity.downloadId, e.message)&#10;        } finally {&#10;            isDownloading = false&#10;            currentDownloadId = null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Download một chunk của file&#10;     */&#10;    private suspend fun downloadChunk(url: String, startByte: Long, endByte: Long, outputFile: File, chunkIndex: Int) = withContext(Dispatchers.IO) {&#10;        var retryCount = 0&#10;        val maxRetries = 3&#10;&#10;        while (retryCount &lt; maxRetries &amp;&amp; isDownloading) {&#10;            try {&#10;                val connection = URL(url).openConnection() as HttpURLConnection&#10;&#10;                // Cấu hình connection cho chunk&#10;                connection.connectTimeout = CONNECT_TIMEOUT&#10;                connection.readTimeout = READ_TIMEOUT&#10;                connection.setRequestProperty(&quot;Range&quot;, &quot;bytes=$startByte-$endByte&quot;)&#10;                connection.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android) ParallelDownloader/1.0&quot;)&#10;                connection.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;&#10;                connection.connect()&#10;&#10;                if (connection.responseCode == 206) {&#10;                    val inputStream = java.io.BufferedInputStream(connection.inputStream, BUFFER_SIZE / 4)&#10;                    val randomAccessFile = FileDownloadRandomAccessFile.create(outputFile)&#10;&#10;                    randomAccessFile.seek(startByte)&#10;                    val buffer = ByteArray(BUFFER_SIZE / 4) // Smaller buffer for parallel chunks&#10;                    var totalRead = 0L&#10;                    var bytesRead: Int&#10;&#10;                    while (inputStream.read(buffer).also { bytesRead = it } != -1 &amp;&amp; isDownloading) {&#10;                        randomAccessFile.write(buffer, 0, bytesRead)&#10;                        totalRead += bytesRead&#10;&#10;                        // Break if we've read all bytes for this chunk&#10;                        if (startByte + totalRead &gt; endByte) {&#10;                            break&#10;                        }&#10;                    }&#10;&#10;                    randomAccessFile.close()&#10;                    inputStream.close()&#10;                    connection.disconnect()&#10;&#10;                    Log.d(TAG, &quot;Chunk $chunkIndex completed: ${formatBytes(totalRead)} bytes&quot;)&#10;                    return@withContext&#10;&#10;                } else {&#10;                    throw Exception(&quot;Chunk $chunkIndex failed with response code: ${connection.responseCode}&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                retryCount++&#10;                Log.w(TAG, &quot;Chunk $chunkIndex retry $retryCount/$maxRetries: ${e.message}&quot;)&#10;&#10;                if (retryCount &gt;= maxRetries) {&#10;                    throw e&#10;                }&#10;&#10;               delay(1000L * retryCount) // Exponential backoff&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Theo dõi tiến độ của parallel download&#10;     */&#10;    private suspend fun monitorParallelProgress(downloadEntity: DownloadEntity, totalSize: Long, tempFile: File) = withContext(Dispatchers.IO) {&#10;        var lastSize = 0L&#10;        var lastTime = System.currentTimeMillis()&#10;&#10;        while (isDownloading &amp;&amp; currentDownloadId == downloadEntity.downloadId) {&#10;            kotlinx.coroutines.delay(1000) // Update every second&#10;&#10;            if (tempFile.exists()) {&#10;                val currentSize = tempFile.length()&#10;                val currentTime = System.currentTimeMillis()&#10;&#10;                // Tính tốc độ&#10;                val speed = (currentSize - lastSize) / ((currentTime - lastTime) / 1000.0)&#10;                val progress = ((currentSize * 100) / totalSize).toInt()&#10;&#10;                // Cập nhật database&#10;                downloadDao.updateProgress(downloadEntity.downloadId, currentSize)&#10;&#10;                Log.d(TAG, &quot;Parallel progress: $progress% - ${formatBytes(currentSize)}/${formatBytes(totalSize)} - Speed: ${formatSpeed(speed)}&quot;)&#10;&#10;                lastSize = currentSize&#10;                lastTime = currentTime&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Lấy file size từ server&#10;     */&#10;    private suspend fun getFileSize(url: String): Long = withContext(Dispatchers.IO) {&#10;        return@withContext try {&#10;            val connection = URL(url).openConnection() as HttpURLConnection&#10;            connection.requestMethod = &quot;HEAD&quot;&#10;            connection.connect()&#10;&#10;            val size = connection.contentLengthLong&#10;            connection.disconnect()&#10;&#10;            Log.d(TAG, &quot;File size: ${formatBytes(size)}&quot;)&#10;            size&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Cannot get file size: ${e.message}&quot;)&#10;            -1L&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Format bytes thành string dễ đọc&#10;     */&#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;%.1f GB&quot;.format(bytes / (1024f * 1024f * 1024f))&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;%.1f MB&quot;.format(bytes / (1024f * 1024f))&#10;            bytes &gt;= 1024 -&gt; &quot;%.1f KB&quot;.format(bytes / 1024f)&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Set callback để UI nhận updates khi network reconnect và auto-resume&#10;     */&#10;    fun setProgressCallback(callback: DownloadProgressCallback?) {&#10;        progressCallback = callback&#10;    }&#10;&#10;    /**&#10;     * Gọi callback để thông báo tiến độ download cho UI&#10;     */&#10;    private fun notifyProgress(downloadId: String, downloadedBytes: Long, totalBytes: Long) {&#10;        progressCallback?.onProgress(downloadId, downloadedBytes, totalBytes)&#10;    }&#10;&#10;    /**&#10;     * Gọi callback khi download hoàn thành&#10;     */&#10;    private fun notifyCompletion(downloadId: String, success: Boolean, errorMessage: String? = null) {&#10;        progressCallback?.onCompletion(downloadId, success, errorMessage)&#10;    }&#10;&#10;    /**&#10;     * Gọi callback khi có lỗi xảy ra&#10;     */&#10;    private fun notifyError(downloadId: String, errorMessage: String) {&#10;        progressCallback?.onError(downloadId, errorMessage)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/FileDownloadRandomAccessFile.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/FileDownloadRandomAccessFile.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.File&#10;import java.io.RandomAccessFile&#10;&#10;object FileDownloadRandomAccessFile {&#10;    &#10;    fun create(file: File): RandomAccessFile {&#10;        return RandomAccessFile(file, &quot;rw&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/FileStorageManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/FileStorageManager.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.ContentResolver&#10;import android.content.ContentValues&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.os.Environment&#10;import android.provider.MediaStore&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.io.OutputStream&#10;&#10;/**&#10; * Handles file storage using ContentProvider for Android 14+ compatibility&#10; * Uses MediaStore API for proper scoped storage access&#10; */&#10;class FileStorageManager(private val context: Context) {&#10;    &#10;    /**&#10;     * Creates a file in the Downloads directory using ContentProvider&#10;     * Returns the Uri of the created file&#10;     */&#10;    fun createDownloadFile(fileName: String, mimeType: String = &quot;application/octet-stream&quot;): Uri? {&#10;        val contentResolver = context.contentResolver&#10;        &#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            // Android 10+ using scoped storage&#10;            createFileWithMediaStore(contentResolver, fileName, mimeType)&#10;        } else {&#10;            // Legacy storage for older Android versions&#10;            createFileLegacy(fileName)&#10;        }&#10;    }&#10;    &#10;    private fun createFileWithMediaStore(&#10;        contentResolver: ContentResolver,&#10;        fileName: String,&#10;        mimeType: String&#10;    ): Uri? {&#10;        val contentValues = ContentValues().apply {&#10;            put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)&#10;            put(MediaStore.MediaColumns.MIME_TYPE, mimeType)&#10;            put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS)&#10;            &#10;            // Mark as pending while we write the file&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                put(MediaStore.MediaColumns.IS_PENDING, 1)&#10;            }&#10;        }&#10;        &#10;        return contentResolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, contentValues)&#10;    }&#10;    &#10;    private fun createFileLegacy(fileName: String): Uri? {&#10;        // For legacy support, you might still need to handle this differently&#10;        // This is a simplified approach - in practice you'd use File API&#10;        return null&#10;    }&#10;    &#10;    /**&#10;     * Opens an OutputStream for writing to the file&#10;     */&#10;    fun openOutputStream(uri: Uri): OutputStream? {&#10;        return context.contentResolver.openOutputStream(uri)&#10;    }&#10;    &#10;    /**&#10;     * Opens an OutputStream for appending to the file (for resume functionality)&#10;     */&#10;    fun openOutputStreamForAppend(uri: Uri): OutputStream? {&#10;        return context.contentResolver.openOutputStream(uri, &quot;wa&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Marks the file as completed (removes pending status)&#10;     */&#10;    fun markFileAsCompleted(uri: Uri) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            val contentValues = ContentValues().apply {&#10;                put(MediaStore.MediaColumns.IS_PENDING, 0)&#10;            }&#10;            context.contentResolver.update(uri, contentValues, null, null)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Deletes the file if download fails or is cancelled&#10;     */&#10;    fun deleteFile(uri: Uri): Boolean {&#10;        return try {&#10;            context.contentResolver.delete(uri, null, null) &gt; 0&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Gets the file size for resume functionality&#10;     */&#10;    fun getFileSize(uri: Uri): Long {&#10;        return try {&#10;            context.contentResolver.openInputStream(uri)?.use { inputStream -&gt;&#10;                inputStream.available().toLong()&#10;            } ?: 0L&#10;        } catch (e: Exception) {&#10;            0L&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Checks if a file exists at the given Uri&#10;     */&#10;    fun fileExists(uri: Uri): Boolean {&#10;        return try {&#10;            context.contentResolver.openInputStream(uri)?.use { true } ?: false&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/FirmwareManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/FirmwareManager.kt" />
              <option name="originalContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.webkit.URLUtil&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.util.concurrent.TimeUnit&#10;import java.io.File&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;/**&#10; * Clean implementation of firmware download manager&#10; * Manages multiple concurrent downloads with proper state tracking&#10; */&#10;class FirmwareManager private constructor() {&#10;&#10;    private val activeDownloads = ConcurrentHashMap&lt;Long, DownloadTask&gt;()&#10;    private val downloadScope = CoroutineScope(Dispatchers.IO)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: FirmwareManager? = null&#10;&#10;        fun getInstance(): FirmwareManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: FirmwareManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startDownload(&#10;        request: DownloadRequest,&#10;        outputFile: Uri,&#10;        listener: DownloadListener? = null&#10;    ): Long {&#10;        validateDownloadRequest(request, outputFile)&#10;&#10;        if (isDownloadActive(request.downloadId)) {&#10;            throw IllegalStateException(&quot;Download with ID ${request.downloadId} is already active&quot;)&#10;        }&#10;&#10;        val downloadTask = createDownloadTask(request, outputFile, listener)&#10;        activeDownloads[request.downloadId] = downloadTask&#10;&#10;        downloadScope.launch {&#10;            try {&#10;                downloadTask.startDownload()&#10;            } finally {&#10;                removeCompletedDownload(request.downloadId)&#10;            }&#10;        }&#10;&#10;        return request.downloadId&#10;    }&#10;&#10;    private fun validateDownloadRequest(request: DownloadRequest, outputFile: File) {&#10;        require(request.url.isNotBlank()) { &quot;Download URL cannot be empty&quot; }&#10;        require(request.downloadId != -1L) { &quot;Invalid download ID&quot; }&#10;        require(outputFile.parentFile?.exists() == true) {&#10;            &quot;Output directory does not exist: ${outputFile.parent}&quot;&#10;        }&#10;    }&#10;&#10;    private fun createDownloadTask(&#10;        request: DownloadRequest,&#10;        outputFile: File,&#10;        listener: DownloadListener?&#10;    ): DownloadTask {&#10;        return DownloadTask(request, outputFile, listener)&#10;    }&#10;&#10;    fun pauseDownload(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.let { task -&gt;&#10;            task.pauseDownload()&#10;            true&#10;        } ?: false&#10;    }&#10;&#10;    fun resumeDownload(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.let { task -&gt;&#10;            task.resumeDownload()&#10;            true&#10;        } ?: false&#10;    }&#10;&#10;    fun cancelDownload(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.let { task -&gt;&#10;            task.cancelDownload()&#10;            activeDownloads.remove(downloadId)&#10;            true&#10;        } ?: false&#10;    }&#10;&#10;    fun cancelAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            task.cancelDownload()&#10;        }&#10;        activeDownloads.clear()&#10;    }&#10;&#10;    fun getDownloadState(downloadId: Long): DownloadState? {&#10;        return getDownloadTask(downloadId)?.getDownloadState()&#10;    }&#10;&#10;    fun getDownloadProgress(downloadId: Long): Long {&#10;        return getDownloadTask(downloadId)?.getCurrentProgress() ?: 0L&#10;    }&#10;&#10;    fun isDownloadActive(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.isActive() == true&#10;    }&#10;&#10;    fun getActiveDownloadIds(): Set&lt;Long&gt; {&#10;        return activeDownloads.keys.toSet()&#10;    }&#10;&#10;    fun getActiveDownloadCount(): Int = activeDownloads.size&#10;&#10;    private fun getDownloadTask(downloadId: Long): DownloadTask? {&#10;        return activeDownloads[downloadId]&#10;    }&#10;&#10;    private fun removeCompletedDownload(downloadId: Long) {&#10;        activeDownloads.remove(downloadId)&#10;    }&#10;&#10;    // Convenience methods for backward compatibility&#10;    @Deprecated(&quot;Use startDownload with DownloadListener instead&quot;, ReplaceWith(&quot;startDownload&quot;))&#10;    fun download(request: DownloadRequest, outputFile: File) {&#10;        startDownload(request, outputFile)&#10;    }&#10;&#10;    @Deprecated(&quot;Use cancelDownload(downloadId) instead&quot;, ReplaceWith(&quot;cancelDownload&quot;))&#10;    fun cancelRequest(request: DownloadRequest) {&#10;        cancelDownload(request.downloadId)&#10;    }&#10;&#10;    @Deprecated(&quot;Use pauseDownload(downloadId) instead&quot;, ReplaceWith(&quot;pauseDownload&quot;))&#10;    fun pause(request: DownloadRequest) {&#10;        pauseDownload(request.downloadId)&#10;    }&#10;&#10;    @Deprecated(&quot;Use resumeDownload(downloadId) instead&quot;, ReplaceWith(&quot;resumeDownload&quot;))&#10;    fun resume(request: DownloadRequest) {&#10;        resumeDownload(request.downloadId)&#10;    }&#10;}&#10;&#10;/**&#10; * Clean data class for download requests with validation and builder pattern&#10; */&#10;data class DownloadRequest(&#10;    val url: String,&#10;    val downloadId: Long,&#10;    val connectTimeOut: Long = TimeUnit.SECONDS.toMillis(30),&#10;    val downloadedBytes: Long = 0L,&#10;    val fileName: String = &quot;&quot;,&#10;    val requestState: RequestState = RequestState.None&#10;) {&#10;    class Builder {&#10;        private var url: String = &quot;&quot;&#10;        private var downloadId: Long = -1L&#10;        private var connectTimeOut: Long = TimeUnit.SECONDS.toMillis(30)&#10;        private var downloadedBytes: Long = 0L&#10;        private var fileName: String = &quot;&quot;&#10;        private var requestState: RequestState = RequestState.None&#10;&#10;        fun url(url: String) = apply {&#10;            this.url = url&#10;            this.fileName = URLUtil.guessFileName(url,null,null)&#10;        }&#10;        fun downloadId(id: Long) = apply { this.downloadId = id }&#10;        fun connectTimeOut(timeout: Long) = apply { this.connectTimeOut = timeout }&#10;        fun downloadedBytes(bytes: Long) = apply { this.downloadedBytes = bytes }&#10;        fun fileName(name: String) = apply { this.fileName = name }&#10;        fun requestState(state: RequestState) = apply { this.requestState = state }&#10;&#10;        fun build() = DownloadRequest(&#10;            url = url,&#10;            downloadId = downloadId,&#10;            connectTimeOut = connectTimeOut,&#10;            downloadedBytes = downloadedBytes,&#10;            fileName = fileName,&#10;            requestState = requestState&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Legacy enum for backward compatibility&#10; */&#10;enum class RequestState {&#10;    None,&#10;    Running,&#10;    Paused,&#10;    Cancelled,&#10;    Completed,&#10;    Failed&#10;}" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.webkit.URLUtil&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.util.concurrent.ConcurrentHashMap&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Clean implementation of firmware download manager with ContentProvider support&#10; * Manages multiple concurrent downloads with proper Android 14+ storage handling&#10; */&#10;class FirmwareManager private constructor() {&#10;&#10;    private val activeDownloads = ConcurrentHashMap&lt;Long, DownloadTask&gt;()&#10;    private val downloadScope = CoroutineScope(Dispatchers.IO)&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: FirmwareManager? = null&#10;&#10;        fun getInstance(): FirmwareManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: FirmwareManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startDownload(&#10;        context: Context,&#10;        request: DownloadRequest,&#10;        fileName: String,&#10;        listener: DownloadListener? = null&#10;    ): Long {&#10;        validateDownloadRequest(request, fileName)&#10;&#10;        if (isDownloadActive(request.downloadId)) {&#10;            throw IllegalStateException(&quot;Download with ID ${request.downloadId} is already active&quot;)&#10;        }&#10;&#10;        val downloadTask = createDownloadTask(context, request, fileName, listener)&#10;        activeDownloads[request.downloadId] = downloadTask&#10;&#10;        downloadScope.launch {&#10;            try {&#10;                downloadTask.startDownload()&#10;            } finally {&#10;                removeCompletedDownload(request.downloadId)&#10;            }&#10;        }&#10;&#10;        return request.downloadId&#10;    }&#10;&#10;    private fun validateDownloadRequest(request: DownloadRequest, fileName: String) {&#10;        require(request.url.isNotBlank()) { &quot;Download URL cannot be empty&quot; }&#10;        require(request.downloadId != -1L) { &quot;Invalid download ID&quot; }&#10;        require(fileName.isNotBlank()) { &quot;File name cannot be empty&quot; }&#10;    }&#10;&#10;    private fun createDownloadTask(&#10;        context: Context,&#10;        request: DownloadRequest,&#10;        fileName: String,&#10;        listener: DownloadListener?&#10;    ): DownloadTask {&#10;        return DownloadTask(context, request, fileName, listener)&#10;    }&#10;&#10;    fun pauseDownload(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.let { task -&gt;&#10;            task.pauseDownload()&#10;            true&#10;        } ?: false&#10;    }&#10;&#10;    fun resumeDownload(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.let { task -&gt;&#10;            task.resumeDownload()&#10;            true&#10;        } ?: false&#10;    }&#10;&#10;    fun cancelDownload(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.let { task -&gt;&#10;            task.cancelDownload()&#10;            activeDownloads.remove(downloadId)&#10;            true&#10;        } ?: false&#10;    }&#10;&#10;    fun cancelAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            task.cancelDownload()&#10;        }&#10;        activeDownloads.clear()&#10;    }&#10;&#10;    fun getDownloadState(downloadId: Long): DownloadState? {&#10;        return getDownloadTask(downloadId)?.getDownloadState()&#10;    }&#10;&#10;    fun getDownloadProgress(downloadId: Long): Long {&#10;        return getDownloadTask(downloadId)?.getCurrentProgress() ?: 0L&#10;    }&#10;&#10;    fun getDownloadFileUri(downloadId: Long): Uri? {&#10;        return getDownloadTask(downloadId)?.getOutputFileUri()&#10;    }&#10;&#10;    fun isDownloadActive(downloadId: Long): Boolean {&#10;        return getDownloadTask(downloadId)?.isActive() == true&#10;    }&#10;&#10;    fun getActiveDownloadIds(): Set&lt;Long&gt; {&#10;        return activeDownloads.keys.toSet()&#10;    }&#10;&#10;    fun getActiveDownloadCount(): Int = activeDownloads.size&#10;&#10;    private fun getDownloadTask(downloadId: Long): DownloadTask? {&#10;        return activeDownloads[downloadId]&#10;    }&#10;&#10;    private fun removeCompletedDownload(downloadId: Long) {&#10;        activeDownloads.remove(downloadId)&#10;    }&#10;&#10;    // Convenience methods for backward compatibility&#10;    @Deprecated(&quot;Use startDownload with DownloadListener instead&quot;, ReplaceWith(&quot;startDownload&quot;))&#10;    fun download(request: DownloadRequest, outputFile: File) {&#10;        startDownload(request, outputFile)&#10;    }&#10;&#10;    @Deprecated(&quot;Use cancelDownload(downloadId) instead&quot;, ReplaceWith(&quot;cancelDownload&quot;))&#10;    fun cancelRequest(request: DownloadRequest) {&#10;        cancelDownload(request.downloadId)&#10;    }&#10;&#10;    @Deprecated(&quot;Use pauseDownload(downloadId) instead&quot;, ReplaceWith(&quot;pauseDownload&quot;))&#10;    fun pause(request: DownloadRequest) {&#10;        pauseDownload(request.downloadId)&#10;    }&#10;&#10;    @Deprecated(&quot;Use resumeDownload(downloadId) instead&quot;, ReplaceWith(&quot;resumeDownload&quot;))&#10;    fun resume(request: DownloadRequest) {&#10;        resumeDownload(request.downloadId)&#10;    }&#10;}&#10;&#10;/**&#10; * Clean data class for download requests with validation and builder pattern&#10; */&#10;data class DownloadRequest(&#10;    val url: String,&#10;    val downloadId: Long,&#10;    val connectTimeOut: Long = TimeUnit.SECONDS.toMillis(30),&#10;    val downloadedBytes: Long = 0L,&#10;    val fileName: String = &quot;&quot;,&#10;    val requestState: RequestState = RequestState.None&#10;) {&#10;    class Builder {&#10;        private var url: String = &quot;&quot;&#10;        private var downloadId: Long = -1L&#10;        private var connectTimeOut: Long = TimeUnit.SECONDS.toMillis(30)&#10;        private var downloadedBytes: Long = 0L&#10;        private var fileName: String = &quot;&quot;&#10;        private var requestState: RequestState = RequestState.None&#10;&#10;        fun url(url: String) = apply {&#10;            this.url = url&#10;            this.fileName = URLUtil.guessFileName(url, null, null)&#10;        }&#10;        fun downloadId(id: Long) = apply { this.downloadId = id }&#10;        fun connectTimeOut(timeout: Long) = apply { this.connectTimeOut = timeout }&#10;        fun downloadedBytes(bytes: Long) = apply { this.downloadedBytes = bytes }&#10;        fun fileName(name: String) = apply { this.fileName = name }&#10;        fun requestState(state: RequestState) = apply { this.requestState = state }&#10;&#10;        fun build() = DownloadRequest(&#10;            url = url,&#10;            downloadId = downloadId,&#10;            connectTimeOut = connectTimeOut,&#10;            downloadedBytes = downloadedBytes,&#10;            fileName = fileName,&#10;            requestState = requestState&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Legacy enum for backward compatibility&#10; */&#10;enum class RequestState {&#10;    None,&#10;    Running,&#10;    Paused,&#10;    Cancelled,&#10;    Completed,&#10;    Failed&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/HttpConnectionManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/HttpConnectionManager.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.IOException&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.util.Locale&#10;&#10;/**&#10; * Manages HTTP connections for downloads with proper resource handling&#10; */&#10;class HttpConnectionManager(private val request: DownloadRequest) {&#10;    private var connection: HttpURLConnection? = null&#10;    &#10;    @Throws(IOException::class)&#10;    fun connect() {&#10;        disconnect() // Ensure clean state&#10;        &#10;        connection = createConnection().also { conn -&gt;&#10;            configureConnection(conn)&#10;            conn.connect()&#10;        }&#10;    }&#10;    &#10;    private fun createConnection(): HttpURLConnection {&#10;        return URL(request.url).openConnection() as HttpURLConnection&#10;    }&#10;    &#10;    private fun configureConnection(conn: HttpURLConnection) {&#10;        conn.connectTimeout = request.connectTimeOut.toInt()&#10;        conn.readTimeout = request.readTimeOut.toInt()&#10;        &#10;        if (request.downloadedBytes &gt; 0) {&#10;            val rangeHeader = String.format(&#10;                Locale.ENGLISH, &#10;                &quot;bytes=%d-&quot;, &#10;                request.downloadedBytes&#10;            )&#10;            conn.setRequestProperty(DownloadConstants.RANGE_HEADER, rangeHeader)&#10;        }&#10;    }&#10;    &#10;    fun getInputStream(): InputStream? = connection?.inputStream&#10;    &#10;    fun getResponseCode(): Int = connection?.responseCode ?: 0&#10;    &#10;    fun getContentLength(): Long = connection?.contentLengthLong ?: -1L&#10;    &#10;    fun getETag(): String? = connection?.getHeaderField(DownloadConstants.ETAG_HEADER)&#10;    &#10;    fun isValidResponse(): Boolean {&#10;        val responseCode = getResponseCode()&#10;        return responseCode == DownloadConstants.HTTP_OK || &#10;               responseCode == DownloadConstants.HTTP_PARTIAL_CONTENT&#10;    }&#10;    &#10;    fun disconnect() {&#10;        connection?.disconnect()&#10;        connection = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/MainActivity.kt" />
              <option name="originalContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.lifecycleScope&#10;import com.marusys.upgradefirmware.database.DownloadDatabase&#10;import com.marusys.upgradefirmware.database.DownloadEntity&#10;import com.marusys.upgradefirmware.ui.theme.UpgradeFirmwareTheme&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var downloadManager: DownloadingManager&#10;    private var currentDownloadId: String? = null&#10;&#10;    // State flows for UI&#10;    private val _downloadState = MutableStateFlow(DownloadUIState())&#10;    private val downloadState: StateFlow&lt;DownloadUIState&gt; = _downloadState&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        initDownloadManager()&#10;&#10;        setContent {&#10;            UpgradeFirmwareTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    DownloadScreen(&#10;                        downloadState = downloadState.collectAsState().value,&#10;                        onStartDownload = { url, md5 -&gt; startDownload(url, md5) },&#10;                        onPauseDownload = { pauseDownload() },&#10;                        onResumeDownload = { resumeDownload() },&#10;                        onCancelDownload = { cancelDownload() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Kiểm tra downloads chưa hoàn thành&#10;        checkIncompleteDownloads()&#10;    }&#10;&#10;    private fun initDownloadManager() {&#10;        downloadManager = DownloadingManager.getInstance()&#10;    }&#10;&#10;    private fun startDownload(url: String, md5: String?) {&#10;        if (url.isBlank()) {&#10;            updateUIState { it.copy(statusMessage = &quot;Vui lòng nhập URL&quot;) }&#10;            return&#10;        }&#10;&#10;        updateUIState {&#10;            it.copy(&#10;                isDownloading = true,&#10;                statusMessage = &quot;Đang bắt đầu download...&quot;,&#10;                buttonsEnabled = it.buttonsEnabled.copy(&#10;                    startEnabled = false,&#10;                    pauseEnabled = true,&#10;                    cancelEnabled = true&#10;                )&#10;            )&#10;        }&#10;&#10;        downloadManager.startDownloading(url, md5?.ifBlank { null })&#10;    }&#10;&#10;    private fun pauseDownload() {&#10;        downloadManager.pauseDownload()&#10;        updateUIState {&#10;            it.copy(&#10;                isPaused = true,&#10;                statusMessage = &quot;Download đã tạm dừng&quot;,&#10;                buttonsEnabled = it.buttonsEnabled.copy(&#10;                    pauseEnabled = false,&#10;                    resumeEnabled = true&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun resumeDownload() {&#10;        currentDownloadId?.let { id -&gt;&#10;            downloadManager.resumeDownload(id)&#10;            updateUIState {&#10;                it.copy(&#10;                    isPaused = false,&#10;                    isDownloading = true,&#10;                    statusMessage = &quot;Đang tiếp tục download...&quot;,&#10;                    buttonsEnabled = it.buttonsEnabled.copy(&#10;                        pauseEnabled = true,&#10;                        resumeEnabled = false&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun cancelDownload() {&#10;        downloadManager.cancelDownload()&#10;        updateUIState {&#10;            DownloadUIState().copy(&#10;                statusMessage = &quot;Download đã hủy&quot;,&#10;                url = it.url,&#10;                md5 = it.md5&#10;            )&#10;        }&#10;        currentDownloadId = null&#10;    }&#10;&#10;    private fun checkIncompleteDownloads() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val database = DownloadDatabase.getDatabase(this@MainActivity)&#10;                val incompleteDownloads = database.downloadDao().getIncompleteDownloads()&#10;&#10;                if (incompleteDownloads.isNotEmpty()) {&#10;                    val download = incompleteDownloads.first()&#10;                    currentDownloadId = download.downloadId&#10;&#10;                    updateUIState {&#10;                        it.copy(&#10;                            statusMessage = &quot;Tìm thấy download chưa hoàn thành: ${download.fileName}&quot;,&#10;                            progress = if (download.totalBytes &gt; 0)&#10;                                ((download.downloadedBytes * 100) / download.totalBytes).toInt()&#10;                                else 0,&#10;                            downloadedBytes = download.downloadedBytes,&#10;                            totalBytes = download.totalBytes,&#10;                            buttonsEnabled = it.buttonsEnabled.copy(&#10;                                resumeEnabled = true,&#10;                                cancelEnabled = true&#10;                            ),&#10;                            hasIncompleteDownload = true&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                updateUIState { it.copy(statusMessage = &quot;Lỗi khi tải downloads: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUIState(update: (DownloadUIState) -&gt; DownloadUIState) {&#10;        _downloadState.value = update(_downloadState.value)&#10;    }&#10;}&#10;&#10;// Data class để quản lý UI state&#10;data class DownloadUIState(&#10;    val url: String = &quot;https://hmxhamsstorage.blob.core.windows.net/firmwares/13/Firmware01_1.4.0.bin&quot;,&#10;    val md5: String = &quot;b7fc994a59bdd9d9d6618af810147639&quot;,&#10;    val progress: Int = 0,&#10;    val downloadedBytes: Long = 0L,&#10;    val totalBytes: Long = 0L,&#10;    val statusMessage: String = &quot;Sẵn sàng download&quot;,&#10;    val isDownloading: Boolean = false,&#10;    val isPaused: Boolean = false,&#10;    val hasIncompleteDownload: Boolean = false,&#10;    val buttonsEnabled: ButtonsState = ButtonsState()&#10;)&#10;&#10;data class ButtonsState(&#10;    val startEnabled: Boolean = true,&#10;    val pauseEnabled: Boolean = false,&#10;    val resumeEnabled: Boolean = false,&#10;    val cancelEnabled: Boolean = false&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DownloadScreen(&#10;    downloadState: DownloadUIState,&#10;    onStartDownload: (String, String) -&gt; Unit,&#10;    onPauseDownload: () -&gt; Unit,&#10;    onResumeDownload: () -&gt; Unit,&#10;    onCancelDownload: () -&gt; Unit&#10;) {&#10;    var urlText by remember { mutableStateOf(downloadState.url) }&#10;    var md5Text by remember { mutableStateOf(downloadState.md5) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;Download Manager&quot;,&#10;            fontSize = 28.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        Divider()&#10;&#10;        // URL Input&#10;        OutlinedTextField(&#10;            value = urlText,&#10;            onValueChange = { urlText = it },&#10;            label = { Text(&quot;Download URL&quot;) },&#10;            placeholder = { Text(&quot;Nhập URL để download&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Uri),&#10;            singleLine = true&#10;        )&#10;&#10;        // MD5 Input&#10;        OutlinedTextField(&#10;            value = md5Text,&#10;            onValueChange = { md5Text = it },&#10;            label = { Text(&quot;MD5 Checksum (Tùy chọn)&quot;) },&#10;            placeholder = { Text(&quot;Nhập MD5 để verify&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true&#10;        )&#10;&#10;        // Control Buttons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Button(&#10;                onClick = { onStartDownload(urlText, md5Text) },&#10;                enabled = downloadState.buttonsEnabled.startEnabled,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Bắt đầu&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = onPauseDownload,&#10;                enabled = downloadState.buttonsEnabled.pauseEnabled,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Tạm dừng&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = onResumeDownload,&#10;                enabled = downloadState.buttonsEnabled.resumeEnabled,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Tiếp tục&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = onCancelDownload,&#10;                enabled = downloadState.buttonsEnabled.cancelEnabled,&#10;                modifier = Modifier.weight(1f),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error&#10;                )&#10;            ) {&#10;                Text(&quot;Hủy&quot;)&#10;            }&#10;        }&#10;&#10;        // Status&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Trạng thái&quot;,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 16.sp&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(text = downloadState.statusMessage)&#10;            }&#10;        }&#10;&#10;        // Progress&#10;        if (downloadState.progress &gt; 0 || downloadState.isDownloading) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Tiến độ&quot;,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                        Text(&#10;                            text = &quot;${downloadState.progress}%&quot;,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    LinearProgressIndicator(&#10;                        progress = downloadState.progress / 100f,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;${formatBytes(downloadState.downloadedBytes)} / ${formatBytes(downloadState.totalBytes)}&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Features Info&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.primaryContainer&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot; Tính năng&quot;,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 16.sp&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                val features = listOf(&#10;                    &quot;• Resume download sau khi tắt app&quot;,&#10;                    &quot;• Tự động tiếp tục khi có mạng&quot;,&#10;                    &quot;• Kiểm tra MD5 checksum&quot;,&#10;                    &quot;• Lưu tiến độ vào database&quot;,&#10;                    &quot;• Hỗ trợ HTTP Range requests&quot;&#10;                )&#10;&#10;                features.forEach { feature -&gt;&#10;                    Text(&#10;                        text = feature,&#10;                        fontSize = 14.sp,&#10;                        modifier = Modifier.padding(vertical = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (downloadState.hasIncompleteDownload) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot; Lưu ý&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 16.sp&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Có download chưa hoàn thành. Nhấn 'Tiếp tục' để resume từ vị trí đã dừng.&quot;,&#10;                        fontSize = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatBytes(bytes: Long): String {&#10;    return when {&#10;        bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;%.1f GB&quot;.format(bytes / (1024f * 1024f * 1024f))&#10;        bytes &gt;= 1024 * 1024 -&gt; &quot;%.1f MB&quot;.format(bytes / (1024f * 1024f))&#10;        bytes &gt;= 1024 -&gt; &quot;%.1f KB&quot;.format(bytes / 1024f)&#10;        else -&gt; &quot;$bytes B&quot;&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DownloadScreenPreview() {&#10;    UpgradeFirmwareTheme {&#10;        DownloadScreen(&#10;            downloadState = DownloadUIState(&#10;                progress = 45,&#10;                downloadedBytes = 45 * 1024 * 1024,&#10;                totalBytes = 100 * 1024 * 1024,&#10;                statusMessage = &quot;Đang download...&quot;,&#10;                isDownloading = true&#10;            ),&#10;            onStartDownload = { _, _ -&gt; },&#10;            onPauseDownload = { },&#10;            onResumeDownload = { },&#10;            onCancelDownload = { }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.lifecycleScope&#10;import com.marusys.upgradefirmware.database.DownloadDatabase&#10;import com.marusys.upgradefirmware.database.DownloadEntity&#10;import com.marusys.upgradefirmware.ui.theme.UpgradeFirmwareTheme&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private lateinit var downloadManager: DownloadingManager&#10;    private var currentDownloadId: String? = null&#10;&#10;    // State flows for UI&#10;    private val _downloadState = MutableStateFlow(DownloadUIState())&#10;    private val downloadState: StateFlow&lt;DownloadUIState&gt; = _downloadState&#10;&#10;    // Progress callback để nhận updates từ DownloadingManager&#10;    private val downloadProgressCallback = object : DownloadProgressCallback {&#10;        override fun onProgressUpdate(downloadId: String, downloaded: Long, total: Long, speed: String) {&#10;            runOnUiThread {&#10;                updateUIState {&#10;                    it.copy(&#10;                        downloadedBytes = downloaded,&#10;                        totalBytes = total,&#10;                        progress = if (total &gt; 0) ((downloaded * 100) / total).toInt() else 0,&#10;                        statusMessage = &quot;Đang download... $speed&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onDownloadStateChanged(downloadId: String, state: Int) {&#10;            runOnUiThread {&#10;                when (state) {&#10;                    DownloadEntity.STATUS_DOWNLOADING -&gt; {&#10;                        updateUIState {&#10;                            it.copy(&#10;                                isDownloading = true,&#10;                                isPaused = false,&#10;                                statusMessage = &quot;Đang download...&quot;,&#10;                                buttonsEnabled = it.buttonsEnabled.copy(&#10;                                    startEnabled = false,&#10;                                    pauseEnabled = true,&#10;                                    resumeEnabled = false,&#10;                                    cancelEnabled = true&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    DownloadEntity.STATUS_PAUSED -&gt; {&#10;                        updateUIState {&#10;                            it.copy(&#10;                                isPaused = true,&#10;                                isDownloading = false,&#10;                                statusMessage = &quot;Download đã tạm dừng&quot;,&#10;                                buttonsEnabled = it.buttonsEnabled.copy(&#10;                                    pauseEnabled = false,&#10;                                    resumeEnabled = true&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    DownloadEntity.STATUS_COMPLETED -&gt; {&#10;                        updateUIState {&#10;                            it.copy(&#10;                                isDownloading = false,&#10;                                statusMessage = &quot;Download hoàn thành!&quot;,&#10;                                progress = 100,&#10;                                buttonsEnabled = ButtonsState()&#10;                            )&#10;                        }&#10;                    }&#10;                    DownloadEntity.STATUS_FAILED -&gt; {&#10;                        updateUIState {&#10;                            it.copy(&#10;                                isDownloading = false,&#10;                                statusMessage = &quot;Download thất bại&quot;,&#10;                                buttonsEnabled = ButtonsState().copy(startEnabled = true)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onNetworkReconnected(downloadId: String) {&#10;            runOnUiThread {&#10;                updateUIState {&#10;                    it.copy(&#10;                        statusMessage = &quot; Mạng đã kết nối lại - Tự động tiếp tục download...&quot;,&#10;                        isDownloading = true,&#10;                        isPaused = false,&#10;                        buttonsEnabled = it.buttonsEnabled.copy(&#10;                            pauseEnabled = true,&#10;                            resumeEnabled = false&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        override fun onNetworkLost(downloadId: String) {&#10;            runOnUiThread {&#10;                updateUIState {&#10;                    it.copy(&#10;                        statusMessage = &quot; Mất kết nối mạng - Download tạm dừng&quot;,&#10;                        isPaused = true,&#10;                        isDownloading = false&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        initDownloadManager()&#10;&#10;        setContent {&#10;            UpgradeFirmwareTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    DownloadScreen(&#10;                        downloadState = downloadState.collectAsState().value,&#10;                        onStartDownload = { url, md5 -&gt; startDownload(url, md5) },&#10;                        onPauseDownload = { pauseDownload() },&#10;                        onResumeDownload = { resumeDownload() },&#10;                        onCancelDownload = { cancelDownload() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Kiểm tra downloads ch��a hoàn thành&#10;        checkIncompleteDownloads()&#10;    }&#10;&#10;    private fun initDownloadManager() {&#10;        downloadManager = DownloadingManager.getInstance()&#10;    }&#10;&#10;    private fun startDownload(url: String, md5: String?) {&#10;        if (url.isBlank()) {&#10;            updateUIState { it.copy(statusMessage = &quot;Vui lòng nhập URL&quot;) }&#10;            return&#10;        }&#10;&#10;        updateUIState {&#10;            it.copy(&#10;                isDownloading = true,&#10;                statusMessage = &quot;Đang bắt đầu download...&quot;,&#10;                buttonsEnabled = it.buttonsEnabled.copy(&#10;                    startEnabled = false,&#10;                    pauseEnabled = true,&#10;                    cancelEnabled = true&#10;                )&#10;            )&#10;        }&#10;&#10;        downloadManager.startDownloading(url, md5?.ifBlank { null })&#10;    }&#10;&#10;    private fun pauseDownload() {&#10;        downloadManager.pauseDownload()&#10;        updateUIState {&#10;            it.copy(&#10;                isPaused = true,&#10;                statusMessage = &quot;Download đã tạm dừng&quot;,&#10;                buttonsEnabled = it.buttonsEnabled.copy(&#10;                    pauseEnabled = false,&#10;                    resumeEnabled = true&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun resumeDownload() {&#10;        currentDownloadId?.let { id -&gt;&#10;            downloadManager.resumeDownload(id)&#10;            updateUIState {&#10;                it.copy(&#10;                    isPaused = false,&#10;                    isDownloading = true,&#10;                    statusMessage = &quot;Đang tiếp tục download...&quot;,&#10;                    buttonsEnabled = it.buttonsEnabled.copy(&#10;                        pauseEnabled = true,&#10;                        resumeEnabled = false&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun cancelDownload() {&#10;        downloadManager.cancelDownload()&#10;        updateUIState {&#10;            DownloadUIState().copy(&#10;                statusMessage = &quot;Download đã hủy&quot;,&#10;                url = it.url,&#10;                md5 = it.md5&#10;            )&#10;        }&#10;        currentDownloadId = null&#10;    }&#10;&#10;    private fun checkIncompleteDownloads() {&#10;        lifecycleScope.launch {&#10;            try {&#10;                val database = DownloadDatabase.getDatabase(this@MainActivity)&#10;                val incompleteDownloads = database.downloadDao().getIncompleteDownloads()&#10;&#10;                if (incompleteDownloads.isNotEmpty()) {&#10;                    val download = incompleteDownloads.first()&#10;                    currentDownloadId = download.downloadId&#10;&#10;                    updateUIState {&#10;                        it.copy(&#10;                            statusMessage = &quot;Tìm thấy download chưa hoàn thành: ${download.fileName}&quot;,&#10;                            progress = if (download.totalBytes &gt; 0)&#10;                                ((download.downloadedBytes * 100) / download.totalBytes).toInt()&#10;                                else 0,&#10;                            downloadedBytes = download.downloadedBytes,&#10;                            totalBytes = download.totalBytes,&#10;                            buttonsEnabled = it.buttonsEnabled.copy(&#10;                                resumeEnabled = true,&#10;                                cancelEnabled = true&#10;                            ),&#10;                            hasIncompleteDownload = true&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                updateUIState { it.copy(statusMessage = &quot;Lỗi khi tải downloads: ${e.message}&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateUIState(update: (DownloadUIState) -&gt; DownloadUIState) {&#10;        _downloadState.value = update(_downloadState.value)&#10;    }&#10;}&#10;&#10;// Data class để quản lý UI state&#10;data class DownloadUIState(&#10;    val url: String = &quot;https://hmxhamsstorage.blob.core.windows.net/firmwares/13/Firmware01_1.4.0.bin&quot;,&#10;    val md5: String = &quot;b7fc994a59bdd9d9d6618af810147639&quot;,&#10;    val progress: Int = 0,&#10;    val downloadedBytes: Long = 0L,&#10;    val totalBytes: Long = 0L,&#10;    val statusMessage: String = &quot;Sẵn sàng download&quot;,&#10;    val isDownloading: Boolean = false,&#10;    val isPaused: Boolean = false,&#10;    val hasIncompleteDownload: Boolean = false,&#10;    val buttonsEnabled: ButtonsState = ButtonsState()&#10;)&#10;&#10;data class ButtonsState(&#10;    val startEnabled: Boolean = true,&#10;    val pauseEnabled: Boolean = false,&#10;    val resumeEnabled: Boolean = false,&#10;    val cancelEnabled: Boolean = false&#10;)&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun DownloadScreen(&#10;    downloadState: DownloadUIState,&#10;    onStartDownload: (String, String) -&gt; Unit,&#10;    onPauseDownload: () -&gt; Unit,&#10;    onResumeDownload: () -&gt; Unit,&#10;    onCancelDownload: () -&gt; Unit&#10;) {&#10;    var urlText by remember { mutableStateOf(downloadState.url) }&#10;    var md5Text by remember { mutableStateOf(downloadState.md5) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;Download Manager&quot;,&#10;            fontSize = 28.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        Divider()&#10;&#10;        // URL Input&#10;        OutlinedTextField(&#10;            value = urlText,&#10;            onValueChange = { urlText = it },&#10;            label = { Text(&quot;Download URL&quot;) },&#10;            placeholder = { Text(&quot;Nhập URL để download&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Uri),&#10;            singleLine = true&#10;        )&#10;&#10;        // MD5 Input&#10;        OutlinedTextField(&#10;            value = md5Text,&#10;            onValueChange = { md5Text = it },&#10;            label = { Text(&quot;MD5 Checksum (Tùy chọn)&quot;) },&#10;            placeholder = { Text(&quot;Nhập MD5 để verify&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            singleLine = true&#10;        )&#10;&#10;        // Control Buttons&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            Button(&#10;                onClick = { onStartDownload(urlText, md5Text) },&#10;                enabled = downloadState.buttonsEnabled.startEnabled,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Bắt đầu&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = onPauseDownload,&#10;                enabled = downloadState.buttonsEnabled.pauseEnabled,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Tạm dừng&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = onResumeDownload,&#10;                enabled = downloadState.buttonsEnabled.resumeEnabled,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&quot;Tiếp tục&quot;)&#10;            }&#10;&#10;            Button(&#10;                onClick = onCancelDownload,&#10;                enabled = downloadState.buttonsEnabled.cancelEnabled,&#10;                modifier = Modifier.weight(1f),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error&#10;                )&#10;            ) {&#10;                Text(&quot;Hủy&quot;)&#10;            }&#10;        }&#10;&#10;        // Status&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Trạng thái&quot;,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 16.sp&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(text = downloadState.statusMessage)&#10;            }&#10;        }&#10;&#10;        // Progress&#10;        if (downloadState.progress &gt; 0 || downloadState.isDownloading) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp)&#10;                ) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Tiến độ&quot;,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                        Text(&#10;                            text = &quot;${downloadState.progress}%&quot;,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    LinearProgressIndicator(&#10;                        progress = downloadState.progress / 100f,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = &quot;${formatBytes(downloadState.downloadedBytes)} / ${formatBytes(downloadState.totalBytes)}&quot;,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Features Info&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.primaryContainer&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot; Tính năng&quot;,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 16.sp&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                val features = listOf(&#10;                    &quot;• Resume download sau khi tắt app&quot;,&#10;                    &quot;• Tự động tiếp tục khi có mạng&quot;,&#10;                    &quot;• Kiểm tra MD5 checksum&quot;,&#10;                    &quot;• Lưu tiến độ vào database&quot;,&#10;                    &quot;• Hỗ trợ HTTP Range requests&quot;&#10;                )&#10;&#10;                features.forEach { feature -&gt;&#10;                    Text(&#10;                        text = feature,&#10;                        fontSize = 14.sp,&#10;                        modifier = Modifier.padding(vertical = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (downloadState.hasIncompleteDownload) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot; Lưu ý&quot;,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 16.sp&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;Có download chưa hoàn thành. Nhấn 'Tiếp tục' để resume từ vị trí đã dừng.&quot;,&#10;                        fontSize = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatBytes(bytes: Long): String {&#10;    return when {&#10;        bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;%.1f GB&quot;.format(bytes / (1024f * 1024f * 1024f))&#10;        bytes &gt;= 1024 * 1024 -&gt; &quot;%.1f MB&quot;.format(bytes / (1024f * 1024f))&#10;        bytes &gt;= 1024 -&gt; &quot;%.1f KB&quot;.format(bytes / 1024f)&#10;        else -&gt; &quot;$bytes B&quot;&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DownloadScreenPreview() {&#10;    UpgradeFirmwareTheme {&#10;        DownloadScreen(&#10;            downloadState = DownloadUIState(&#10;                progress = 45,&#10;                downloadedBytes = 45 * 1024 * 1024,&#10;                totalBytes = 100 * 1024 * 1024,&#10;                statusMessage = &quot;Đang download...&quot;,&#10;                isDownloading = true&#10;            ),&#10;            onStartDownload = { _, _ -&gt; },&#10;            onPauseDownload = { },&#10;            onResumeDownload = { },&#10;            onCancelDownload = { }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/Utils.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/Utils.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.File&#10;&#10;object Utils {&#10;    &#10;    fun getPath(dirPath: String?, fileName: String?): String {&#10;        return dirPath + File.separator + fileName&#10;    }&#10;    &#10;    fun renameFileName(oldPath: String, newPath: String): Boolean {&#10;        return try {&#10;            val oldFile = File(oldPath)&#10;            val newFile = File(newPath)&#10;            &#10;            if (oldFile.exists()) {&#10;                oldFile.renameTo(newFile)&#10;            } else {&#10;                false&#10;            }&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadDao.kt" />
              <option name="originalContent" value="&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface DownloadDao {&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertDownload(download: DownloadEntity)&#10;    &#10;    @Update&#10;    suspend fun updateDownload(download: DownloadEntity)&#10;    &#10;    @Query(&quot;UPDATE downloads SET downloadedBytes = :downloadedBytes, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateProgress(downloadId: String, downloadedBytes: Long, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE downloads SET status = :status, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateStatus(downloadId: String, status: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE downloads SET totalBytes = :totalBytes WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateTotalBytes(downloadId: String, totalBytes: Long)&#10;    &#10;    @Query(&quot;UPDATE downloads SET errorMessage = :error WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateError(downloadId: String, error: String?)&#10;    &#10;    @Query(&quot;SELECT * FROM downloads WHERE downloadId = :downloadId&quot;)&#10;    suspend fun getDownloadById(downloadId: String): DownloadEntity?&#10;    &#10;    @Query(&quot;SELECT * FROM downloads WHERE status IN (0, 1, 2) ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getIncompleteDownloads(): List&lt;DownloadEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM downloads ORDER BY updatedAt DESC&quot;)&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DownloadEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM downloads WHERE downloadId = :downloadId&quot;)&#10;    fun getDownloadFlow(downloadId: String): Flow&lt;DownloadEntity?&gt;&#10;    &#10;    @Delete&#10;    suspend fun deleteDownload(download: DownloadEntity)&#10;    &#10;    @Query(&quot;DELETE FROM downloads WHERE downloadId = :downloadId&quot;)&#10;    suspend fun deleteDownloadById(downloadId: String)&#10;    &#10;    @Query(&quot;DELETE FROM downloads WHERE status = 3 AND updatedAt &lt; :beforeTime&quot;)&#10;    suspend fun deleteOldCompletedDownloads(beforeTime: Long)&#10;}" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.database&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface DownloadDao {&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertDownload(download: DownloadEntity)&#10;    &#10;    @Update&#10;    suspend fun updateDownload(download: DownloadEntity)&#10;    &#10;    @Query(&quot;UPDATE downloads SET downloadedBytes = :downloadedBytes, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateProgress(downloadId: String, downloadedBytes: Long, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE downloads SET status = :status, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateStatus(downloadId: String, status: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE downloads SET totalBytes = :totalBytes WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateTotalBytes(downloadId: String, totalBytes: Long)&#10;    &#10;    @Query(&quot;UPDATE downloads SET errorMessage = :error WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateError(downloadId: String, error: String?)&#10;    &#10;    @Query(&quot;SELECT * FROM downloads WHERE downloadId = :downloadId&quot;)&#10;    suspend fun getDownloadById(downloadId: String): DownloadEntity?&#10;    &#10;    @Query(&quot;SELECT * FROM downloads WHERE status IN (0, 1, 2) ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getIncompleteDownloads(): List&lt;DownloadEntity&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM downloads ORDER BY updatedAt DESC&quot;)&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DownloadEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM downloads WHERE downloadId = :downloadId&quot;)&#10;    fun getDownloadFlow(downloadId: String): Flow&lt;DownloadEntity?&gt;&#10;    &#10;    @Delete&#10;    suspend fun deleteDownload(download: DownloadEntity)&#10;    &#10;    @Query(&quot;DELETE FROM downloads WHERE downloadId = :downloadId&quot;)&#10;    suspend fun deleteDownloadById(downloadId: String)&#10;    &#10;    @Query(&quot;DELETE FROM downloads WHERE status = 3 AND updatedAt &lt; :beforeTime&quot;)&#10;    suspend fun deleteOldCompletedDownloads(beforeTime: Long)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadDatabase.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [DownloadEntity::class],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;abstract class DownloadDatabase : RoomDatabase() {&#10;    &#10;    abstract fun downloadDao(): DownloadDao&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadDatabase? = null&#10;        &#10;        fun getDatabase(context: Context): DownloadDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    DownloadDatabase::class.java,&#10;                    &quot;download_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadEntity.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.database&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;downloads&quot;)&#10;data class DownloadEntity(&#10;    @PrimaryKey&#10;    val downloadId: String,&#10;    val url: String,&#10;    val fileName: String,&#10;    val filePath: String,&#10;    val tempPath: String,&#10;    val downloadedBytes: Long = 0L,&#10;    val totalBytes: Long = 0L,&#10;    val status: Int = STATUS_PENDING, // 0: pending, 1: downloading, 2: paused, 3: completed, 4: failed, 5: cancelled&#10;    val expectedMD5: String? = null,&#10;    val createdAt: Long = System.currentTimeMillis(),&#10;    val updatedAt: Long = System.currentTimeMillis(),&#10;    val errorMessage: String? = null&#10;) {&#10;    companion object {&#10;        const val STATUS_PENDING = 0&#10;        const val STATUS_DOWNLOADING = 1&#10;        const val STATUS_PAUSED = 2&#10;        const val STATUS_COMPLETED = 3&#10;        const val STATUS_FAILED = 4&#10;        const val STATUS_CANCELLED = 5&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/network/NetworkStateReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/network/NetworkStateReceiver.kt" />
              <option name="originalContent" value="&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.util.Log&#10;&#10;class NetworkStateReceiver : BroadcastReceiver() {&#10;    &#10;    private val TAG = &quot;NetworkStateReceiver&quot;&#10;    &#10;    interface NetworkStateListener {&#10;        fun onNetworkAvailable()&#10;        fun onNetworkLost()&#10;    }&#10;    &#10;    companion object {&#10;        var listeners = mutableSetOf&lt;NetworkStateListener&gt;()&#10;        &#10;        fun addListener(listener: NetworkStateListener) {&#10;            listeners.add(listener)&#10;        }&#10;        &#10;        fun removeListener(listener: NetworkStateListener) {&#10;            listeners.remove(listener)&#10;        }&#10;    }&#10;    &#10;    override fun onReceive(context: Context?, intent: Intent?) {&#10;        if (context == null) return&#10;        &#10;        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;        val isConnected = isNetworkAvailable(connectivityManager)&#10;        &#10;        Log.d(TAG, &quot;Network state changed: connected = $isConnected&quot;)&#10;        &#10;        if (isConnected) {&#10;            listeners.forEach { it.onNetworkAvailable() }&#10;        } else {&#10;            listeners.forEach { it.onNetworkLost() }&#10;        }&#10;    }&#10;    &#10;    private fun isNetworkAvailable(connectivityManager: ConnectivityManager): Boolean {&#10;        val network = connectivityManager.activeNetwork ?: return false&#10;        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false&#10;        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.network&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.util.Log&#10;&#10;class NetworkStateReceiver : BroadcastReceiver() {&#10;    &#10;    private val TAG = &quot;NetworkStateReceiver&quot;&#10;    &#10;    interface NetworkStateListener {&#10;        fun onNetworkAvailable()&#10;        fun onNetworkLost()&#10;    }&#10;    &#10;    companion object {&#10;        var listeners = mutableSetOf&lt;NetworkStateListener&gt;()&#10;        &#10;        fun addListener(listener: NetworkStateListener) {&#10;            listeners.add(listener)&#10;        }&#10;        &#10;        fun removeListener(listener: NetworkStateListener) {&#10;            listeners.remove(listener)&#10;        }&#10;    }&#10;    &#10;    override fun onReceive(context: Context?, intent: Intent?) {&#10;        if (context == null) return&#10;        &#10;        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;        val isConnected = isNetworkAvailable(connectivityManager)&#10;        &#10;        Log.d(TAG, &quot;Network state changed: connected = $isConnected&quot;)&#10;        &#10;        if (isConnected) {&#10;            listeners.forEach { it.onNetworkAvailable() }&#10;        } else {&#10;            listeners.forEach { it.onNetworkLost() }&#10;        }&#10;    }&#10;    &#10;    private fun isNetworkAvailable(connectivityManager: ConnectivityManager): Boolean {&#10;        val network = connectivityManager.activeNetwork ?: return false&#10;        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false&#10;        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Color.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;// Custom colors for download app&#10;val DownloadBlue = Color(0xFF2196F3)&#10;val DownloadGreen = Color(0xFF4CAF50)&#10;val DownloadRed = Color(0xFFFF5722)&#10;val DownloadOrange = Color(0xFFFF9800)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Theme.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.ui.theme&#10;&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.platform.LocalContext&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80,&#10;    error = DownloadRed,&#10;    primaryContainer = DownloadBlue,&#10;    secondaryContainer = DownloadGreen&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40,&#10;    error = DownloadRed,&#10;    primaryContainer = DownloadBlue.copy(alpha = 0.1f),&#10;    secondaryContainer = DownloadGreen.copy(alpha = 0.1f)&#10;)&#10;&#10;@Composable&#10;fun UpgradeFirmwareTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    // Dynamic color is available on Android 12+&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Type.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Type.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.ui.theme&#10;&#10;import androidx.compose.material3.Typography&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.sp&#10;&#10;// Set of Material typography styles to start with&#10;val Typography = Typography(&#10;    bodyLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Normal,&#10;        fontSize = 16.sp,&#10;        lineHeight = 24.sp,&#10;        letterSpacing = 0.5.sp&#10;    ),&#10;    titleLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Bold,&#10;        fontSize = 22.sp,&#10;        lineHeight = 28.sp,&#10;        letterSpacing = 0.sp&#10;    ),&#10;    labelSmall = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Medium,&#10;        fontSize = 11.sp,&#10;        lineHeight = 16.sp,&#10;        letterSpacing = 0.5.sp&#10;    )&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_main.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Download Manager&quot;&#10;        android:textSize=&quot;24sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginBottom=&quot;24dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Download URL:&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;EditText&#10;        android:id=&quot;@+id/etUrl&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:hint=&quot;Enter download URL&quot;&#10;        android:inputType=&quot;textUri&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Expected MD5 (Optional):&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;EditText&#10;        android:id=&quot;@+id/etMd5&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:hint=&quot;Enter MD5 checksum&quot;&#10;        android:inputType=&quot;text&quot;&#10;        android:layout_marginBottom=&quot;24dp&quot; /&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/btnStart&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Start&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/btnPause&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Pause&quot;&#10;            android:enabled=&quot;false&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/btnResume&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Resume&quot;&#10;            android:enabled=&quot;false&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/btnCancel&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Cancel&quot;&#10;            android:enabled=&quot;false&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvStatus&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Ready to download&quot;&#10;        android:textSize=&quot;16sp&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;ProgressBar&#10;        android:id=&quot;@+id/progressBar&quot;&#10;        style=&quot;?android:attr/progressBarStyleHorizontal&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:max=&quot;100&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvProgress&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;0%&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:gravity=&quot;center&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot; Features:\n• Resume downloads after app restart\n• Auto-resume when network reconnects\n• MD5 verification\n• Progress saved to database&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:layout_marginTop=&quot;24dp&quot;&#10;        android:padding=&quot;16dp&quot;&#10;        android:background=&quot;#f0f0f0&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>