<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/Constants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/Constants.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import java.util.concurrent.TimeUnit&#10;&#10;object Constants {&#10;    const val RANGE_HEADER = &quot;Range&quot;&#10;    const val ETAG_HEADER = &quot;ETag&quot;&#10;    val CONNECT_TIMEOUT = TimeUnit.SECONDS.toSeconds(60)&#10;    const val HTTP_OK = 200&#10;    const val HTTP_PARTIAL_CONTENT = 206&#10;&#10;    // Download States&#10;    const val STATE_IDLE = 0&#10;    const val STATE_DOWNLOADING = 1&#10;    const val STATE_PAUSED = 2&#10;    const val STATE_COMPLETED = 3&#10;    const val STATE_FAILED = 4&#10;    const val STATE_CANCELLED = 5&#10;    const val STATE_WAITING_FOR_NETWORK = 6&#10;&#10;    // Buffer and retry settings&#10;    const val BUFFER_SIZE = 8192&#10;    const val MAX_RETRY_ATTEMPTS = 3&#10;    const val RETRY_DELAY_MS = 2000L&#10;    const val NETWORK_CHECK_INTERVAL_MS = 1000L&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import java.util.concurrent.TimeUnit&#10;&#10;object Constants {&#10;    const val RANGE_HEADER = &quot;Range&quot;&#10;    const val ETAG_HEADER = &quot;ETag&quot;&#10;    val CONNECT_TIMEOUT = TimeUnit.SECONDS.toSeconds(60)&#10;    const val HTTP_OK = 200&#10;    const val HTTP_PARTIAL_CONTENT = 206&#10;&#10;    // Download States&#10;    const val STATE_IDLE = 0&#10;    const val STATE_DOWNLOADING = 1&#10;    const val STATE_PAUSED = 2&#10;    const val STATE_COMPLETED = 3&#10;    const val STATE_FAILED = 4&#10;    const val STATE_CANCELLED = 5&#10;    const val STATE_WAITING_FOR_NETWORK = 6&#10;&#10;    // Buffer and retry settings&#10;    const val BUFFER_SIZE = 8192&#10;    const val MAX_RETRY_ATTEMPTS = 3&#10;    const val RETRY_DELAY_MS = 2000L&#10;    const val NETWORK_CHECK_INTERVAL_MS = 1000L&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadController.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadController.kt" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;/**&#10; * Interface for download operations and state management&#10; */&#10;interface DownloadController {&#10;    fun pauseDownload()&#10;    fun resumeDownload()&#10;    fun cancelDownload()&#10;    fun getDownloadState(): Int&#10;    fun getCurrentProgress(): Long&#10;    fun getTotalSize(): Long&#10;}&#10;&#10;/**&#10; * Listener interface for download events&#10; */&#10;interface DownloadListener {&#10;    fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int)&#10;    fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?)&#10;    fun onDownloadError(downloadId: Long, error: String)&#10;    fun onDownloadStateChanged(downloadId: Long, state: Int)&#10;    fun onDownloadPaused(downloadId: Long)&#10;    fun onDownloadResumed(downloadId: Long)&#10;    fun onDownloadCancelled(downloadId: Long)&#10;    fun onNetworkReconnected(downloadId: Long)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import java.io.File&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;/**&#10; * Main Download Manager that handles multiple concurrent downloads&#10; * with pause, resume, cancel, and network reconnection support&#10; */&#10;class DownloadManager private constructor() {&#10;    &#10;    private val TAG = &quot;DownloadManager&quot;&#10;    private val activeDownloads = ConcurrentHashMap&lt;Long, DownloadTaskManager&gt;()&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadManager? = null&#10;        &#10;        fun getInstance(): DownloadManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DownloadManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Start a new download&#10;     */&#10;    fun startDownload(&#10;        context: Context,&#10;        downloadRequest: DownloadRequestFileModel,&#10;        outputFile: File,&#10;        listener: DownloadListener? = null&#10;    ): Long {&#10;        val downloadId = downloadRequest.downloadId&#10;        &#10;        // Check if download is already active&#10;        if (isDownloadActive(downloadId)) {&#10;            Log.w(TAG, &quot;Download with ID $downloadId is already active&quot;)&#10;            return downloadId&#10;        }&#10;        &#10;        // Create and start download task&#10;        val downloadTask = DownloadTaskManager(context, downloadRequest, outputFile, listener)&#10;        activeDownloads[downloadId] = downloadTask&#10;        downloadTask.startDownload()&#10;        &#10;        Log.d(TAG, &quot;Started download: ${downloadRequest.fileName} (ID: $downloadId)&quot;)&#10;        return downloadId&#10;    }&#10;    &#10;    /**&#10;     * Pause a download&#10;     */&#10;    fun pauseDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.pauseDownload()&#10;            Log.d(TAG, &quot;Paused download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Resume a paused download&#10;     */&#10;    fun resumeDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.resumeDownload()&#10;            Log.d(TAG, &quot;Resumed download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel a download&#10;     */&#10;    fun cancelDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.cancelDownload()&#10;            activeDownloads.remove(downloadId)&#10;            Log.d(TAG, &quot;Cancelled download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel all active downloads&#10;     */&#10;    fun cancelAllDownloads() {&#10;        val downloadIds = activeDownloads.keys.toList()&#10;        downloadIds.forEach { downloadId -&gt;&#10;            cancelDownload(downloadId)&#10;        }&#10;        Log.d(TAG, &quot;Cancelled all downloads (${downloadIds.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Get download state&#10;     */&#10;    fun getDownloadState(downloadId: Long): Int? {&#10;        return activeDownloads[downloadId]?.getDownloadState()&#10;    }&#10;    &#10;    /**&#10;     * Get current progress in bytes&#10;     */&#10;    fun getDownloadProgress(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getCurrentProgress() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get total file size in bytes&#10;     */&#10;    fun getDownloadTotalSize(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getTotalSize() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get complete download information&#10;     */&#10;    fun getDownloadInfo(downloadId: Long): DownloadRequestFileModel? {&#10;        return activeDownloads[downloadId]?.getDownloadInfo()&#10;    }&#10;    &#10;    /**&#10;     * Check if download is active&#10;     */&#10;    fun isDownloadActive(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.isActive() == true&#10;    }&#10;    &#10;    /**&#10;     * Get all active download IDs&#10;     */&#10;    fun getActiveDownloadIds(): Set&lt;Long&gt; {&#10;        return activeDownloads.keys.toSet()&#10;    }&#10;    &#10;    /**&#10;     * Get number of active downloads&#10;     */&#10;    fun getActiveDownloadCount(): Int = activeDownloads.size&#10;    &#10;    /**&#10;     * Pause all active downloads&#10;     */&#10;    fun pauseAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            task.pauseDownload()&#10;        }&#10;        Log.d(TAG, &quot;Paused all downloads (${activeDownloads.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Resume all paused downloads&#10;     */&#10;    fun resumeAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            if (task.getDownloadState() == Constants.STATE_PAUSED) {&#10;                task.resumeDownload()&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Resumed all paused downloads&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Clean up completed or failed downloads from active list&#10;     */&#10;    fun cleanupCompletedDownloads() {&#10;        val completedIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        activeDownloads.forEach { (id, task) -&gt;&#10;            val state = task.getDownloadState()&#10;            if (state in listOf(Constants.STATE_COMPLETED, Constants.STATE_FAILED, Constants.STATE_CANCELLED)) {&#10;                task.cleanup()&#10;                completedIds.add(id)&#10;            }&#10;        }&#10;        &#10;        completedIds.forEach { id -&gt;&#10;            activeDownloads.remove(id)&#10;        }&#10;        &#10;        if (completedIds.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Cleaned up ${completedIds.size} completed downloads&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get download statistics&#10;     */&#10;    fun getDownloadStatistics(): DownloadStatistics {&#10;        var totalDownloading = 0&#10;        var totalPaused = 0&#10;        var totalWaitingForNetwork = 0&#10;        var totalCompleted = 0&#10;        var totalFailed = 0&#10;        &#10;        activeDownloads.values.forEach { task -&gt;&#10;            when (task.getDownloadState()) {&#10;                Constants.STATE_DOWNLOADING -&gt; totalDownloading++&#10;                Constants.STATE_PAUSED -&gt; totalPaused++&#10;                Constants.STATE_WAITING_FOR_NETWORK -&gt; totalWaitingForNetwork++&#10;                Constants.STATE_COMPLETED -&gt; totalCompleted++&#10;                Constants.STATE_FAILED -&gt; totalFailed++&#10;            }&#10;        }&#10;        &#10;        return DownloadStatistics(&#10;            totalActive = activeDownloads.size,&#10;            downloading = totalDownloading,&#10;            paused = totalPaused,&#10;            waitingForNetwork = totalWaitingForNetwork,&#10;            completed = totalCompleted,&#10;            failed = totalFailed&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Data class for download statistics&#10; */&#10;data class DownloadStatistics(&#10;    val totalActive: Int,&#10;    val downloading: Int,&#10;    val paused: Int,&#10;    val waitingForNetwork: Int,&#10;    val completed: Int,&#10;    val failed: Int&#10;)&#10;" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.db.DownloadPersistenceManager&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import java.io.File&#10;import java.util.concurrent.ConcurrentHashMap&#10;&#10;/**&#10; * Enhanced Download Manager with Room database persistence&#10; * Automatically resumes downloads when app is reopened&#10; */&#10;class DownloadManager private constructor() {&#10;    &#10;    private val TAG = &quot;DownloadManager&quot;&#10;    private val activeDownloads = ConcurrentHashMap&lt;Long, DownloadTaskManager&gt;()&#10;    private val persistenceManager = DownloadPersistenceManager.getInstance()&#10;    private val resumeScope = CoroutineScope(Dispatchers.IO)&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadManager? = null&#10;        &#10;        fun getInstance(): DownloadManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DownloadManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Initialize the download manager and resume incomplete downloads&#10;     */&#10;    fun initialize(context: Context, autoResumeIncompleteDownloads: Boolean = true) {&#10;        persistenceManager.initialize(context)&#10;        &#10;        if (autoResumeIncompleteDownloads) {&#10;            resumeIncompleteDownloads(context)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;DownloadManager initialized&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Resume all incomplete downloads from database when app opens&#10;     */&#10;    fun resumeIncompleteDownloads(context: Context) {&#10;        resumeScope.launch {&#10;            try {&#10;                val incompleteDownloads = persistenceManager.getIncompleteDownloads()&#10;                Log.d(TAG, &quot;Resuming ${incompleteDownloads.size} incomplete downloads&quot;)&#10;                &#10;                incompleteDownloads.forEach { request -&gt;&#10;                    // Validate that the file still exists and has correct size&#10;                    if (persistenceManager.validateDownloadFile(request.downloadId)) {&#10;                        val outputFile = File(context.getExternalFilesDir(null), request.fileName)&#10;                        resumeDownloadFromDatabase(context, request, outputFile)&#10;                    } else {&#10;                        Log.w(TAG, &quot;Cannot resume download ${request.fileName} - file validation failed&quot;)&#10;                        // Reset download progress in database&#10;                        persistenceManager.updateProgress(request.downloadId, 0L, request.totalBytes)&#10;                        persistenceManager.updateState(request.downloadId, Constants.STATE_IDLE)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error resuming incomplete downloads&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun resumeDownloadFromDatabase(&#10;        context: Context,&#10;        request: DownloadRequestFileModel,&#10;        outputFile: File&#10;    ) {&#10;        Log.d(TAG, &quot;Resuming download: ${request.fileName} from ${formatBytes(request.downloadedBytes)}&quot;)&#10;        &#10;        val listener = DatabaseIntegratedListener(request.downloadId)&#10;        val downloadTask = DownloadTaskManager(context, request, outputFile, listener)&#10;        activeDownloads[request.downloadId] = downloadTask&#10;        &#10;        // Set initial state to paused so user can choose to resume&#10;        persistenceManager.updateState(request.downloadId, Constants.STATE_PAUSED)&#10;        &#10;        Log.d(TAG, &quot;Download ${request.fileName} ready to resume (currently paused)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Start a new download with database persistence&#10;     */&#10;    fun startDownload(&#10;        context: Context,&#10;        downloadRequest: DownloadRequestFileModel,&#10;        outputFile: File,&#10;        listener: DownloadListener? = null&#10;    ): Long {&#10;        val downloadId = downloadRequest.downloadId&#10;        &#10;        // Check if download is already active&#10;        if (isDownloadActive(downloadId)) {&#10;            Log.w(TAG, &quot;Download with ID $downloadId is already active&quot;)&#10;            return downloadId&#10;        }&#10;        &#10;        // Save to database&#10;        resumeScope.launch {&#10;            persistenceManager.saveDownloadRequest(downloadRequest, outputFile.absolutePath)&#10;        }&#10;        &#10;        // Create composite listener that includes database updates&#10;        val compositeListener = CompositeDownloadListener(downloadId, listener)&#10;        &#10;        // Create and start download task&#10;        val downloadTask = DownloadTaskManager(context, downloadRequest, outputFile, compositeListener)&#10;        activeDownloads[downloadId] = downloadTask&#10;        downloadTask.startDownload()&#10;        &#10;        Log.d(TAG, &quot;Started download: ${downloadRequest.fileName} (ID: $downloadId)&quot;)&#10;        return downloadId&#10;    }&#10;    &#10;    /**&#10;     * Pause a download&#10;     */&#10;    fun pauseDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.pauseDownload()&#10;            persistenceManager.updateState(downloadId, Constants.STATE_PAUSED)&#10;            Log.d(TAG, &quot;Paused download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Resume a paused download&#10;     */&#10;    fun resumeDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.resumeDownload()&#10;            persistenceManager.updateState(downloadId, Constants.STATE_DOWNLOADING)&#10;            Log.d(TAG, &quot;Resumed download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel a download&#10;     */&#10;    fun cancelDownload(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.let { task -&gt;&#10;            task.cancelDownload()&#10;            persistenceManager.updateState(downloadId, Constants.STATE_CANCELLED)&#10;            activeDownloads.remove(downloadId)&#10;            Log.d(TAG, &quot;Cancelled download ID: $downloadId&quot;)&#10;            true&#10;        } ?: false&#10;    }&#10;    &#10;    /**&#10;     * Cancel all active downloads&#10;     */&#10;    fun cancelAllDownloads() {&#10;        val downloadIds = activeDownloads.keys.toList()&#10;        downloadIds.forEach { downloadId -&gt;&#10;            cancelDownload(downloadId)&#10;        }&#10;        Log.d(TAG, &quot;Cancelled all downloads (${downloadIds.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Get download state&#10;     */&#10;    fun getDownloadState(downloadId: Long): Int? {&#10;        return activeDownloads[downloadId]?.getDownloadState()&#10;    }&#10;    &#10;    /**&#10;     * Get current progress in bytes&#10;     */&#10;    fun getDownloadProgress(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getCurrentProgress() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get total file size in bytes&#10;     */&#10;    fun getDownloadTotalSize(downloadId: Long): Long {&#10;        return activeDownloads[downloadId]?.getTotalSize() ?: 0L&#10;    }&#10;    &#10;    /**&#10;     * Get complete download information&#10;     */&#10;    fun getDownloadInfo(downloadId: Long): DownloadRequestFileModel? {&#10;        return activeDownloads[downloadId]?.getDownloadInfo()&#10;    }&#10;    &#10;    /**&#10;     * Check if download is active&#10;     */&#10;    fun isDownloadActive(downloadId: Long): Boolean {&#10;        return activeDownloads[downloadId]?.isActive() == true&#10;    }&#10;    &#10;    /**&#10;     * Get all active download IDs&#10;     */&#10;    fun getActiveDownloadIds(): Set&lt;Long&gt; {&#10;        return activeDownloads.keys.toSet()&#10;    }&#10;    &#10;    /**&#10;     * Get number of active downloads&#10;     */&#10;    fun getActiveDownloadCount(): Int = activeDownloads.size&#10;    &#10;    /**&#10;     * Pause all active downloads&#10;     */&#10;    fun pauseAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            task.pauseDownload()&#10;        }&#10;        Log.d(TAG, &quot;Paused all downloads (${activeDownloads.size} downloads)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Resume all paused downloads&#10;     */&#10;    fun resumeAllDownloads() {&#10;        activeDownloads.values.forEach { task -&gt;&#10;            if (task.getDownloadState() == Constants.STATE_PAUSED) {&#10;                task.resumeDownload()&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Resumed all paused downloads&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Clean up completed or failed downloads from active list&#10;     */&#10;    fun cleanupCompletedDownloads() {&#10;        val completedIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        activeDownloads.forEach { (id, task) -&gt;&#10;            val state = task.getDownloadState()&#10;            if (state in listOf(Constants.STATE_COMPLETED, Constants.STATE_FAILED, Constants.STATE_CANCELLED)) {&#10;                task.cleanup()&#10;                completedIds.add(id)&#10;            }&#10;        }&#10;        &#10;        completedIds.forEach { id -&gt;&#10;            activeDownloads.remove(id)&#10;        }&#10;        &#10;        if (completedIds.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Cleaned up ${completedIds.size} completed downloads&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Get download statistics&#10;     */&#10;    fun getDownloadStatistics(): DownloadStatistics {&#10;        var totalDownloading = 0&#10;        var totalPaused = 0&#10;        var totalWaitingForNetwork = 0&#10;        var totalCompleted = 0&#10;        var totalFailed = 0&#10;        &#10;        activeDownloads.values.forEach { task -&gt;&#10;            when (task.getDownloadState()) {&#10;                Constants.STATE_DOWNLOADING -&gt; totalDownloading++&#10;                Constants.STATE_PAUSED -&gt; totalPaused++&#10;                Constants.STATE_WAITING_FOR_NETWORK -&gt; totalWaitingForNetwork++&#10;                Constants.STATE_COMPLETED -&gt; totalCompleted++&#10;                Constants.STATE_FAILED -&gt; totalFailed++&#10;            }&#10;        }&#10;        &#10;        return DownloadStatistics(&#10;            totalActive = activeDownloads.size,&#10;            downloading = totalDownloading,&#10;            paused = totalPaused,&#10;            waitingForNetwork = totalWaitingForNetwork,&#10;            completed = totalCompleted,&#10;            failed = totalFailed&#10;        )&#10;    }&#10;    &#10;    private fun formatBytes(bytes: Long): String {&#10;        return when {&#10;            bytes &gt;= 1024 * 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024 * 1024)} GB&quot;&#10;            bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;            bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;            else -&gt; &quot;$bytes B&quot;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Composite listener that handles both user callbacks and database persistence&#10;     */&#10;    private inner class CompositeDownloadListener(&#10;        private val downloadId: Long,&#10;        private val userListener: DownloadListener?&#10;    ) : DownloadListener {&#10;        &#10;        override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;            // Update database&#10;            persistenceManager.updateProgress(downloadId, downloaded, total)&#10;            // Notify user listener&#10;            userListener?.onProgressUpdate(downloadId, downloaded, total, percentage)&#10;        }&#10;        &#10;        override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;            // Update database&#10;            val state = if (success) Constants.STATE_COMPLETED else Constants.STATE_FAILED&#10;            persistenceManager.updateState(downloadId, state)&#10;            // Remove from active downloads&#10;            activeDownloads.remove(downloadId)&#10;            // Notify user listener&#10;            userListener?.onDownloadComplete(downloadId, success, filePath)&#10;        }&#10;        &#10;        override fun onDownloadError(downloadId: Long, error: String) {&#10;            // Update database&#10;            persistenceManager.updateState(downloadId, Constants.STATE_FAILED, error)&#10;            // Notify user listener&#10;            userListener?.onDownloadError(downloadId, error)&#10;        }&#10;        &#10;        override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;            // Update database&#10;            persistenceManager.updateState(downloadId, state)&#10;            // Notify user listener&#10;            userListener?.onDownloadStateChanged(downloadId, state)&#10;        }&#10;        &#10;        override fun onDownloadPaused(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_PAUSED)&#10;            userListener?.onDownloadPaused(downloadId)&#10;        }&#10;        &#10;        override fun onDownloadResumed(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_DOWNLOADING)&#10;            userListener?.onDownloadResumed(downloadId)&#10;        }&#10;        &#10;        override fun onDownloadCancelled(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_CANCELLED)&#10;            userListener?.onDownloadCancelled(downloadId)&#10;        }&#10;        &#10;        override fun onNetworkReconnected(downloadId: Long) {&#10;            userListener?.onNetworkReconnected(downloadId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Database-only listener for resumed downloads&#10;     */&#10;    private inner class DatabaseIntegratedListener(&#10;        private val downloadId: Long&#10;    ) : DownloadListener {&#10;        &#10;        override fun onProgressUpdate(downloadId: Long, downloaded: Long, total: Long, percentage: Int) {&#10;            persistenceManager.updateProgress(downloadId, downloaded, total)&#10;        }&#10;        &#10;        override fun onDownloadComplete(downloadId: Long, success: Boolean, filePath: String?) {&#10;            val state = if (success) Constants.STATE_COMPLETED else Constants.STATE_FAILED&#10;            persistenceManager.updateState(downloadId, state)&#10;            activeDownloads.remove(downloadId)&#10;        }&#10;        &#10;        override fun onDownloadError(downloadId: Long, error: String) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_FAILED, error)&#10;        }&#10;        &#10;        override fun onDownloadStateChanged(downloadId: Long, state: Int) {&#10;            persistenceManager.updateState(downloadId, state)&#10;        }&#10;        &#10;        override fun onDownloadPaused(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_PAUSED)&#10;        }&#10;        &#10;        override fun onDownloadResumed(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_DOWNLOADING)&#10;        }&#10;        &#10;        override fun onDownloadCancelled(downloadId: Long) {&#10;            persistenceManager.updateState(downloadId, Constants.STATE_CANCELLED)&#10;        }&#10;        &#10;        override fun onNetworkReconnected(downloadId: Long) {&#10;            // Handle network reconnection&#10;        }&#10;    }&#10;}&#10;&#10;data class DownloadStatistics(&#10;    val totalActive: Int,&#10;    val downloading: Int,&#10;    val paused: Int,&#10;    val waitingForNetwork: Int,&#10;    val completed: Int,&#10;    val failed: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadTaskManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/DownloadTaskManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.*&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;import java.util.concurrent.atomic.AtomicInteger&#10;import java.util.concurrent.atomic.AtomicLong&#10;&#10;class DownloadTaskManager(&#10;    private val context: Context,&#10;    private var downloadRequestFileModel: DownloadRequestFileModel,&#10;    private val outputFile: File,&#10;    private val listener: DownloadListener? = null&#10;) : DownloadController, NetworkManager.NetworkConnectionState {&#10;&#10;    private val TAG = &quot;DownloadTaskManager&quot;&#10;    &#10;    // Core components&#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private val httpConnectionManager = HttpConnectionManager(downloadRequestFileModel)&#10;    private val networkManager = NetworkManager(context, this)&#10;    &#10;    // State management&#10;    private val currentState = AtomicInteger(Constants.STATE_IDLE)&#10;    private val isPaused = AtomicBoolean(false)&#10;    private val isCancelled = AtomicBoolean(false)&#10;    private val isWaitingForNetwork = AtomicBoolean(false)&#10;    &#10;    // Download progress tracking&#10;    private val downloadedBytes = AtomicLong(downloadRequestFileModel.downloadedBytes)&#10;    private val totalBytes = AtomicLong(downloadRequestFileModel.totalBytes)&#10;    &#10;    // Jobs and retry management&#10;    private var downloadJob: Job? = null&#10;    private var retryCount = 0&#10;&#10;    @RequiresPermission(Manifest.permission.ACCESS_NETWORK_STATE)&#10;    fun startDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            Log.w(TAG, &quot;Download already in progress&quot;)&#10;            return&#10;        }&#10;        &#10;        networkManager.registerNetworkCallback()&#10;        &#10;        if (!networkManager.isConnected()) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            Log.d(TAG, &quot;No network connection, waiting for network...&quot;)&#10;            return&#10;        }&#10;        &#10;        executeDownload()&#10;    }&#10;&#10;    private fun executeDownload() {&#10;        if (isCancelled.get()) return&#10;        &#10;        setState(Constants.STATE_DOWNLOADING)&#10;        isPaused.set(false)&#10;        &#10;        downloadJob = scope.launch {&#10;            try {&#10;                performDownload()&#10;            } catch (e: CancellationException) {&#10;                Log.d(TAG, &quot;Download cancelled&quot;)&#10;                handleDownloadCancellation()&#10;            } catch (e: IOException) {&#10;                Log.e(TAG, &quot;Download IO error&quot;, e)&#10;                handleNetworkError(e)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Download error&quot;, e)&#10;                handleDownloadError(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun performDownload() {&#10;        // Update request model with current progress&#10;        downloadRequestFileModel = downloadRequestFileModel.copy(&#10;            downloadedBytes = downloadedBytes.get()&#10;        )&#10;        &#10;        // Establish connection&#10;        httpConnectionManager.buildConnectionToDownload()&#10;        &#10;        val contentLength = httpConnectionManager.getContentLength()&#10;        if (contentLength &gt; 0 &amp;&amp; totalBytes.get() &lt;= 0) {&#10;            totalBytes.set(contentLength + downloadedBytes.get())&#10;        }&#10;        &#10;        // Start streaming download&#10;        httpConnectionManager.getInputStream()?.use { inputStream -&gt;&#10;            FileOutputStream(outputFile, downloadedBytes.get() &gt; 0).use { outputStream -&gt;&#10;                downloadDataStream(inputStream, outputStream)&#10;            }&#10;        } ?: throw IOException(&quot;Unable to get input stream&quot;)&#10;        &#10;        // Download completed successfully&#10;        setState(Constants.STATE_COMPLETED)&#10;        listener?.onDownloadComplete(&#10;            downloadRequestFileModel.downloadId,&#10;            true,&#10;            outputFile.absolutePath&#10;        )&#10;    }&#10;&#10;    private suspend fun downloadDataStream(&#10;        inputStream: java.io.InputStream,&#10;        outputStream: FileOutputStream&#10;    ) {&#10;        val buffer = ByteArray(Constants.BUFFER_SIZE)&#10;        var bytesRead: Int&#10;        var lastProgressUpdate = 0L&#10;&#10;        while (inputStream.read(buffer).also { bytesRead = it } != -1) {&#10;            // Check for cancellation&#10;            if (isCancelled.get()) {&#10;                throw CancellationException(&quot;Download cancelled&quot;)&#10;            }&#10;&#10;            // Handle pause state&#10;            while (isPaused.get() &amp;&amp; !isCancelled.get()) {&#10;                delay(100)&#10;            }&#10;&#10;            // Write data to file&#10;            outputStream.write(buffer, 0, bytesRead)&#10;            outputStream.flush()&#10;            &#10;            // Update progress&#10;            val currentDownloaded = downloadedBytes.addAndGet(bytesRead.toLong())&#10;            &#10;            // Throttle progress updates (every 100KB or 1%)&#10;            val shouldUpdateProgress = currentDownloaded - lastProgressUpdate &gt;= 100_000 ||&#10;                    (totalBytes.get() &gt; 0 &amp;&amp; (currentDownloaded * 100 / totalBytes.get()) &gt; (lastProgressUpdate * 100 / totalBytes.get()))&#10;            &#10;            if (shouldUpdateProgress) {&#10;                notifyProgress(currentDownloaded)&#10;                lastProgressUpdate = currentDownloaded&#10;            }&#10;            &#10;            // Yield to allow other coroutines to run and check for state changes&#10;            yield()&#10;        }&#10;    }&#10;&#10;    private fun notifyProgress(downloaded: Long) {&#10;        val total = totalBytes.get()&#10;        val percentage = if (total &gt; 0) {&#10;            ((downloaded * 100) / total).toInt()&#10;        } else 0&#10;        &#10;        listener?.onProgressUpdate(&#10;            downloadRequestFileModel.downloadId,&#10;            downloaded,&#10;            total,&#10;            percentage&#10;        )&#10;    }&#10;&#10;    private fun handleNetworkError(exception: IOException) {&#10;        if (networkManager.isConnected()) {&#10;            // Network is available but connection failed - retry&#10;            handleRetry(exception)&#10;        } else {&#10;            // No network - wait for reconnection&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;            Log.d(TAG, &quot;Network lost during download, waiting for reconnection...&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleRetry(exception: Exception) {&#10;        if (retryCount &lt; Constants.MAX_RETRY_ATTEMPTS &amp;&amp; !isCancelled.get()) {&#10;            retryCount++&#10;            Log.d(TAG, &quot;Retrying download... Attempt $retryCount/${Constants.MAX_RETRY_ATTEMPTS}&quot;)&#10;            &#10;            scope.launch {&#10;                delay(Constants.RETRY_DELAY_MS)&#10;                if (!isCancelled.get()) {&#10;                    executeDownload()&#10;                }&#10;            }&#10;        } else {&#10;            setState(Constants.STATE_FAILED)&#10;            listener?.onDownloadError(&#10;                downloadRequestFileModel.downloadId,&#10;                &quot;Download failed after $retryCount attempts: ${exception.message}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun handleDownloadError(exception: Exception) {&#10;        setState(Constants.STATE_FAILED)&#10;        listener?.onDownloadError(&#10;            downloadRequestFileModel.downloadId,&#10;            &quot;Download error: ${exception.message}&quot;&#10;        )&#10;    }&#10;&#10;    private fun handleDownloadCancellation() {&#10;        setState(Constants.STATE_CANCELLED)&#10;        // Delete partial file if download was cancelled&#10;        if (outputFile.exists() &amp;&amp; downloadedBytes.get() &lt; totalBytes.get()) {&#10;            outputFile.delete()&#10;            Log.d(TAG, &quot;Deleted partial download file&quot;)&#10;        }&#10;        listener?.onDownloadCancelled(downloadRequestFileModel.downloadId)&#10;    }&#10;&#10;    // DownloadController implementation&#10;    override fun pauseDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            isPaused.set(true)&#10;            setState(Constants.STATE_PAUSED)&#10;            listener?.onDownloadPaused(downloadRequestFileModel.downloadId)&#10;            Log.d(TAG, &quot;Download paused&quot;)&#10;        }&#10;    }&#10;&#10;    override fun resumeDownload() {&#10;        when (currentState.get()) {&#10;            Constants.STATE_PAUSED -&gt; {&#10;                if (networkManager.isConnected()) {&#10;                    isPaused.set(false)&#10;                    setState(Constants.STATE_DOWNLOADING)&#10;                    listener?.onDownloadResumed(downloadRequestFileModel.downloadId)&#10;                    Log.d(TAG, &quot;Download resumed&quot;)&#10;                } else {&#10;                    setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;                    isWaitingForNetwork.set(true)&#10;                    Log.d(TAG, &quot;Cannot resume - no network connection&quot;)&#10;                }&#10;            }&#10;            Constants.STATE_FAILED -&gt; {&#10;                // Allow resume after failure&#10;                retryCount = 0&#10;                executeDownload()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun cancelDownload() {&#10;        isCancelled.set(true)&#10;        isPaused.set(false)&#10;        downloadJob?.cancel()&#10;        cleanup()&#10;        Log.d(TAG, &quot;Download cancelled&quot;)&#10;    }&#10;&#10;    override fun getDownloadState(): Int = currentState.get()&#10;&#10;    override fun getCurrentProgress(): Long = downloadedBytes.get()&#10;&#10;    override fun getTotalSize(): Long = totalBytes.get()&#10;&#10;    // NetworkManager.NetworkConnectionState implementation&#10;    override fun onConnected() {&#10;        Log.d(TAG, &quot;Network reconnected&quot;)&#10;        &#10;        if (isWaitingForNetwork.get() || currentState.get() == Constants.STATE_WAITING_FOR_NETWORK) {&#10;            isWaitingForNetwork.set(false)&#10;            retryCount = 0 // Reset retry count on network reconnection&#10;            &#10;            listener?.onNetworkReconnected(downloadRequestFileModel.downloadId)&#10;            &#10;            // Resume download automatically when network is restored&#10;            executeDownload()&#10;        }&#10;    }&#10;&#10;    override fun onDisconnected() {&#10;        Log.d(TAG, &quot;Network disconnected&quot;)&#10;        &#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;        }&#10;    }&#10;&#10;    private fun setState(newState: Int) {&#10;        val oldState = currentState.getAndSet(newState)&#10;        if (oldState != newState) {&#10;            listener?.onDownloadStateChanged(downloadRequestFileModel.downloadId, newState)&#10;        }&#10;    }&#10;&#10;    fun cleanup() {&#10;        downloadJob?.cancel()&#10;        httpConnectionManager.disconnect()&#10;        networkManager.cleanup()&#10;        scope.cancel()&#10;    }&#10;&#10;    // Utility methods&#10;    fun getDownloadInfo(): DownloadRequestFileModel {&#10;        return downloadRequestFileModel.copy(&#10;            downloadedBytes = downloadedBytes.get(),&#10;            totalBytes = totalBytes.get(),&#10;            state = currentState.get(),&#10;            progress = if (totalBytes.get() &gt; 0) {&#10;                (downloadedBytes.get().toFloat() / totalBytes.get().toFloat()) * 100&#10;            } else 0f&#10;        )&#10;    }&#10;&#10;    fun isActive(): Boolean {&#10;        return currentState.get() in listOf(&#10;            Constants.STATE_DOWNLOADING,&#10;            Constants.STATE_WAITING_FOR_NETWORK&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.*&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.io.IOException&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;import java.util.concurrent.atomic.AtomicInteger&#10;import java.util.concurrent.atomic.AtomicLong&#10;&#10;class DownloadTaskManager(&#10;    private val context: Context,&#10;    private var downloadRequestFileModel: DownloadRequestFileModel,&#10;    private val outputFile: File,&#10;    private val listener: DownloadListener? = null&#10;) : DownloadController, NetworkManager.NetworkConnectionState {&#10;&#10;    private val TAG = &quot;DownloadTaskManager&quot;&#10;    &#10;    // Core components&#10;    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())&#10;    private val httpConnectionManager = HttpConnectionManager(downloadRequestFileModel)&#10;    private val networkManager = NetworkManager(context, this)&#10;    &#10;    // State management&#10;    private val currentState = AtomicInteger(Constants.STATE_IDLE)&#10;    private val isPaused = AtomicBoolean(false)&#10;    private val isCancelled = AtomicBoolean(false)&#10;    private val isWaitingForNetwork = AtomicBoolean(false)&#10;    &#10;    // Download progress tracking&#10;    private val downloadedBytes = AtomicLong(downloadRequestFileModel.downloadedBytes)&#10;    private val totalBytes = AtomicLong(downloadRequestFileModel.totalBytes)&#10;    &#10;    // Jobs and retry management&#10;    private var downloadJob: Job? = null&#10;    private var retryCount = 0&#10;&#10;    @RequiresPermission(Manifest.permission.ACCESS_NETWORK_STATE)&#10;    fun startDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            Log.w(TAG, &quot;Download already in progress&quot;)&#10;            return&#10;        }&#10;        &#10;        networkManager.registerNetworkCallback()&#10;        &#10;        if (!networkManager.isConnected()) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            Log.d(TAG, &quot;No network connection, waiting for network...&quot;)&#10;            return&#10;        }&#10;        &#10;        executeDownload()&#10;    }&#10;&#10;    private fun executeDownload() {&#10;        if (isCancelled.get()) return&#10;        &#10;        setState(Constants.STATE_DOWNLOADING)&#10;        isPaused.set(false)&#10;        &#10;        downloadJob = scope.launch {&#10;            try {&#10;                performDownload()&#10;            } catch (e: CancellationException) {&#10;                Log.d(TAG, &quot;Download cancelled&quot;)&#10;                handleDownloadCancellation()&#10;            } catch (e: IOException) {&#10;                Log.e(TAG, &quot;Download IO error&quot;, e)&#10;                handleNetworkError(e)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Download error&quot;, e)&#10;                handleDownloadError(e)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun performDownload() {&#10;        // Get current downloaded bytes (important for resume)&#10;        val currentDownloadedBytes = downloadedBytes.get()&#10;        &#10;        // Update request model with current progress for HTTP Range header&#10;        downloadRequestFileModel = downloadRequestFileModel.copy(&#10;            downloadedBytes = currentDownloadedBytes&#10;        )&#10;        &#10;        Log.d(TAG, &quot;Starting download from byte: $currentDownloadedBytes&quot;)&#10;        &#10;        // Establish connection with Range header for resume&#10;        httpConnectionManager.buildConnectionToDownload()&#10;        &#10;        val contentLength = httpConnectionManager.getContentLength()&#10;        &#10;        // Set total bytes correctly for resume scenarios&#10;        if (totalBytes.get() &lt;= 0) {&#10;            // For new downloads, total = content length + already downloaded&#10;            val totalSize = if (currentDownloadedBytes &gt; 0) {&#10;                // Resume: add current downloaded bytes to remaining content length&#10;                currentDownloadedBytes + contentLength&#10;            } else {&#10;                // New download: just the content length&#10;                contentLength&#10;            }&#10;            totalBytes.set(totalSize)&#10;            Log.d(TAG, &quot;Total size set to: $totalSize bytes&quot;)&#10;        }&#10;        &#10;        // Validate that we can resume&#10;        if (currentDownloadedBytes &gt; 0 &amp;&amp; outputFile.exists()) {&#10;            val actualFileSize = outputFile.length()&#10;            if (actualFileSize != currentDownloadedBytes) {&#10;                Log.w(TAG, &quot;File size mismatch. Expected: $currentDownloadedBytes, Actual: $actualFileSize&quot;)&#10;                // Reset to actual file size&#10;                downloadedBytes.set(actualFileSize)&#10;                downloadRequestFileModel = downloadRequestFileModel.copy(&#10;                    downloadedBytes = actualFileSize&#10;                )&#10;                // Reconnect with correct range&#10;                httpConnectionManager.disconnect()&#10;                httpConnectionManager.buildConnectionToDownload()&#10;            }&#10;        }&#10;        &#10;        // Start streaming download from current position&#10;        httpConnectionManager.getInputStream()?.use { inputStream -&gt;&#10;            // IMPORTANT: Use append mode (true) when resuming&#10;            FileOutputStream(outputFile, currentDownloadedBytes &gt; 0).use { outputStream -&gt;&#10;                Log.d(TAG, &quot;Resume mode: ${currentDownloadedBytes &gt; 0}, File exists: ${outputFile.exists()}&quot;)&#10;                downloadDataStream(inputStream, outputStream)&#10;            }&#10;        } ?: throw IOException(&quot;Unable to get input stream&quot;)&#10;        &#10;        // Download completed successfully&#10;        setState(Constants.STATE_COMPLETED)&#10;        listener?.onDownloadComplete(&#10;            downloadRequestFileModel.downloadId,&#10;            true,&#10;            outputFile.absolutePath&#10;        )&#10;        &#10;        Log.d(TAG, &quot;Download completed. Final size: ${outputFile.length()} bytes&quot;)&#10;    }&#10;&#10;    private suspend fun downloadDataStream(&#10;        inputStream: java.io.InputStream,&#10;        outputStream: FileOutputStream&#10;    ) {&#10;        val buffer = ByteArray(Constants.BUFFER_SIZE)&#10;        var bytesRead: Int&#10;        var lastProgressUpdate = 0L&#10;&#10;        while (inputStream.read(buffer).also { bytesRead = it } != -1) {&#10;            // Check for cancellation&#10;            if (isCancelled.get()) {&#10;                throw CancellationException(&quot;Download cancelled&quot;)&#10;            }&#10;&#10;            // Handle pause state&#10;            while (isPaused.get() &amp;&amp; !isCancelled.get()) {&#10;                delay(100)&#10;            }&#10;&#10;            // Write data to file&#10;            outputStream.write(buffer, 0, bytesRead)&#10;            outputStream.flush()&#10;            &#10;            // Update progress&#10;            val currentDownloaded = downloadedBytes.addAndGet(bytesRead.toLong())&#10;            &#10;            // Throttle progress updates (every 100KB or 1%)&#10;            val shouldUpdateProgress = currentDownloaded - lastProgressUpdate &gt;= 100_000 ||&#10;                    (totalBytes.get() &gt; 0 &amp;&amp; (currentDownloaded * 100 / totalBytes.get()) &gt; (lastProgressUpdate * 100 / totalBytes.get()))&#10;            &#10;            if (shouldUpdateProgress) {&#10;                notifyProgress(currentDownloaded)&#10;                lastProgressUpdate = currentDownloaded&#10;            }&#10;            &#10;            // Yield to allow other coroutines to run and check for state changes&#10;            yield()&#10;        }&#10;    }&#10;&#10;    private fun notifyProgress(downloaded: Long) {&#10;        val total = totalBytes.get()&#10;        val percentage = if (total &gt; 0) {&#10;            ((downloaded * 100) / total).toInt()&#10;        } else 0&#10;        &#10;        listener?.onProgressUpdate(&#10;            downloadRequestFileModel.downloadId,&#10;            downloaded,&#10;            total,&#10;            percentage&#10;        )&#10;    }&#10;&#10;    private fun handleNetworkError(exception: IOException) {&#10;        if (networkManager.isConnected()) {&#10;            // Network is available but connection failed - retry&#10;            handleRetry(exception)&#10;        } else {&#10;            // No network - wait for reconnection&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;            Log.d(TAG, &quot;Network lost during download, waiting for reconnection...&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleRetry(exception: Exception) {&#10;        if (retryCount &lt; Constants.MAX_RETRY_ATTEMPTS &amp;&amp; !isCancelled.get()) {&#10;            retryCount++&#10;            Log.d(TAG, &quot;Retrying download... Attempt $retryCount/${Constants.MAX_RETRY_ATTEMPTS}&quot;)&#10;            &#10;            scope.launch {&#10;                delay(Constants.RETRY_DELAY_MS)&#10;                if (!isCancelled.get()) {&#10;                    executeDownload()&#10;                }&#10;            }&#10;        } else {&#10;            setState(Constants.STATE_FAILED)&#10;            listener?.onDownloadError(&#10;                downloadRequestFileModel.downloadId,&#10;                &quot;Download failed after $retryCount attempts: ${exception.message}&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private fun handleDownloadError(exception: Exception) {&#10;        setState(Constants.STATE_FAILED)&#10;        listener?.onDownloadError(&#10;            downloadRequestFileModel.downloadId,&#10;            &quot;Download error: ${exception.message}&quot;&#10;        )&#10;    }&#10;&#10;    private fun handleDownloadCancellation() {&#10;        setState(Constants.STATE_CANCELLED)&#10;        // Delete partial file if download was cancelled&#10;        if (outputFile.exists() &amp;&amp; downloadedBytes.get() &lt; totalBytes.get()) {&#10;            outputFile.delete()&#10;            Log.d(TAG, &quot;Deleted partial download file&quot;)&#10;        }&#10;        listener?.onDownloadCancelled(downloadRequestFileModel.downloadId)&#10;    }&#10;&#10;    // DownloadController implementation&#10;    override fun pauseDownload() {&#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            isPaused.set(true)&#10;            setState(Constants.STATE_PAUSED)&#10;            listener?.onDownloadPaused(downloadRequestFileModel.downloadId)&#10;            Log.d(TAG, &quot;Download paused&quot;)&#10;        }&#10;    }&#10;&#10;    override fun resumeDownload() {&#10;        when (currentState.get()) {&#10;            Constants.STATE_PAUSED -&gt; {&#10;                if (networkManager.isConnected()) {&#10;                    isPaused.set(false)&#10;                    setState(Constants.STATE_DOWNLOADING)&#10;                    listener?.onDownloadResumed(downloadRequestFileModel.downloadId)&#10;                    Log.d(TAG, &quot;Download resumed&quot;)&#10;                } else {&#10;                    setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;                    isWaitingForNetwork.set(true)&#10;                    Log.d(TAG, &quot;Cannot resume - no network connection&quot;)&#10;                }&#10;            }&#10;            Constants.STATE_FAILED -&gt; {&#10;                // Allow resume after failure&#10;                retryCount = 0&#10;                executeDownload()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun cancelDownload() {&#10;        isCancelled.set(true)&#10;        isPaused.set(false)&#10;        downloadJob?.cancel()&#10;        cleanup()&#10;        Log.d(TAG, &quot;Download cancelled&quot;)&#10;    }&#10;&#10;    override fun getDownloadState(): Int = currentState.get()&#10;&#10;    override fun getCurrentProgress(): Long = downloadedBytes.get()&#10;&#10;    override fun getTotalSize(): Long = totalBytes.get()&#10;&#10;    // NetworkManager.NetworkConnectionState implementation&#10;    override fun onConnected() {&#10;        Log.d(TAG, &quot;Network reconnected&quot;)&#10;        &#10;        if (isWaitingForNetwork.get() || currentState.get() == Constants.STATE_WAITING_FOR_NETWORK) {&#10;            isWaitingForNetwork.set(false)&#10;            retryCount = 0 // Reset retry count on network reconnection&#10;            &#10;            listener?.onNetworkReconnected(downloadRequestFileModel.downloadId)&#10;            &#10;            // Resume download automatically when network is restored&#10;            executeDownload()&#10;        }&#10;    }&#10;&#10;    override fun onDisconnected() {&#10;        Log.d(TAG, &quot;Network disconnected&quot;)&#10;        &#10;        if (currentState.get() == Constants.STATE_DOWNLOADING) {&#10;            setState(Constants.STATE_WAITING_FOR_NETWORK)&#10;            isWaitingForNetwork.set(true)&#10;        }&#10;    }&#10;&#10;    private fun setState(newState: Int) {&#10;        val oldState = currentState.getAndSet(newState)&#10;        if (oldState != newState) {&#10;            listener?.onDownloadStateChanged(downloadRequestFileModel.downloadId, newState)&#10;        }&#10;    }&#10;&#10;    fun cleanup() {&#10;        downloadJob?.cancel()&#10;        httpConnectionManager.disconnect()&#10;        networkManager.cleanup()&#10;        scope.cancel()&#10;    }&#10;&#10;    // Utility methods&#10;    fun getDownloadInfo(): DownloadRequestFileModel {&#10;        return downloadRequestFileModel.copy(&#10;            downloadedBytes = downloadedBytes.get(),&#10;            totalBytes = totalBytes.get(),&#10;            state = currentState.get(),&#10;            progress = if (totalBytes.get() &gt; 0) {&#10;                (downloadedBytes.get().toFloat() / totalBytes.get().toFloat()) * 100&#10;            } else 0f&#10;        )&#10;    }&#10;&#10;    fun isActive(): Boolean {&#10;        return currentState.get() in listOf(&#10;            Constants.STATE_DOWNLOADING,&#10;            Constants.STATE_WAITING_FOR_NETWORK&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/HttpConnectionManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/HttpConnectionManager.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk&#10;&#10;import android.annotation.SuppressLint&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants.CONNECT_TIMEOUT&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.util.Locale&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HttpConnectionManager(private val request: DownloadRequestFileModel) {&#10;    private val TAG = &quot;HttpConnectionManager&quot;&#10;    private var httpURLConnection : HttpURLConnection? = null&#10;&#10;    suspend fun buildConnectionToDownload() {&#10;        disconnect()&#10;        httpURLConnection = createConnection(request.url).also { conn -&gt;&#10;            configureConnection(conn)&#10;            conn.connect()&#10;        }&#10;    }&#10;&#10;    private fun createConnection(url: String): HttpURLConnection {&#10;        return URL(url).openConnection() as HttpURLConnection&#10;    }&#10;    private fun configureConnection(conn: HttpURLConnection) {&#10;        conn.connectTimeout = CONNECT_TIMEOUT.toInt()&#10;        if (request.downloadedBytes &gt; 0) {&#10;            val rangeHeader = String.format(&#10;                Locale.ENGLISH,&#10;                &quot;bytes=%d-&quot;,&#10;                request.downloadedBytes&#10;            )&#10;            Log.d(TAG, &quot;configureConnection: =====&gt; rangeHeader&quot;)&#10;            conn.setRequestProperty(Constants.RANGE_HEADER, rangeHeader)&#10;        }&#10;    }&#10;    fun getInputStream(): InputStream? = httpURLConnection?.inputStream&#10;    fun getResponseCode(): Int = httpURLConnection?.responseCode ?: 0&#10;&#10;    fun getContentLength(): Long = httpURLConnection?.contentLengthLong ?: -1L&#10;&#10;    fun isValidResponse(): Boolean {&#10;        val responseCode = getResponseCode()&#10;        return responseCode == Constants.HTTP_OK || responseCode == Constants.HTTP_PARTIAL_CONTENT&#10;    }&#10;    fun disconnect() {&#10;        httpURLConnection?.disconnect()&#10;        httpURLConnection = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.marusys.downloadsdk&#10;&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants.CONNECT_TIMEOUT&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import java.io.IOException&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.util.Locale&#10;import java.util.concurrent.TimeUnit&#10;&#10;class HttpConnectionManager(private val request: DownloadRequestFileModel) {&#10;    private val TAG = &quot;HttpConnectionManager&quot;&#10;    private var httpURLConnection : HttpURLConnection? = null&#10;&#10;    suspend fun buildConnectionToDownload() {&#10;        disconnect()&#10;        httpURLConnection = createConnection(request.url).also { conn -&gt;&#10;            configureConnection(conn)&#10;            conn.connect()&#10;        }&#10;        &#10;        if (!isValidResponse()) {&#10;            throw IOException(&quot;Invalid HTTP response: ${getResponseCode()}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun createConnection(url: String): HttpURLConnection {&#10;        return URL(url).openConnection() as HttpURLConnection&#10;    }&#10;    &#10;    private fun configureConnection(conn: HttpURLConnection) {&#10;        conn.connectTimeout = CONNECT_TIMEOUT.toInt()&#10;        conn.readTimeout = CONNECT_TIMEOUT.toInt()&#10;        &#10;        if (request.downloadedBytes &gt; 0) {&#10;            val rangeHeader = String.format(&#10;                Locale.ENGLISH,&#10;                &quot;bytes=%d-&quot;,&#10;                request.downloadedBytes&#10;            )&#10;            Log.d(TAG, &quot;configureConnection: =====&gt; rangeHeader: $rangeHeader&quot;)&#10;            conn.setRequestProperty(Constants.RANGE_HEADER, rangeHeader)&#10;        }&#10;    }&#10;    &#10;    fun getInputStream(): InputStream? = httpURLConnection?.inputStream&#10;    &#10;    fun getResponseCode(): Int = httpURLConnection?.responseCode ?: 0&#10;&#10;    fun getContentLength(): Long = httpURLConnection?.contentLengthLong ?: -1L&#10;    &#10;    fun getETag(): String? = httpURLConnection?.getHeaderField(Constants.ETAG_HEADER)&#10;&#10;    fun isValidResponse(): Boolean {&#10;        val responseCode = getResponseCode()&#10;        return responseCode == Constants.HTTP_OK || responseCode == Constants.HTTP_PARTIAL_CONTENT&#10;    }&#10;    &#10;    fun disconnect() {&#10;        httpURLConnection?.disconnect()&#10;        httpURLConnection = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestDao.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy.Companion.REPLACE&#10;import androidx.room.Query&#10;&#10;@Dao&#10;interface DataRequestDao {&#10;    @Insert(onConflict = REPLACE)&#10;    suspend fun insertDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Update&#10;    suspend fun updateDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Query(&quot;UPDATE download_requests SET state = :state, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadState(downloadId: Long, state: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET downloadedBytes = :downloadedBytes, progress = :progress, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadProgress(downloadId: Long, downloadedBytes: Long, progress: Float, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET totalBytes = :totalBytes, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateTotalBytes(downloadId: Long, totalBytes: Long, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET retryCount = :retryCount, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateRetryCount(downloadId: Long, retryCount: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET errorMessage = :errorMessage, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateErrorMessage(downloadId: Long, errorMessage: String?, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    // Query methods for resume functionality&#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun getDownloadRequest(downloadId: Long): DataRequestModel?&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (:states)&quot;)&#10;    suspend fun getDownloadsByState(states: List&lt;Int&gt;): List&lt;DataRequestModel&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadsByState(state: Int): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get incomplete downloads for resume (downloading, paused, waiting for network)&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (1, 2, 6) ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getIncompleteDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get failed downloads for retry&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = 4 ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getFailedDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get all downloads ordered by most recent&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getAllDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Live data for UI updates&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DataRequestModel&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    fun getDownloadRequestFlow(downloadId: Long): Flow&lt;DataRequestModel?&gt;&#10;    &#10;    // Cleanup methods&#10;    @Query(&quot;DELETE FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun deleteDownloadRequest(downloadId: Long)&#10;    &#10;    @Query(&quot;DELETE FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun deleteDownloadsByState(state: Int)&#10;    &#10;    // Delete old completed downloads (older than specified timestamp)&#10;    @Query(&quot;DELETE FROM download_requests WHERE state = 3 AND updatedAt &lt; :beforeTimestamp&quot;)&#10;    suspend fun deleteOldCompletedDownloads(beforeTimestamp: Long)&#10;    &#10;    // Get download statistics&#10;    @Query(&quot;SELECT COUNT(*) FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadCountByState(state: Int): Int&#10;    &#10;    @Query(&quot;SELECT state, COUNT(*) as count FROM download_requests GROUP BY state&quot;)&#10;    suspend fun getDownloadStatistics(): Map&lt;Int, Int&gt;&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy.Companion.REPLACE&#10;import androidx.room.Query&#10;import androidx.room.Update&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface DataRequestDao {&#10;    &#10;    @Insert(onConflict = REPLACE)&#10;    suspend fun insertDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Update&#10;    suspend fun updateDownloadRequest(dataRequest: DataRequestModel)&#10;    &#10;    @Query(&quot;UPDATE download_requests SET state = :state, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadState(downloadId: Long, state: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET downloadedBytes = :downloadedBytes, progress = :progress, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateDownloadProgress(downloadId: Long, downloadedBytes: Long, progress: Float, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET totalBytes = :totalBytes, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateTotalBytes(downloadId: Long, totalBytes: Long, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET retryCount = :retryCount, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateRetryCount(downloadId: Long, retryCount: Int, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    @Query(&quot;UPDATE download_requests SET errorMessage = :errorMessage, updatedAt = :updatedAt WHERE downloadId = :downloadId&quot;)&#10;    suspend fun updateErrorMessage(downloadId: Long, errorMessage: String?, updatedAt: Long = System.currentTimeMillis())&#10;    &#10;    // Query methods for resume functionality&#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun getDownloadRequest(downloadId: Long): DataRequestModel?&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (:states)&quot;)&#10;    suspend fun getDownloadsByState(states: List&lt;Int&gt;): List&lt;DataRequestModel&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadsByState(state: Int): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get incomplete downloads for resume (downloading, paused, waiting for network)&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state IN (1, 2, 6) ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getIncompleteDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get failed downloads for retry&#10;    @Query(&quot;SELECT * FROM download_requests WHERE state = 4 ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getFailedDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Get all downloads ordered by most recent&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    suspend fun getAllDownloads(): List&lt;DataRequestModel&gt;&#10;    &#10;    // Live data for UI updates&#10;    @Query(&quot;SELECT * FROM download_requests ORDER BY updatedAt DESC&quot;)&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DataRequestModel&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    fun getDownloadRequestFlow(downloadId: Long): Flow&lt;DataRequestModel?&gt;&#10;    &#10;    // Cleanup methods&#10;    @Query(&quot;DELETE FROM download_requests WHERE downloadId = :downloadId&quot;)&#10;    suspend fun deleteDownloadRequest(downloadId: Long)&#10;    &#10;    @Query(&quot;DELETE FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun deleteDownloadsByState(state: Int)&#10;    &#10;    // Delete old completed downloads (older than specified timestamp)&#10;    @Query(&quot;DELETE FROM download_requests WHERE state = 3 AND updatedAt &lt; :beforeTimestamp&quot;)&#10;    suspend fun deleteOldCompletedDownloads(beforeTimestamp: Long)&#10;    &#10;    // Get download statistics&#10;    @Query(&quot;SELECT COUNT(*) FROM download_requests WHERE state = :state&quot;)&#10;    suspend fun getDownloadCountByState(state: Int): Int&#10;    &#10;    @Query(&quot;SELECT state, COUNT(*) as count FROM download_requests GROUP BY state&quot;)&#10;    suspend fun getDownloadStatistics(): Map&lt;Int, Int&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DataRequestModel.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;data_request_table&quot;)&#10;data class DataRequestModel(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id : Long = System.currentTimeMillis(),&#10;    val downloadId : Long = 0,&#10;    val fileName : String = &quot;&quot;,&#10;    val url : String = &quot;&quot;,&#10;    val progress : Float = 0.0f,&#10;    val downloadedBytes : Long = 0L,&#10;    val totalBytes : Long = 0L,&#10;    val state : Int = 0 // 0: idle, 1: downloading, 2: completed, 3: failed&#10;)" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;download_requests&quot;)&#10;data class DataRequestModel(&#10;    @PrimaryKey&#10;    val downloadId: Long,&#10;    val fileName: String = &quot;&quot;,&#10;    val url: String = &quot;&quot;,&#10;    val filePath: String = &quot;&quot;, // Added: Full file path for resume&#10;    val progress: Float = 0.0f,&#10;    val downloadedBytes: Long = 0L,&#10;    val totalBytes: Long = 0L,&#10;    val state: Int = 0, // Using Constants.STATE_* values&#10;    val createdAt: Long = System.currentTimeMillis(),&#10;    val updatedAt: Long = System.currentTimeMillis(),&#10;    val etag: String? = null, // Added: For server validation&#10;    val retryCount: Int = 0, // Added: Track retry attempts&#10;    val errorMessage: String? = null // Added: Last error message&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DatabaseCache.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DatabaseCache.kt" />
              <option name="originalContent" value="package com.marusys.downloadsdk.db&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;&#10;abstract class DatabaseCache : RoomDatabase() {&#10;&#10;    abstract fun getDataRequestDao() : DataRequestDao&#10;&#10;    companion object {&#10;        private var databaseCache: DatabaseCache? = null&#10;        fun create(context: Context) {&#10;            databaseCache =&#10;                Room.databaseBuilder(context, DatabaseCache::class.java, &quot;data_request&quot;).build()&#10;        }&#10;&#10;        fun getInstance(): DatabaseCache {&#10;            return databaseCache!!&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;&#10;@Database(&#10;    entities = [DataRequestModel::class],&#10;    version = 2,&#10;    exportSchema = false&#10;)&#10;abstract class DatabaseCache : RoomDatabase() {&#10;&#10;    abstract fun getDataRequestDao(): DataRequestDao&#10;&#10;    companion object {&#10;        private const val DATABASE_NAME = &quot;download_requests_db&quot;&#10;        &#10;        @Volatile&#10;        private var INSTANCE: DatabaseCache? = null&#10;        &#10;        // Migration from version 1 to 2 (if users have old database)&#10;        private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;            override fun migrate(database: SupportSQLiteDatabase) {&#10;                // Drop old table if exists and create new one&#10;                database.execSQL(&quot;DROP TABLE IF EXISTS data_request_table&quot;)&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE IF NOT EXISTS download_requests (&#10;                        downloadId INTEGER PRIMARY KEY NOT NULL,&#10;                        fileName TEXT NOT NULL,&#10;                        url TEXT NOT NULL,&#10;                        filePath TEXT NOT NULL,&#10;                        progress REAL NOT NULL,&#10;                        downloadedBytes INTEGER NOT NULL,&#10;                        totalBytes INTEGER NOT NULL,&#10;                        state INTEGER NOT NULL,&#10;                        createdAt INTEGER NOT NULL,&#10;                        updatedAt INTEGER NOT NULL,&#10;                        etag TEXT,&#10;                        retryCount INTEGER NOT NULL,&#10;                        errorMessage TEXT&#10;                    )&#10;                &quot;&quot;&quot;.trimIndent())&#10;            }&#10;        }&#10;        &#10;        fun create(context: Context) {&#10;            synchronized(this) {&#10;                if (INSTANCE == null) {&#10;                    INSTANCE = Room.databaseBuilder(&#10;                        context.applicationContext,&#10;                        DatabaseCache::class.java,&#10;                        DATABASE_NAME&#10;                    )&#10;                    .addMigrations(MIGRATION_1_2)&#10;                    .fallbackToDestructiveMigration() // For development - remove in production&#10;                    .build()&#10;                }&#10;            }&#10;        }&#10;&#10;        fun getInstance(): DatabaseCache {&#10;            return INSTANCE ?: throw IllegalStateException(&#10;                &quot;Database not initialized. Call create(context) first.&quot;&#10;            )&#10;        }&#10;        &#10;        fun closeDatabase() {&#10;            INSTANCE?.close()&#10;            INSTANCE = null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DownloadPersistenceManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DownloadSDK/src/main/java/com/marusys/downloadsdk/db/DownloadPersistenceManager.kt" />
              <option name="updatedContent" value="package com.marusys.downloadsdk.db&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.marusys.downloadsdk.Constants&#10;import com.marusys.downloadsdk.model.DownloadRequestFileModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.io.File&#10;&#10;/**&#10; * Manages persistence of download requests to Room database&#10; * Enables resume functionality when app is reopened&#10; */&#10;class DownloadPersistenceManager private constructor() {&#10;    &#10;    private val TAG = &quot;DownloadPersistence&quot;&#10;    private lateinit var dao: DataRequestDao&#10;    private val persistenceScope = CoroutineScope(Dispatchers.IO)&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadPersistenceManager? = null&#10;        &#10;        fun getInstance(): DownloadPersistenceManager {&#10;            return INSTANCE ?: synchronized(this) {&#10;                INSTANCE ?: DownloadPersistenceManager().also { INSTANCE = it }&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun initialize(context: Context) {&#10;        DatabaseCache.create(context)&#10;        dao = DatabaseCache.getInstance().getDataRequestDao()&#10;        Log.d(TAG, &quot;DownloadPersistenceManager initialized&quot;)&#10;    }&#10;    &#10;    // Save download request to database&#10;    suspend fun saveDownloadRequest(request: DownloadRequestFileModel, filePath: String) {&#10;        withContext(Dispatchers.IO) {&#10;            val dataModel = request.toDataRequestEntity().copy(&#10;                filePath = filePath,&#10;                updatedAt = System.currentTimeMillis()&#10;            )&#10;            dao.insertDownloadRequest(dataModel)&#10;            Log.d(TAG, &quot;Saved download request: ${request.fileName} (ID: ${request.downloadId})&quot;)&#10;        }&#10;    }&#10;    &#10;    // Update download progress in database&#10;    fun updateProgress(downloadId: Long, downloadedBytes: Long, totalBytes: Long) {&#10;        persistenceScope.launch {&#10;            val progress = if (totalBytes &gt; 0) {&#10;                (downloadedBytes.toFloat() / totalBytes.toFloat()) * 100&#10;            } else 0f&#10;            &#10;            dao.updateDownloadProgress(downloadId, downloadedBytes, progress)&#10;            &#10;            if (totalBytes &gt; 0) {&#10;                dao.updateTotalBytes(downloadId, totalBytes)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Update download state in database&#10;    fun updateState(downloadId: Long, state: Int, errorMessage: String? = null) {&#10;        persistenceScope.launch {&#10;            dao.updateDownloadState(downloadId, state)&#10;            errorMessage?.let { &#10;                dao.updateErrorMessage(downloadId, it)&#10;            }&#10;            Log.d(TAG, &quot;Updated state for download $downloadId to ${getStateString(state)}&quot;)&#10;        }&#10;    }&#10;    &#10;    // Update retry count&#10;    fun updateRetryCount(downloadId: Long, retryCount: Int) {&#10;        persistenceScope.launch {&#10;            dao.updateRetryCount(downloadId, retryCount)&#10;        }&#10;    }&#10;    &#10;    // Get incomplete downloads for resume when app opens&#10;    suspend fun getIncompleteDownloads(): List&lt;DownloadRequestFileModel&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            val incompleteDownloads = dao.getIncompleteDownloads()&#10;            Log.d(TAG, &quot;Found ${incompleteDownloads.size} incomplete downloads to resume&quot;)&#10;            incompleteDownloads.map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Get failed downloads for potential retry&#10;    suspend fun getFailedDownloads(): List&lt;DownloadRequestFileModel&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            val failedDownloads = dao.getFailedDownloads()&#10;            Log.d(TAG, &quot;Found ${failedDownloads.size} failed downloads&quot;)&#10;            failedDownloads.map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Get specific download request&#10;    suspend fun getDownloadRequest(downloadId: Long): DownloadRequestFileModel? {&#10;        return withContext(Dispatchers.IO) {&#10;            dao.getDownloadRequest(downloadId)?.toDownloadRequestFileModel()&#10;        }&#10;    }&#10;    &#10;    // Get all downloads for UI display&#10;    suspend fun getAllDownloads(): List&lt;DownloadRequestFileModel&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            dao.getAllDownloads().map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Flow for real-time UI updates&#10;    fun getAllDownloadsFlow(): Flow&lt;List&lt;DownloadRequestFileModel&gt;&gt; {&#10;        return dao.getAllDownloadsFlow().map { list -&gt;&#10;            list.map { it.toDownloadRequestFileModel() }&#10;        }&#10;    }&#10;    &#10;    // Flow for specific download&#10;    fun getDownloadFlow(downloadId: Long): Flow&lt;DownloadRequestFileModel?&gt; {&#10;        return dao.getDownloadRequestFlow(downloadId).map { &#10;            it?.toDownloadRequestFileModel() &#10;        }&#10;    }&#10;    &#10;    // Check if file exists and validate download integrity&#10;    suspend fun validateDownloadFile(downloadId: Long): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            val request = dao.getDownloadRequest(downloadId) ?: return@withContext false&#10;            val file = File(request.filePath)&#10;            &#10;            if (!file.exists()) {&#10;                Log.w(TAG, &quot;Download file not found: ${request.filePath}&quot;)&#10;                return@withContext false&#10;            }&#10;            &#10;            val actualFileSize = file.length()&#10;            val expectedSize = request.downloadedBytes&#10;            &#10;            if (actualFileSize != expectedSize) {&#10;                Log.w(TAG, &quot;File size mismatch. Expected: $expectedSize, Actual: $actualFileSize&quot;)&#10;                // Update database with actual file size&#10;                dao.updateDownloadProgress(downloadId, actualFileSize, &#10;                    if (request.totalBytes &gt; 0) (actualFileSize.toFloat() / request.totalBytes) * 100 else 0f)&#10;                return@withContext false&#10;            }&#10;            &#10;            Log.d(TAG, &quot;Download file validated: ${request.fileName}&quot;)&#10;            true&#10;        }&#10;    }&#10;    &#10;    // Delete download from database&#10;    suspend fun deleteDownload(downloadId: Long) {&#10;        withContext(Dispatchers.IO) {&#10;            dao.deleteDownloadRequest(downloadId)&#10;            Log.d(TAG, &quot;Deleted download request: $downloadId&quot;)&#10;        }&#10;    }&#10;    &#10;    // Cleanup old completed downloads (older than 30 days)&#10;    suspend fun cleanupOldDownloads(daysOld: Int = 30) {&#10;        withContext(Dispatchers.IO) {&#10;            val cutoffTime = System.currentTimeMillis() - (daysOld * 24 * 60 * 60 * 1000L)&#10;            dao.deleteOldCompletedDownloads(cutoffTime)&#10;            Log.d(TAG, &quot;Cleaned up downloads older than $daysOld days&quot;)&#10;        }&#10;    }&#10;    &#10;    // Get download statistics from database&#10;    suspend fun getDownloadStatistics(): Map&lt;Int, Int&gt; {&#10;        return withContext(Dispatchers.IO) {&#10;            dao.getDownloadStatistics()&#10;        }&#10;    }&#10;    &#10;    private fun getStateString(state: Int): String {&#10;        return when (state) {&#10;            Constants.STATE_IDLE -&gt; &quot;Idle&quot;&#10;            Constants.STATE_DOWNLOADING -&gt; &quot;Downloading&quot;&#10;            Constants.STATE_PAUSED -&gt; &quot;Paused&quot;&#10;            Constants.STATE_COMPLETED -&gt; &quot;Completed&quot;&#10;            Constants.STATE_FAILED -&gt; &quot;Failed&quot;&#10;            Constants.STATE_CANCELLED -&gt; &quot;Cancelled&quot;&#10;            Constants.STATE_WAITING_FOR_NETWORK -&gt; &quot;Waiting for Network&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;}&#10;&#10;// Extension functions for conversion between models&#10;fun DataRequestModel.toDownloadRequestFileModel(): DownloadRequestFileModel {&#10;    return DownloadRequestFileModel(&#10;        id = downloadId,&#10;        downloadId = downloadId,&#10;        fileName = fileName,&#10;        url = url,&#10;        progress = progress,&#10;        downloadedBytes = downloadedBytes,&#10;        totalBytes = totalBytes,&#10;        state = state&#10;    )&#10;}&#10;&#10;fun DownloadRequestFileModel.toDataRequestEntity(): DataRequestModel {&#10;    return DataRequestModel(&#10;        downloadId = downloadId,&#10;        fileName = fileName,&#10;        url = url,&#10;        filePath = &quot;&quot;, // Will be set when saving&#10;        progress = progress,&#10;        downloadedBytes = downloadedBytes,&#10;        totalBytes = totalBytes,&#10;        state = state,&#10;        createdAt = System.currentTimeMillis(),&#10;        updatedAt = System.currentTimeMillis(),&#10;        retryCount = 0&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadConstants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadConstants.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;/**&#10; * Constants used throughout the download system&#10; */&#10;object DownloadConstants {&#10;    const val RANGE_HEADER = &quot;Range&quot;&#10;    const val ETAG_HEADER = &quot;ETag&quot;&#10;    const val USER_AGENT_HEADER = &quot;User-Agent&quot;&#10;    &#10;    const val DEFAULT_READ_TIMEOUT_MILLIS = 20_000&#10;    const val DEFAULT_CONNECT_TIMEOUT_MILLIS = 20_000&#10;    const val DEFAULT_BUFFER_SIZE = 8_192&#10;    const val PAUSE_CHECK_DELAY_MILLIS = 100L&#10;    &#10;    const val HTTP_OK = 200&#10;    const val HTTP_PARTIAL_CONTENT = 206&#10;    const val HTTP_RANGE_NOT_SATISFIABLE = 416&#10;    const val HTTP_TEMPORARY_REDIRECT = 307&#10;    const val HTTP_PERMANENT_REDIRECT = 308&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/DownloadExample.kt" />
              <option name="originalContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.File&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Example usage of the download functionality with pause, resume, and cancel operations&#10; */&#10;class DownloadExample {&#10;&#10;    fun demonstrateDownloadOperations() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;&#10;        // Create a download request&#10;        val downloadRequest = DownloadRequest(&#10;            url = &quot;https://example.com/firmware.bin&quot;,&#10;            downloadId = System.currentTimeMillis(),&#10;            fileName = &quot;firmware.bin&quot;,&#10;            connectTimeOut = 30000,&#10;            readTimeOut = 30000,&#10;            downloadedBytes = 0L,&#10;            requestState = RequestState.None&#10;        )&#10;&#10;        // Specify output file&#10;        val outputFile = File(&quot;/path/to/download/firmware.bin&quot;)&#10;&#10;        // Start download&#10;        firmwareManager.download(downloadRequest, outputFile)&#10;&#10;        // Example of pausing after 5 seconds&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            delay(5000)&#10;            println(&quot;Pausing download...&quot;)&#10;            firmwareManager.pause(downloadRequest)&#10;&#10;            // Resume after 3 seconds&#10;            delay(3000)&#10;            println(&quot;Resuming download...&quot;)&#10;            firmwareManager.resume(downloadRequest)&#10;&#10;            // Cancel after 10 more seconds&#10;            delay(10000)&#10;            println(&quot;Cancelling download...&quot;)&#10;            firmwareManager.cancelRequest(downloadRequest)&#10;        }&#10;    }&#10;&#10;    fun monitorDownloadProgress(downloadId: Long) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            while (true) {&#10;                val state = firmwareManager.getRequestState(downloadId)&#10;                val progress = firmwareManager.getDownloadProgress(downloadId)&#10;                val isActive = firmwareManager.isDownloadActive(downloadId)&#10;&#10;                println(&quot;Download ID: $downloadId&quot;)&#10;                println(&quot;State: $state&quot;)&#10;                println(&quot;Progress: $progress bytes&quot;)&#10;                println(&quot;Active: $isActive&quot;)&#10;                println(&quot;---&quot;)&#10;&#10;                // Exit monitoring if download is completed, cancelled, or failed&#10;                if (state in listOf(RequestState.Completed, RequestState.Cancelled, RequestState.Failed)) {&#10;                    break&#10;                }&#10;&#10;                delay(1000) // Check every second&#10;            }&#10;        }&#10;    }&#10;&#10;    fun handleDownloadWithCallbacks() {&#10;        val downloadTask = DownloadTask()&#10;&#10;        // Set up progress callback&#10;        downloadTask.onProgressUpdate = { downloaded, total, percentage -&gt;&#10;            println(&quot;Progress: $downloaded/$total bytes ($percentage%)&quot;)&#10;        }&#10;&#10;        // Set up completion callback&#10;        downloadTask.onDownloadComplete = { success, filePath -&gt;&#10;            if (success) {&#10;                println(&quot;Download completed successfully: $filePath&quot;)&#10;            } else {&#10;                println(&quot;Download failed&quot;)&#10;            }&#10;        }&#10;&#10;        // Set up error callback&#10;        downloadTask.onDownloadError = { error -&gt;&#10;            println(&quot;Download error: $error&quot;)&#10;        }&#10;&#10;        // Example of manual control&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            delay(5000)&#10;            if (downloadTask.isDownloadActive()) {&#10;                downloadTask.pauseDownload()&#10;                println(&quot;Download paused&quot;)&#10;&#10;                delay(2000)&#10;                downloadTask.resumeDownload()&#10;                println(&quot;Download resumed&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware&#10;&#10;import java.io.File&#10;import kotlinx.coroutines.*&#10;&#10;/**&#10; * Clean usage examples demonstrating the refactored download functionality&#10; * Shows proper implementation of the listener pattern and clean API usage&#10; */&#10;class CleanDownloadExample {&#10;    &#10;    fun demonstrateBasicDownload() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        // Create download request using builder pattern for better readability&#10;        val downloadRequest = DownloadRequest.Builder()&#10;            .url(&quot;https://example.com/firmware.bin&quot;)&#10;            .downloadId(System.currentTimeMillis())&#10;            .fileName(&quot;firmware.bin&quot;)&#10;            .connectTimeOut(30_000)&#10;            .readTimeOut(30_000)&#10;            .build()&#10;        &#10;        val outputFile = File(&quot;/path/to/download/firmware.bin&quot;)&#10;        &#10;        // Create listener for handling download events&#10;        val downloadListener = object : DownloadListener {&#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                println(&quot;Download progress: $percentage% ($downloaded/$total bytes)&quot;)&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    println(&quot;Download completed successfully: $filePath&quot;)&#10;                } else {&#10;                    println(&quot;Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;Download error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                println(&quot;Download state changed to: $state&quot;)&#10;            }&#10;        }&#10;        &#10;        // Start download with proper error handling&#10;        try {&#10;            val downloadId = firmwareManager.startDownload(downloadRequest, outputFile, downloadListener)&#10;            println(&quot;Download started with ID: $downloadId&quot;)&#10;        } catch (e: IllegalStateException) {&#10;            println(&quot;Failed to start download: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    fun demonstrateDownloadControl() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        val downloadId = System.currentTimeMillis()&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            // Pause download after 5 seconds&#10;            delay(5_000)&#10;            if (firmwareManager.pauseDownload(downloadId)) {&#10;                println(&quot;Download paused successfully&quot;)&#10;            } else {&#10;                println(&quot;Failed to pause download - download not found or not active&quot;)&#10;            }&#10;            &#10;            // Resume after 3 seconds&#10;            delay(3_000)&#10;            if (firmwareManager.resumeDownload(downloadId)) {&#10;                println(&quot;Download resumed successfully&quot;)&#10;            }&#10;            &#10;            // Cancel after 10 more seconds&#10;            delay(10_000)&#10;            if (firmwareManager.cancelDownload(downloadId)) {&#10;                println(&quot;Download cancelled successfully&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun demonstrateMultipleDownloads() {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        // Start multiple downloads&#10;        val downloadIds = mutableListOf&lt;Long&gt;()&#10;        &#10;        repeat(3) { index -&gt;&#10;            val request = DownloadRequest.Builder()&#10;                .url(&quot;https://example.com/firmware$index.bin&quot;)&#10;                .downloadId(System.currentTimeMillis() + index)&#10;                .fileName(&quot;firmware$index.bin&quot;)&#10;                .build()&#10;                &#10;            val outputFile = File(&quot;/path/to/firmware$index.bin&quot;)&#10;            val downloadId = firmwareManager.startDownload(request, outputFile)&#10;            downloadIds.add(downloadId)&#10;        }&#10;        &#10;        // Monitor all downloads&#10;        monitorDownloads(downloadIds)&#10;        &#10;        // Cancel all downloads after some time&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            delay(30_000)&#10;            firmwareManager.cancelAllDownloads()&#10;            println(&quot;All downloads cancelled&quot;)&#10;        }&#10;    }&#10;    &#10;    private fun monitorDownloads(downloadIds: List&lt;Long&gt;) {&#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        &#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            while (downloadIds.any { firmwareManager.isDownloadActive(it) }) {&#10;                downloadIds.forEach { downloadId -&gt;&#10;                    val state = firmwareManager.getDownloadState(downloadId)&#10;                    val progress = firmwareManager.getDownloadProgress(downloadId)&#10;                    val isActive = firmwareManager.isDownloadActive(downloadId)&#10;                    &#10;                    println(&quot;Download $downloadId - State: $state, Progress: $progress bytes, Active: $isActive&quot;)&#10;                }&#10;                &#10;                println(&quot;Active downloads: ${firmwareManager.getActiveDownloadCount()}&quot;)&#10;                println(&quot;---&quot;)&#10;                &#10;                delay(2_000) // Check every 2 seconds&#10;            }&#10;            &#10;            println(&quot;All downloads completed or stopped&quot;)&#10;        }&#10;    }&#10;    &#10;    fun demonstrateCustomDownloadListener() {&#10;        class CustomDownloadListener(private val downloadName: String) : DownloadListener {&#10;            private var lastProgressTime = System.currentTimeMillis()&#10;            &#10;            override fun onProgressUpdate(downloaded: Long, total: Long, percentage: Int) {&#10;                val currentTime = System.currentTimeMillis()&#10;                if (currentTime - lastProgressTime &gt;= 1000) { // Throttle updates to once per second&#10;                    println(&quot;[$downloadName] Progress: $percentage% - ${formatBytes(downloaded)}/${formatBytes(total)}&quot;)&#10;                    lastProgressTime = currentTime&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadComplete(success: Boolean, filePath: String?) {&#10;                if (success) {&#10;                    println(&quot;[$downloadName] ✅ Download completed: $filePath&quot;)&#10;                } else {&#10;                    println(&quot;[$downloadName] ❌ Download failed&quot;)&#10;                }&#10;            }&#10;            &#10;            override fun onDownloadError(error: String) {&#10;                println(&quot;[$downloadName] ⚠️ Error: $error&quot;)&#10;            }&#10;            &#10;            override fun onDownloadStateChanged(state: DownloadState) {&#10;                val emoji = when (state) {&#10;                    DownloadState.CONNECTING -&gt; &quot;&quot;&#10;                    DownloadState.DOWNLOADING -&gt; &quot;⬇️&quot;&#10;                    DownloadState.PAUSED -&gt; &quot;⏸️&quot;&#10;                    DownloadState.COMPLETED -&gt; &quot;✅&quot;&#10;                    DownloadState.CANCELLED -&gt; &quot;❌&quot;&#10;                    DownloadState.FAILED -&gt; &quot;⚠️&quot;&#10;                    else -&gt; &quot;&quot;&#10;                }&#10;                println(&quot;[$downloadName] $emoji State changed to: $state&quot;)&#10;            }&#10;            &#10;            private fun formatBytes(bytes: Long): String {&#10;                return when {&#10;                    bytes &gt;= 1024 * 1024 -&gt; &quot;${bytes / (1024 * 1024)} MB&quot;&#10;                    bytes &gt;= 1024 -&gt; &quot;${bytes / 1024} KB&quot;&#10;                    else -&gt; &quot;$bytes B&quot;&#10;                }&#10;            }&#10;        }&#10;        &#10;        val firmwareManager = FirmwareManager.getInstance()&#10;        val customListener = CustomDownloadListener(&quot;Firmware Update&quot;)&#10;        &#10;        val request = DownloadRequest.Builder()&#10;            .url(&quot;https://example.com/large-firmware.bin&quot;)&#10;            .downloadId(System.currentTimeMillis())&#10;            .fileName(&quot;large-firmware.bin&quot;)&#10;            .build()&#10;            &#10;        val outputFile = File(&quot;/path/to/large-firmware.bin&quot;)&#10;        firmwareManager.startDownload(request, outputFile, customListener)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/database/DownloadDatabase.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import android.content.Context&#10;&#10;@Database(&#10;    entities = [DownloadEntity::class],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;abstract class DownloadDatabase : RoomDatabase() {&#10;    &#10;    abstract fun downloadDao(): DownloadDao&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: DownloadDatabase? = null&#10;        &#10;        fun getDatabase(context: Context): DownloadDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    DownloadDatabase::class.java,&#10;                    &quot;download_database&quot;&#10;                ).build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/network/NetworkStateReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/network/NetworkStateReceiver.kt" />
              <option name="originalContent" value="&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.util.Log&#10;&#10;class NetworkStateReceiver : BroadcastReceiver() {&#10;    &#10;    private val TAG = &quot;NetworkStateReceiver&quot;&#10;    &#10;    interface NetworkStateListener {&#10;        fun onNetworkAvailable()&#10;        fun onNetworkLost()&#10;    }&#10;    &#10;    companion object {&#10;        var listeners = mutableSetOf&lt;NetworkStateListener&gt;()&#10;        &#10;        fun addListener(listener: NetworkStateListener) {&#10;            listeners.add(listener)&#10;        }&#10;        &#10;        fun removeListener(listener: NetworkStateListener) {&#10;            listeners.remove(listener)&#10;        }&#10;    }&#10;    &#10;    override fun onReceive(context: Context?, intent: Intent?) {&#10;        if (context == null) return&#10;        &#10;        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;        val isConnected = isNetworkAvailable(connectivityManager)&#10;        &#10;        Log.d(TAG, &quot;Network state changed: connected = $isConnected&quot;)&#10;        &#10;        if (isConnected) {&#10;            listeners.forEach { it.onNetworkAvailable() }&#10;        } else {&#10;            listeners.forEach { it.onNetworkLost() }&#10;        }&#10;    }&#10;    &#10;    private fun isNetworkAvailable(connectivityManager: ConnectivityManager): Boolean {&#10;        val network = connectivityManager.activeNetwork ?: return false&#10;        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false&#10;        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.network&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.ConnectivityManager&#10;import android.net.NetworkCapabilities&#10;import android.util.Log&#10;&#10;class NetworkStateReceiver : BroadcastReceiver() {&#10;    &#10;    private val TAG = &quot;NetworkStateReceiver&quot;&#10;    &#10;    interface NetworkStateListener {&#10;        fun onNetworkAvailable()&#10;        fun onNetworkLost()&#10;    }&#10;    &#10;    companion object {&#10;        var listeners = mutableSetOf&lt;NetworkStateListener&gt;()&#10;        &#10;        fun addListener(listener: NetworkStateListener) {&#10;            listeners.add(listener)&#10;        }&#10;        &#10;        fun removeListener(listener: NetworkStateListener) {&#10;            listeners.remove(listener)&#10;        }&#10;    }&#10;    &#10;    override fun onReceive(context: Context?, intent: Intent?) {&#10;        if (context == null) return&#10;        &#10;        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;        val isConnected = isNetworkAvailable(connectivityManager)&#10;        &#10;        Log.d(TAG, &quot;Network state changed: connected = $isConnected&quot;)&#10;        &#10;        if (isConnected) {&#10;            listeners.forEach { it.onNetworkAvailable() }&#10;        } else {&#10;            listeners.forEach { it.onNetworkLost() }&#10;        }&#10;    }&#10;    &#10;    private fun isNetworkAvailable(connectivityManager: ConnectivityManager): Boolean {&#10;        val network = connectivityManager.activeNetwork ?: return false&#10;        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false&#10;        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Color.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Color.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.ui.theme&#10;&#10;import androidx.compose.ui.graphics.Color&#10;&#10;val Purple80 = Color(0xFFD0BCFF)&#10;val PurpleGrey80 = Color(0xFFCCC2DC)&#10;val Pink80 = Color(0xFFEFB8C8)&#10;&#10;val Purple40 = Color(0xFF6650a4)&#10;val PurpleGrey40 = Color(0xFF625b71)&#10;val Pink40 = Color(0xFF7D5260)&#10;&#10;// Custom colors for download app&#10;val DownloadBlue = Color(0xFF2196F3)&#10;val DownloadGreen = Color(0xFF4CAF50)&#10;val DownloadRed = Color(0xFFFF5722)&#10;val DownloadOrange = Color(0xFFFF9800)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Theme.kt" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.ui.theme&#10;&#10;import android.os.Build&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.material3.dynamicDarkColorScheme&#10;import androidx.compose.material3.dynamicLightColorScheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.platform.LocalContext&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Purple80,&#10;    secondary = PurpleGrey80,&#10;    tertiary = Pink80,&#10;    error = DownloadRed,&#10;    primaryContainer = DownloadBlue,&#10;    secondaryContainer = DownloadGreen&#10;)&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Purple40,&#10;    secondary = PurpleGrey40,&#10;    tertiary = Pink40,&#10;    error = DownloadRed,&#10;    primaryContainer = DownloadBlue.copy(alpha = 0.1f),&#10;    secondaryContainer = DownloadGreen.copy(alpha = 0.1f)&#10;)&#10;&#10;@Composable&#10;fun UpgradeFirmwareTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    // Dynamic color is available on Android 12+&#10;    dynamicColor: Boolean = true,&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = when {&#10;        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {&#10;            val context = LocalContext.current&#10;            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)&#10;        }&#10;&#10;        darkTheme -&gt; DarkColorScheme&#10;        else -&gt; LightColorScheme&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = Typography,&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Type.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/marusys/upgradefirmware/ui/theme/Type.kt" />
              <option name="originalContent" value="&#10;import androidx.compose.material3.Typography&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.sp&#10;&#10;// Set of Material typography styles to start with&#10;val Typography = Typography(&#10;    bodyLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Normal,&#10;        fontSize = 16.sp,&#10;        lineHeight = 24.sp,&#10;        letterSpacing = 0.5.sp&#10;    ),&#10;    titleLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Bold,&#10;        fontSize = 22.sp,&#10;        lineHeight = 28.sp,&#10;        letterSpacing = 0.sp&#10;    ),&#10;    labelSmall = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Medium,&#10;        fontSize = 11.sp,&#10;        lineHeight = 16.sp,&#10;        letterSpacing = 0.5.sp&#10;    )&#10;)" />
              <option name="updatedContent" value="package com.marusys.upgradefirmware.ui.theme&#10;&#10;import androidx.compose.material3.Typography&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.sp&#10;&#10;// Set of Material typography styles to start with&#10;val Typography = Typography(&#10;    bodyLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Normal,&#10;        fontSize = 16.sp,&#10;        lineHeight = 24.sp,&#10;        letterSpacing = 0.5.sp&#10;    ),&#10;    titleLarge = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Bold,&#10;        fontSize = 22.sp,&#10;        lineHeight = 28.sp,&#10;        letterSpacing = 0.sp&#10;    ),&#10;    labelSmall = TextStyle(&#10;        fontFamily = FontFamily.Default,&#10;        fontWeight = FontWeight.Medium,&#10;        fontSize = 11.sp,&#10;        lineHeight = 16.sp,&#10;        letterSpacing = 0.5.sp&#10;    )&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>